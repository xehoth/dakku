#ifndef DAKKU_MATH_VECTOR_BASE_H_
#define DAKKU_MATH_VECTOR_BASE_H_
#include <math/fwd.h>
#include <logger/logger.h>

namespace dakku {

/**
 * @brief vector base class
 *
 * @tparam T type
 * @tparam size dimension of the vector
 * @tparam Derived derived class type
 */
template <ArithmeticType T, size_t size, typename Derived>
class VectorBase {
 public:
  /**
   * @brief Construct a new Vector Base object with
   * all components initialized to zero
   *
   */
  explicit VectorBase() : _data() {}

  /**
   * @brief Construct a new Vector Base object with
   * all components initialized to `value`
   *
   * @tparam Arg value type
   * @param value init value
   */
  template <ArithmeticType Arg>
  explicit VectorBase(Arg value) {
    set(value);
  }

  /**
   * @brief Construct a new Vector Base object with given values
   *
   * @tparam Args value types
   * @param args init values
   */
  template <ArithmeticType... Args>
  requires(sizeof...(Args) == size) explicit VectorBase(Args &&...args) {
    set(std::forward<Args>(args)...);
  }

  /**
   * @brief set all components to `value`
   *
   * @tparam Arg value type
   * @param value the given value
   */
  template <ArithmeticType Arg>
  void set(Arg value) {
    for (size_t i = 0; i < size; ++i) _data[i] = value;
  }

  /**
   * @brief set data[index] to value
   *
   * @tparam Arg value type
   * @param index the index of the component
   * @param value the given value
   */
  template <ArithmeticType Arg>
  void setByIndex(size_t index, Arg value) {
    DAKKU_CHECK(0 <= index && index < size, "index out of range: {} >= {}", index,
                size);
    _data[index] = value;
  }

  /**
   * @brief set data to args
   *
   * @tparam Args value types
   * @tparam Is indices (generated by std::index_sequence_for)
   * @param args values
   */
  template <ArithmeticType... Args, size_t... Is>
  requires(sizeof...(Args) == size) void set(std::index_sequence<Is...>,
                                             Args &&...args) {
    (setByIndex(Is, std::forward<Args>(args)), ...);
  }

  /**
   * @brief set data to args
   *
   * @tparam Args value typs
   * @param args values
   */
  template <ArithmeticType... Args>
  requires(sizeof...(Args) == size) void set(Args &&...args) {
    set(std::index_sequence_for<Args...>{}, std::forward<Args>(args)...);
  }

 protected:
  /// vector base data
  T _data[size];
};
}  // namespace dakku
#endif