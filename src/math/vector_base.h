#ifndef DAKKU_MATH_VECTOR_BASE_H_
#define DAKKU_MATH_VECTOR_BASE_H_
#include <math/fwd.h>
#include <logger/logger.h>
#include <array>
#include <algorithm>
#include <string>
#include <ostream>

namespace dakku {

/**
 * @brief vector base class
 *
 * @tparam T type
 * @tparam size dimension of the vector
 * @tparam Derived derived class type
 */
template <ArithmeticType T, size_t S, typename Derived>
class VectorBase {
 public:
  /**
   * @brief Construct a new Vector Base object with
   * all components initialized to zero
   *
   */
  explicit VectorBase() : _data() {}

  /**
   * @brief Construct a new Vector Base object with
   * all components initialized to `value`
   *
   * @tparam Arg value type
   * @param value init value
   */
  template <ArithmeticType Arg>
  explicit VectorBase(Arg value) {
    set(value);
    DAKKU_CHECK(!hasNaNs(), "has nan");
  }

  /**
   * @brief Construct a new Vector Base object with a vector expression
   *
   * @tparam Other
   * @tparam OtherDerived
   * @tparam Expr
   * @param expr the given expression
   */
  template <ArithmeticType Other, typename OtherDerived>
  explicit VectorBase(const VectorBase<Other, S, OtherDerived> &other) {
    set(other);
    DAKKU_CHECK(!hasNaNs(), "has nan");
  }

  VectorBase(const VectorBase &other) : _data(other._data) {
    DAKKU_CHECK(!hasNaNs(), "has nan");
  }
  VectorBase(VectorBase &&other) noexcept : _data(std::move(other._data)) {
    DAKKU_CHECK(!hasNaNs(), "has nan");
  }
  VectorBase &operator=(const VectorBase &other) {
    if (this == &other) return *this;
    _data = other._data;
    DAKKU_CHECK(!hasNaNs(), "has nan");
    return *this;
  }
  VectorBase &operator=(VectorBase &&other) noexcept {
    if (this == &other) return *this;
    _data = std::move(other._data);
    DAKKU_CHECK(!hasNaNs(), "has nan");
    return *this;
  }

  /**
   * @brief Construct a new Vector Base object with given values
   *
   * @tparam Args value types
   * @param args init values
   */
  template <ArithmeticType... Args>
  requires(sizeof...(Args) == S) explicit VectorBase(Args &&...args) {
    set(std::forward<Args>(args)...);
  }

  /**
   * @brief set all components to `value`
   *
   * @tparam Arg value type
   * @param value the given value
   */
  template <ArithmeticType Arg>
  void set(Arg value) {
    _data.fill(static_cast<T>(value));
  }

  /**
   * @brief set data[index] to value
   *
   * @tparam Arg value type
   * @param index the index of the component
   * @param value the given value
   */
  template <ArithmeticType Arg>
  void setByIndex(size_t index, Arg value) {
    DAKKU_CHECK(0 <= index && index < S, "index out of range: {} >= {}", index,
                S);
    _data[index] = static_cast<T>(value);
  }

  /**
   * @brief set data to args
   *
   * @tparam Args value types
   * @tparam Is indices (generated by std::index_sequence_for)
   * @param args values
   */
  template <ArithmeticType... Args, size_t... Is>
  requires(sizeof...(Args) == S) void set(std::index_sequence<Is...>,
                                          Args &&...args) {
    (setByIndex(Is, std::forward<Args>(args)), ...);
  }

  /**
   * @brief set data to args
   *
   * @tparam Args value types
   * @param args values
   */
  template <ArithmeticType... Args>
  requires(sizeof...(Args) == S) void set(Args &&...args) {
    set(std::index_sequence_for<Args...>{}, std::forward<Args>(args)...);
  }

  /**
   * @brief set data by `rhs`'s data
   *
   * @tparam Other `rhs` type
   * @tparam OtherDerived `rhs` derived type
   * @param rhs the given vector
   */
  template <ArithmeticType Other, typename OtherDerived>
  void set(const VectorBase<Other, S, OtherDerived> &rhs) {
    for (size_t i = 0; i < S; ++i) _data[i] = static_cast<T>(rhs[i]);
  }

  /**
   * @brief check whether there are nan components
   *
   * @return true vector contains nan
   * @return false vector does not contain nans
   */
  [[nodiscard]] bool hasNaNs() const {
    return std::any_of(std::begin(_data), std::end(_data),
                       [](T x) { return isNaN(x); });
  }

  /**
   * @brief get i'th component
   *
   * @param i the index
   * @return the value
   */
  const T &get(size_t i) const { return _data[i]; }

  /**
   * @brief convert vector to string
   *
   * @return the converted string
   */
  [[nodiscard]] std::string toString() const {
    std::string ret{"["};
    for (size_t i = 0; i < _data.size(); ++i) {
      ret += std::to_string(_data[i]);
      if (i + 1 != _data.size()) ret += ", ";
    }
    return ret + "]";
  }

  /**
   * @brief output the vector
   *
   * @param os ostream
   * @param vec the vector to output
   * @return ostream
   */
  friend std::ostream &operator<<(std::ostream &os, const VectorBase &vec) {
    return os << vec.toString();
  }

  /**
   * @brief size of the vector
   *
   * @return size
   */
  [[nodiscard]] size_t size() const { return S; }

  /**
   * @brief get i'th value
   *
   * @param i index
   * @return value
   */
  const T &operator[](size_t i) const { return _data[i]; }

  /**
   * @brief get i'th value
   *
   * @param i index
   * @return value
   */
  T &operator[](size_t i) {
    return const_cast<T &>(static_cast<const VectorBase &>(*this)[i]);
  }

  /**
   * @brief negation of the vector
   *
   * @return $-\vec v$
   */
  Derived operator-() const {
    Derived ret = derived();
    for (size_t i = 0; i < S; ++i) ret[i] = -ret[i];
    return ret;
  }

  /**
   * @brief get derived class
   *
   */
  const Derived &derived() const { return static_cast<const Derived &>(*this); }

  /**
   * @brief get derived class
   *
   */
  Derived &derived() {
    return const_cast<Derived &>(
        static_cast<const VectorBase &>(*this).derived());
  }

  /**
   * @brief addition
   *
   * @param rhs another vector
   * @return this
   */
  Derived &operator+=(const Derived &rhs) {
    for (size_t i = 0; i < S; ++i) _data[i] += rhs[i];
    return derived();
  }

  /**
   * @brief addition
   *
   * @param rhs scalar
   * @return this
   */
  template <ArithmeticType V>
  Derived &operator+=(const V &rhs) {
    for (size_t i = 0; i < S; ++i) _data[i] += rhs;
    return derived();
  }

  /**
   * @brief addition
   *
   * @param a vector $\vec a$
   * @param b vector $\vec b$
   * @return $\vec a + \vec b$
   */
  friend Derived operator+(const Derived &a, const Derived &b) {
    Derived ret = a;
    ret += b;
    return ret;
  }

  /**
   * @brief addition
   *
   * @param a $\vec a$
   * @param b $b$
   * @return elementwise add b
   */
  template <ArithmeticType U>
  friend Derived operator+(const Derived &a, const U &b) {
    Derived ret = a;
    ret += b;
    return ret;
  }

  /**
   * @brief addition
   *
   * @param a $a$
   * @param b $\vec b$
   * @return elementwise add a
   */
  template <ArithmeticType U>
  friend Derived operator+(const U &a, const Derived &b) {
    return b + a;
  }

  /**
   * @brief subtraction
   *
   * @param rhs another vector
   * @return this
   */
  Derived &operator-=(const Derived &rhs) {
    for (size_t i = 0; i < S; ++i) _data[i] -= rhs[i];
    return derived();
  }

  /**
   * @brief subtraction
   *
   * @param rhs scalar
   * @return this
   */
  template <ArithmeticType V>
  Derived &operator-=(const V &rhs) {
    for (size_t i = 0; i < S; ++i) _data[i] -= rhs;
    return derived();
  }

  /**
   * @brief subtraction
   *
   * @param a $\vec a$
   * @param b $b$
   * @return elementwise sub
   */
  template <ArithmeticType U>
  friend Derived operator-(const Derived &a, const U &b) {
    Derived ret = a;
    ret -= b;
    return ret;
  }

  /**
   * @brief subtraction
   *
   * @param a $a$
   * @param b $\vec b$
   * @return elementwise sub
   */
  template <ArithmeticType U>
  friend Derived operator-(const U &a, const Derived &b) {
    Derived ret = -b;
    ret += a;
    return ret;
  }

  /**
   * @brief multiplication
   *
   * @param rhs another vector
   * @return this
   */
  Derived &operator*=(const Derived &rhs) {
    for (size_t i = 0; i < S; ++i) _data[i] *= rhs[i];
    return derived();
  }

  /**
   * @brief multiplication
   *
   * @param rhs scalar
   * @return this
   */
  template <ArithmeticType V>
  Derived &operator*=(const V &rhs) {
    for (size_t i = 0; i < S; ++i) _data[i] *= rhs;
    return derived();
  }

  /**
   * @brief multiplication
   *
   * @param a vector $\vec a$
   * @param b vector $\vec b$
   * @return elementwise mul
   */
  friend Derived operator*(const Derived &a, const Derived &b) {
    Derived ret = a;
    ret *= b;
    return ret;
  }

  /**
   * @brief multiplication
   *
   * @param a $\vec a$
   * @param b $b$
   * @return $b\vec a$
   */
  template <ArithmeticType U>
  friend Derived operator*(const Derived &a, const U &b) {
    Derived ret = a;
    ret *= b;
    return ret;
  }

  /**
   * @brief multiplication
   *
   * @param a $a$
   * @param b $\vec b$
   * @return elementwise mul
   */
  template <ArithmeticType U>
  friend Derived operator*(const U &a, const Derived &b) {
    return b * a;
  }

  /**
   * @brief division
   *
   * @param rhs another vector
   * @return this
   */
  Derived &operator/=(const Derived &rhs) {
    for (size_t i = 0; i < S; ++i) _data[i] /= rhs[i];
    return derived();
  }

  /**
   * @brief division
   *
   * @param rhs scalar
   * @return this
   */
  template <ArithmeticType V>
  Derived &operator/=(const V &rhs) {
    return derived() *= static_cast<T>(T{1} / rhs);
  }

  /**
   * @brief division
   *
   * @param a vector $\vec a$
   * @param b vector $\vec b$
   * @return elementwise div
   */
  friend Derived operator/(const Derived &a, const Derived &b) {
    Derived ret = a;
    ret /= b;
    return ret;
  }

  /**
   * @brief division
   *
   * @param a $\vec a$
   * @param b $b$
   * @return $\vec a / b$
   */
  template <ArithmeticType U>
  friend Derived operator/(const Derived &a, const U &b) {
    Derived ret = a;
    ret /= b;
    return ret;
  }

  /**
   * @brief division
   *
   * @param a $a$
   * @param b $\vec b$
   * @return elementwise div (broad cast $a$)
   */
  template <ArithmeticType U>
  friend Derived operator/(const U &a, const Derived &b) {
    return Derived(a) / b;
  }

 protected:
  /// vector base data
  std::array<T, S> _data;
};

/*! @page vector_base Vector Base

dakku currently use naive implementation, may use intrinsics and expression
templates later.
*/
}  // namespace dakku
#endif