#include <core/transform.h>

namespace dakku {

Matrix4x4 transpose(const Matrix4x4 &m) {
  return {m[0][0], m[1][0], m[2][0], m[3][0], m[0][1], m[1][1],
          m[2][1], m[3][1], m[0][2], m[1][2], m[2][2], m[3][2],
          m[0][3], m[1][3], m[2][3], m[3][3]};
}

Matrix4x4 Matrix4x4::mul(const Matrix4x4 &m1, const Matrix4x4 &m2) {
  Matrix4x4 c;
  for (int i = 0; i < 4; ++i)
    for (int j = 0; j < 4; ++j)
      c.m[i][j] = m1.m[i][0] * m2.m[0][j] + m1.m[i][1] * m2.m[1][j] +
                  m1.m[i][2] * m2.m[2][j] + m1.m[i][3] * m2.m[3][j];
  return c;
}

Matrix4x4 inverse(const Matrix4x4 &m) {
  Matrix4x4 inv;
  inv[0][0] = m[1][1] * m[2][2] * m[3][3] - m[1][1] * m[3][2] * m[2][3] -
              m[1][2] * m[2][1] * m[3][3] + m[1][2] * m[3][1] * m[2][3] +
              m[1][3] * m[2][1] * m[3][2] - m[1][3] * m[3][1] * m[2][2];

  inv[0][1] = -m[0][1] * m[2][2] * m[3][3] + m[0][1] * m[3][2] * m[2][3] +
              m[0][2] * m[2][1] * m[3][3] - m[0][2] * m[3][1] * m[2][3] -
              m[0][3] * m[2][1] * m[3][2] + m[0][3] * m[3][1] * m[2][2];

  inv[0][2] = m[0][1] * m[1][2] * m[3][3] - m[0][1] * m[3][2] * m[1][3] -
              m[0][2] * m[1][1] * m[3][3] + m[0][2] * m[3][1] * m[1][3] +
              m[0][3] * m[1][1] * m[3][2] - m[0][3] * m[3][1] * m[1][2];

  inv[0][3] = -m[0][1] * m[1][2] * m[2][3] + m[0][1] * m[2][2] * m[1][3] +
              m[0][2] * m[1][1] * m[2][3] - m[0][2] * m[2][1] * m[1][3] -
              m[0][3] * m[1][1] * m[2][2] + m[0][3] * m[2][1] * m[1][2];

  inv[1][0] = -m[1][0] * m[2][2] * m[3][3] + m[1][0] * m[3][2] * m[2][3] +
              m[1][2] * m[2][0] * m[3][3] - m[1][2] * m[3][0] * m[2][3] -
              m[1][3] * m[2][0] * m[3][2] + m[1][3] * m[3][0] * m[2][2];

  inv[1][1] = m[0][0] * m[2][2] * m[3][3] - m[0][0] * m[3][2] * m[2][3] -
              m[0][2] * m[2][0] * m[3][3] + m[0][2] * m[3][0] * m[2][3] +
              m[0][3] * m[2][0] * m[3][2] - m[0][3] * m[3][0] * m[2][2];

  inv[1][2] = -m[0][0] * m[1][2] * m[3][3] + m[0][0] * m[3][2] * m[1][3] +
              m[0][2] * m[1][0] * m[3][3] - m[0][2] * m[3][0] * m[1][3] -
              m[0][3] * m[1][0] * m[3][2] + m[0][3] * m[3][0] * m[1][2];

  inv[1][3] = m[0][0] * m[1][2] * m[2][3] - m[0][0] * m[2][2] * m[1][3] -
              m[0][2] * m[1][0] * m[2][3] + m[0][2] * m[2][0] * m[1][3] +
              m[0][3] * m[1][0] * m[2][2] - m[0][3] * m[2][0] * m[1][2];

  inv[2][0] = m[1][0] * m[2][1] * m[3][3] - m[1][0] * m[3][1] * m[2][3] -
              m[1][1] * m[2][0] * m[3][3] + m[1][1] * m[3][0] * m[2][3] +
              m[1][3] * m[2][0] * m[3][1] - m[1][3] * m[3][0] * m[2][1];

  inv[2][1] = -m[0][0] * m[2][1] * m[3][3] + m[0][0] * m[3][1] * m[2][3] +
              m[0][1] * m[2][0] * m[3][3] - m[0][1] * m[3][0] * m[2][3] -
              m[0][3] * m[2][0] * m[3][1] + m[0][3] * m[3][0] * m[2][1];

  inv[2][2] = m[0][0] * m[1][1] * m[3][3] - m[0][0] * m[3][1] * m[1][3] -
              m[0][1] * m[1][0] * m[3][3] + m[0][1] * m[3][0] * m[1][3] +
              m[0][3] * m[1][0] * m[3][1] - m[0][3] * m[3][0] * m[1][1];

  inv[2][3] = -m[0][0] * m[1][1] * m[2][3] + m[0][0] * m[2][1] * m[1][3] +
              m[0][1] * m[1][0] * m[2][3] - m[0][1] * m[2][0] * m[1][3] -
              m[0][3] * m[1][0] * m[2][1] + m[0][3] * m[2][0] * m[1][1];

  inv[3][0] = -m[1][0] * m[2][1] * m[3][2] + m[1][0] * m[3][1] * m[2][2] +
              m[1][1] * m[2][0] * m[3][2] - m[1][1] * m[3][0] * m[2][2] -
              m[1][2] * m[2][0] * m[3][1] + m[1][2] * m[3][0] * m[2][1];

  inv[3][1] = m[0][0] * m[2][1] * m[3][2] - m[0][0] * m[3][1] * m[2][2] -
              m[0][1] * m[2][0] * m[3][2] + m[0][1] * m[3][0] * m[2][2] +
              m[0][2] * m[2][0] * m[3][1] - m[0][2] * m[3][0] * m[2][1];

  inv[3][2] = -m[0][0] * m[1][1] * m[3][2] + m[0][0] * m[3][1] * m[1][2] +
              m[0][1] * m[1][0] * m[3][2] - m[0][1] * m[3][0] * m[1][2] -
              m[0][2] * m[1][0] * m[3][1] + m[0][2] * m[3][0] * m[1][1];

  inv[3][3] = m[0][0] * m[1][1] * m[2][2] - m[0][0] * m[2][1] * m[1][2] -
              m[0][1] * m[1][0] * m[2][2] + m[0][1] * m[2][0] * m[1][2] +
              m[0][2] * m[1][0] * m[2][1] - m[0][2] * m[2][0] * m[1][1];

  float det = m[0][0] * inv[0][0] + m[1][0] * inv[0][1] + m[2][0] * inv[0][2] +
              m[3][0] * inv[0][3];

  if (det == 0) {
    DAKKU_ERR("singular matrix");
  }
  det = 1 / det;

  for (int i = 0; i < 4; ++i)
    for (int j = 0; j < 4; ++j) inv[i][j] *= det;
  return inv;
}
}  // namespace dakku