{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"dakku documentation This is the documentation of dakku renderer. Vector Base Updated on 2022-04-07 at 06:53:17 +0000","title":"dakku documentation"},{"location":"#dakku-documentation","text":"This is the documentation of dakku renderer. Vector Base Updated on 2022-04-07 at 06:53:17 +0000","title":"dakku documentation"},{"location":"Classes/","text":"Classes namespace dakku dakku namespace class Bounds2 2d bounding box class Bounds2iIterator 2d integer bounds iterator, iterate all pixels inside class Bounds3 3d bounding box class BoundsBase bounding box base class Class RTTI support. class Logger logger class struct Matrix4x4 4x4 matrix class Normal normal class Point point class Property property class, containing many data types, similar to json class Vector vector class VectorBase vector base class namespace std Updated on 2022-04-07 at 06:53:17 +0000","title":"Classes"},{"location":"Classes/#classes","text":"namespace dakku dakku namespace class Bounds2 2d bounding box class Bounds2iIterator 2d integer bounds iterator, iterate all pixels inside class Bounds3 3d bounding box class BoundsBase bounding box base class Class RTTI support. class Logger logger class struct Matrix4x4 4x4 matrix class Normal normal class Point point class Property property class, containing many data types, similar to json class Vector vector class VectorBase vector base class namespace std Updated on 2022-04-07 at 06:53:17 +0000","title":"Classes"},{"location":"Classes/classdakku_1_1Bounds2/","text":"dakku::Bounds2 2d bounding box More... #include <bounds.h> Inherits from dakku::BoundsBase< T, 2 > Public Functions Name decltype(auto) area () const get the area of bounds Additional inherited members Public Functions inherited from dakku::BoundsBase< T, 2 > Name BoundsBase () =default default constructor BoundsBase (const Point < T, S > & p) Construct a new Bounds2 with a point. BoundsBase (const Point < T, S > & p1, const Point < T, S > & p2) Construct a new Bounds Base object with two points (take min/max of them to pMin and pMax) template <ArithmeticType U> operator BoundsBase< U, S > () const cast data type of bounds Vector < T, S > diagonal () const get the diagonal of the bounding box size_t maxExtent () const get the dimension who has the maximum extent bool operator== (const BoundsBase & rhs) const bool operator!= (const BoundsBase & rhs) const Point < T, S > lerp (const Point < float, S > & t) const linera interpolation between pMin and pMax Vector < T, S > offset (const Point < T, S > & p) const get the offset \\(v\\) of a point, p = o + v * d void boundingSphere ( Point < T, S > & center, float & rad) get the bounding sphere of the bounds Public Attributes inherited from dakku::BoundsBase< T, 2 > Name Point < T, S > pMin left bottom corner of the bounds Point < T, S > pMax right top corner of the bounds Friends inherited from dakku::BoundsBase< T, 2 > Name bool overlaps (const BoundsBase & a, const BoundsBase & b) check whether two bounds overlaps bool inside (const Point < T, S > & p, const BoundsBase & b) check whether point is inside the bounds (exclusive) bool insideExclusive (const Point < T, S > & p, const BoundsBase & b) check whether point is inside the bounds (inclusive) decltype(auto) distanceSquared (const Point < T, S > & p, const BoundsBase & b) minimum squared distance between point and bounds, if inside return 0 decltype(auto) distance (const Point < T, S > & p, const BoundsBase & b) minimum distance between point and bounds, if inside return 0 Detailed Description template < ArithmeticType T > class dakku :: Bounds2 ; 2d bounding box Public Functions Documentation function area inline decltype ( auto ) area () const get the area of bounds Return : the area Updated on 2022-04-07 at 06:53:17 +0000","title":"dakku::Bounds2"},{"location":"Classes/classdakku_1_1Bounds2/#dakkubounds2","text":"2d bounding box More... #include <bounds.h> Inherits from dakku::BoundsBase< T, 2 >","title":"dakku::Bounds2"},{"location":"Classes/classdakku_1_1Bounds2/#public-functions","text":"Name decltype(auto) area () const get the area of bounds","title":"Public Functions"},{"location":"Classes/classdakku_1_1Bounds2/#additional-inherited-members","text":"Public Functions inherited from dakku::BoundsBase< T, 2 > Name BoundsBase () =default default constructor BoundsBase (const Point < T, S > & p) Construct a new Bounds2 with a point. BoundsBase (const Point < T, S > & p1, const Point < T, S > & p2) Construct a new Bounds Base object with two points (take min/max of them to pMin and pMax) template <ArithmeticType U> operator BoundsBase< U, S > () const cast data type of bounds Vector < T, S > diagonal () const get the diagonal of the bounding box size_t maxExtent () const get the dimension who has the maximum extent bool operator== (const BoundsBase & rhs) const bool operator!= (const BoundsBase & rhs) const Point < T, S > lerp (const Point < float, S > & t) const linera interpolation between pMin and pMax Vector < T, S > offset (const Point < T, S > & p) const get the offset \\(v\\) of a point, p = o + v * d void boundingSphere ( Point < T, S > & center, float & rad) get the bounding sphere of the bounds Public Attributes inherited from dakku::BoundsBase< T, 2 > Name Point < T, S > pMin left bottom corner of the bounds Point < T, S > pMax right top corner of the bounds Friends inherited from dakku::BoundsBase< T, 2 > Name bool overlaps (const BoundsBase & a, const BoundsBase & b) check whether two bounds overlaps bool inside (const Point < T, S > & p, const BoundsBase & b) check whether point is inside the bounds (exclusive) bool insideExclusive (const Point < T, S > & p, const BoundsBase & b) check whether point is inside the bounds (inclusive) decltype(auto) distanceSquared (const Point < T, S > & p, const BoundsBase & b) minimum squared distance between point and bounds, if inside return 0 decltype(auto) distance (const Point < T, S > & p, const BoundsBase & b) minimum distance between point and bounds, if inside return 0","title":"Additional inherited members"},{"location":"Classes/classdakku_1_1Bounds2/#detailed-description","text":"template < ArithmeticType T > class dakku :: Bounds2 ; 2d bounding box","title":"Detailed Description"},{"location":"Classes/classdakku_1_1Bounds2/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Classes/classdakku_1_1Bounds2/#function-area","text":"inline decltype ( auto ) area () const get the area of bounds Return : the area Updated on 2022-04-07 at 06:53:17 +0000","title":"function area"},{"location":"Classes/classdakku_1_1Bounds2iIterator/","text":"dakku::Bounds2iIterator 2d integer bounds iterator, iterate all pixels inside #include <bounds.h> Inherits from std::forward_iterator_tag Public Functions Name Bounds2iIterator (const Bounds2i & b, const Point2i & p) Bounds2iIterator operator++ () Bounds2iIterator operator++ (int ) bool operator== (const Bounds2iIterator & rhs) const bool operator!= (const Bounds2iIterator & rhs) const Point2i operator* () const Public Functions Documentation function Bounds2iIterator inline explicit Bounds2iIterator ( const Bounds2i & b , const Point2i & p ) function operator++ inline Bounds2iIterator operator ++ () function operator++ inline Bounds2iIterator operator ++ ( int ) function operator== inline bool operator == ( const Bounds2iIterator & rhs ) const function operator!= inline bool operator != ( const Bounds2iIterator & rhs ) const function operator* inline Point2i operator * () const Updated on 2022-04-07 at 06:53:17 +0000","title":"dakku::Bounds2iIterator"},{"location":"Classes/classdakku_1_1Bounds2iIterator/#dakkubounds2iiterator","text":"2d integer bounds iterator, iterate all pixels inside #include <bounds.h> Inherits from std::forward_iterator_tag","title":"dakku::Bounds2iIterator"},{"location":"Classes/classdakku_1_1Bounds2iIterator/#public-functions","text":"Name Bounds2iIterator (const Bounds2i & b, const Point2i & p) Bounds2iIterator operator++ () Bounds2iIterator operator++ (int ) bool operator== (const Bounds2iIterator & rhs) const bool operator!= (const Bounds2iIterator & rhs) const Point2i operator* () const","title":"Public Functions"},{"location":"Classes/classdakku_1_1Bounds2iIterator/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Classes/classdakku_1_1Bounds2iIterator/#function-bounds2iiterator","text":"inline explicit Bounds2iIterator ( const Bounds2i & b , const Point2i & p )","title":"function Bounds2iIterator"},{"location":"Classes/classdakku_1_1Bounds2iIterator/#function-operator","text":"inline Bounds2iIterator operator ++ ()","title":"function operator++"},{"location":"Classes/classdakku_1_1Bounds2iIterator/#function-operator_1","text":"inline Bounds2iIterator operator ++ ( int )","title":"function operator++"},{"location":"Classes/classdakku_1_1Bounds2iIterator/#function-operator_2","text":"inline bool operator == ( const Bounds2iIterator & rhs ) const","title":"function operator=="},{"location":"Classes/classdakku_1_1Bounds2iIterator/#function-operator_3","text":"inline bool operator != ( const Bounds2iIterator & rhs ) const","title":"function operator!="},{"location":"Classes/classdakku_1_1Bounds2iIterator/#function-operator_4","text":"inline Point2i operator * () const Updated on 2022-04-07 at 06:53:17 +0000","title":"function operator*"},{"location":"Classes/classdakku_1_1Bounds3/","text":"dakku::Bounds3 3d bounding box More... #include <bounds.h> Inherits from dakku::BoundsBase< T, 3 > Additional inherited members Public Functions inherited from dakku::BoundsBase< T, 3 > Name BoundsBase () =default default constructor BoundsBase (const Point < T, S > & p) Construct a new Bounds2 with a point. BoundsBase (const Point < T, S > & p1, const Point < T, S > & p2) Construct a new Bounds Base object with two points (take min/max of them to pMin and pMax) template <ArithmeticType U> operator BoundsBase< U, S > () const cast data type of bounds Vector < T, S > diagonal () const get the diagonal of the bounding box size_t maxExtent () const get the dimension who has the maximum extent bool operator== (const BoundsBase & rhs) const bool operator!= (const BoundsBase & rhs) const Point < T, S > lerp (const Point < float, S > & t) const linera interpolation between pMin and pMax Vector < T, S > offset (const Point < T, S > & p) const get the offset \\(v\\) of a point, p = o + v * d void boundingSphere ( Point < T, S > & center, float & rad) get the bounding sphere of the bounds Public Attributes inherited from dakku::BoundsBase< T, 3 > Name Point < T, S > pMin left bottom corner of the bounds Point < T, S > pMax right top corner of the bounds Friends inherited from dakku::BoundsBase< T, 3 > Name bool overlaps (const BoundsBase & a, const BoundsBase & b) check whether two bounds overlaps bool inside (const Point < T, S > & p, const BoundsBase & b) check whether point is inside the bounds (exclusive) bool insideExclusive (const Point < T, S > & p, const BoundsBase & b) check whether point is inside the bounds (inclusive) decltype(auto) distanceSquared (const Point < T, S > & p, const BoundsBase & b) minimum squared distance between point and bounds, if inside return 0 decltype(auto) distance (const Point < T, S > & p, const BoundsBase & b) minimum distance between point and bounds, if inside return 0 Detailed Description template < ArithmeticType T > class dakku :: Bounds3 ; 3d bounding box Updated on 2022-04-07 at 06:53:17 +0000","title":"dakku::Bounds3"},{"location":"Classes/classdakku_1_1Bounds3/#dakkubounds3","text":"3d bounding box More... #include <bounds.h> Inherits from dakku::BoundsBase< T, 3 >","title":"dakku::Bounds3"},{"location":"Classes/classdakku_1_1Bounds3/#additional-inherited-members","text":"Public Functions inherited from dakku::BoundsBase< T, 3 > Name BoundsBase () =default default constructor BoundsBase (const Point < T, S > & p) Construct a new Bounds2 with a point. BoundsBase (const Point < T, S > & p1, const Point < T, S > & p2) Construct a new Bounds Base object with two points (take min/max of them to pMin and pMax) template <ArithmeticType U> operator BoundsBase< U, S > () const cast data type of bounds Vector < T, S > diagonal () const get the diagonal of the bounding box size_t maxExtent () const get the dimension who has the maximum extent bool operator== (const BoundsBase & rhs) const bool operator!= (const BoundsBase & rhs) const Point < T, S > lerp (const Point < float, S > & t) const linera interpolation between pMin and pMax Vector < T, S > offset (const Point < T, S > & p) const get the offset \\(v\\) of a point, p = o + v * d void boundingSphere ( Point < T, S > & center, float & rad) get the bounding sphere of the bounds Public Attributes inherited from dakku::BoundsBase< T, 3 > Name Point < T, S > pMin left bottom corner of the bounds Point < T, S > pMax right top corner of the bounds Friends inherited from dakku::BoundsBase< T, 3 > Name bool overlaps (const BoundsBase & a, const BoundsBase & b) check whether two bounds overlaps bool inside (const Point < T, S > & p, const BoundsBase & b) check whether point is inside the bounds (exclusive) bool insideExclusive (const Point < T, S > & p, const BoundsBase & b) check whether point is inside the bounds (inclusive) decltype(auto) distanceSquared (const Point < T, S > & p, const BoundsBase & b) minimum squared distance between point and bounds, if inside return 0 decltype(auto) distance (const Point < T, S > & p, const BoundsBase & b) minimum distance between point and bounds, if inside return 0","title":"Additional inherited members"},{"location":"Classes/classdakku_1_1Bounds3/#detailed-description","text":"template < ArithmeticType T > class dakku :: Bounds3 ;","title":"Detailed Description"},{"location":"Classes/classdakku_1_1Bounds3/#3d-bounding-box","text":"Updated on 2022-04-07 at 06:53:17 +0000","title":"3d bounding box"},{"location":"Classes/classdakku_1_1BoundsBase/","text":"dakku::BoundsBase bounding box base More... #include <bounds.h> Public Functions Name BoundsBase () =default default constructor BoundsBase (const Point < T, S > & p) Construct a new Bounds2 with a point. BoundsBase (const Point < T, S > & p1, const Point < T, S > & p2) Construct a new Bounds Base object with two points (take min/max of them to pMin and pMax) template <ArithmeticType U> operator BoundsBase< U, S > () const cast data type of bounds Vector < T, S > diagonal () const get the diagonal of the bounding box size_t maxExtent () const get the dimension who has the maximum extent bool operator== (const BoundsBase & rhs) const bool operator!= (const BoundsBase & rhs) const Point < T, S > lerp (const Point < float, S > & t) const linera interpolation between pMin and pMax Vector < T, S > offset (const Point < T, S > & p) const get the offset \\(v\\) of a point, p = o + v * d void boundingSphere ( Point < T, S > & center, float & rad) get the bounding sphere of the bounds Public Attributes Name Point < T, S > pMin left bottom corner of the bounds Point < T, S > pMax right top corner of the bounds Friends Name bool overlaps (const BoundsBase & a, const BoundsBase & b) check whether two bounds overlaps bool inside (const Point < T, S > & p, const BoundsBase & b) check whether point is inside the bounds (exclusive) bool insideExclusive (const Point < T, S > & p, const BoundsBase & b) check whether point is inside the bounds (inclusive) decltype(auto) distanceSquared (const Point < T, S > & p, const BoundsBase & b) minimum squared distance between point and bounds, if inside return 0 decltype(auto) distance (const Point < T, S > & p, const BoundsBase & b) minimum distance between point and bounds, if inside return 0 Detailed Description template < ArithmeticType T , size_t S > class dakku :: BoundsBase ; bounding box base Template Parameters : T data type S dimension Public Functions Documentation function BoundsBase BoundsBase () = default default constructor function BoundsBase inline explicit BoundsBase ( const Point < T , S > & p ) Construct a new Bounds2 with a point. Parameters : p the given point function BoundsBase inline BoundsBase ( const Point < T , S > & p1 , const Point < T , S > & p2 ) Construct a new Bounds Base object with two points (take min/max of them to pMin and pMax) function operator BoundsBase< U, S > template < ArithmeticType U > inline explicit operator BoundsBase < U , S > () const cast data type of bounds function diagonal inline Vector < T , S > diagonal () const get the diagonal of the bounding box function maxExtent inline size_t maxExtent () const get the dimension who has the maximum extent Return : the dimension function operator== inline bool operator == ( const BoundsBase & rhs ) const function operator!= inline bool operator != ( const BoundsBase & rhs ) const function lerp inline Point < T , S > lerp ( const Point < float , S > & t ) const linera interpolation between pMin and pMax Parameters : t interpolate \\(t\\) (element wise) function offset inline Vector < T , S > offset ( const Point < T , S > & p ) const get the offset \\(v\\) of a point, p = o + v * d Parameters : p the point Return : the offset function boundingSphere inline void boundingSphere ( Point < T , S > & center , float & rad ) get the bounding sphere of the bounds Parameters : center the center of the sphere rad the radius of the sphere Public Attributes Documentation variable pMin Point < T , S > pMin { std :: numeric_limits < T >:: max ()}; left bottom corner of the bounds variable pMax Point < T , S > pMax { std :: numeric_limits < T >:: lowest ()}; right top corner of the bounds Friends friend overlaps friend bool overlaps ( const BoundsBase & a , const BoundsBase & b ); check whether two bounds overlaps friend inside friend bool inside ( const Point < T , S > & p , const BoundsBase & b ); check whether point is inside the bounds (exclusive) Parameters : p the point b the bounds friend insideExclusive friend bool insideExclusive ( const Point < T , S > & p , const BoundsBase & b ); check whether point is inside the bounds (inclusive) Parameters : p the point b the bounds friend distanceSquared friend decltype ( auto ) distanceSquared ( const Point < T , S > & p , const BoundsBase & b ); minimum squared distance between point and bounds, if inside return 0 Parameters : p the point b the bounds Return : the squared distance friend distance friend decltype ( auto ) distance ( const Point < T , S > & p , const BoundsBase & b ); minimum distance between point and bounds, if inside return 0 Parameters : p the point b the bounds Return : the distance Updated on 2022-04-07 at 06:53:17 +0000","title":"dakku::BoundsBase"},{"location":"Classes/classdakku_1_1BoundsBase/#dakkuboundsbase","text":"bounding box base More... #include <bounds.h>","title":"dakku::BoundsBase"},{"location":"Classes/classdakku_1_1BoundsBase/#public-functions","text":"Name BoundsBase () =default default constructor BoundsBase (const Point < T, S > & p) Construct a new Bounds2 with a point. BoundsBase (const Point < T, S > & p1, const Point < T, S > & p2) Construct a new Bounds Base object with two points (take min/max of them to pMin and pMax) template <ArithmeticType U> operator BoundsBase< U, S > () const cast data type of bounds Vector < T, S > diagonal () const get the diagonal of the bounding box size_t maxExtent () const get the dimension who has the maximum extent bool operator== (const BoundsBase & rhs) const bool operator!= (const BoundsBase & rhs) const Point < T, S > lerp (const Point < float, S > & t) const linera interpolation between pMin and pMax Vector < T, S > offset (const Point < T, S > & p) const get the offset \\(v\\) of a point, p = o + v * d void boundingSphere ( Point < T, S > & center, float & rad) get the bounding sphere of the bounds","title":"Public Functions"},{"location":"Classes/classdakku_1_1BoundsBase/#public-attributes","text":"Name Point < T, S > pMin left bottom corner of the bounds Point < T, S > pMax right top corner of the bounds","title":"Public Attributes"},{"location":"Classes/classdakku_1_1BoundsBase/#friends","text":"Name bool overlaps (const BoundsBase & a, const BoundsBase & b) check whether two bounds overlaps bool inside (const Point < T, S > & p, const BoundsBase & b) check whether point is inside the bounds (exclusive) bool insideExclusive (const Point < T, S > & p, const BoundsBase & b) check whether point is inside the bounds (inclusive) decltype(auto) distanceSquared (const Point < T, S > & p, const BoundsBase & b) minimum squared distance between point and bounds, if inside return 0 decltype(auto) distance (const Point < T, S > & p, const BoundsBase & b) minimum distance between point and bounds, if inside return 0","title":"Friends"},{"location":"Classes/classdakku_1_1BoundsBase/#detailed-description","text":"template < ArithmeticType T , size_t S > class dakku :: BoundsBase ; bounding box base Template Parameters : T data type S dimension","title":"Detailed Description"},{"location":"Classes/classdakku_1_1BoundsBase/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Classes/classdakku_1_1BoundsBase/#function-boundsbase","text":"BoundsBase () = default default constructor","title":"function BoundsBase"},{"location":"Classes/classdakku_1_1BoundsBase/#function-boundsbase_1","text":"inline explicit BoundsBase ( const Point < T , S > & p ) Construct a new Bounds2 with a point. Parameters : p the given point","title":"function BoundsBase"},{"location":"Classes/classdakku_1_1BoundsBase/#function-boundsbase_2","text":"inline BoundsBase ( const Point < T , S > & p1 , const Point < T , S > & p2 ) Construct a new Bounds Base object with two points (take min/max of them to pMin and pMax)","title":"function BoundsBase"},{"location":"Classes/classdakku_1_1BoundsBase/#function-operator-boundsbase-u-s","text":"template < ArithmeticType U > inline explicit operator BoundsBase < U , S > () const cast data type of bounds","title":"function operator BoundsBase&lt; U, S &gt;"},{"location":"Classes/classdakku_1_1BoundsBase/#function-diagonal","text":"inline Vector < T , S > diagonal () const get the diagonal of the bounding box","title":"function diagonal"},{"location":"Classes/classdakku_1_1BoundsBase/#function-maxextent","text":"inline size_t maxExtent () const get the dimension who has the maximum extent Return : the dimension","title":"function maxExtent"},{"location":"Classes/classdakku_1_1BoundsBase/#function-operator","text":"inline bool operator == ( const BoundsBase & rhs ) const","title":"function operator=="},{"location":"Classes/classdakku_1_1BoundsBase/#function-operator_1","text":"inline bool operator != ( const BoundsBase & rhs ) const","title":"function operator!="},{"location":"Classes/classdakku_1_1BoundsBase/#function-lerp","text":"inline Point < T , S > lerp ( const Point < float , S > & t ) const linera interpolation between pMin and pMax Parameters : t interpolate \\(t\\) (element wise)","title":"function lerp"},{"location":"Classes/classdakku_1_1BoundsBase/#function-offset","text":"inline Vector < T , S > offset ( const Point < T , S > & p ) const get the offset \\(v\\) of a point, p = o + v * d Parameters : p the point Return : the offset","title":"function offset"},{"location":"Classes/classdakku_1_1BoundsBase/#function-boundingsphere","text":"inline void boundingSphere ( Point < T , S > & center , float & rad ) get the bounding sphere of the bounds Parameters : center the center of the sphere rad the radius of the sphere","title":"function boundingSphere"},{"location":"Classes/classdakku_1_1BoundsBase/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"Classes/classdakku_1_1BoundsBase/#variable-pmin","text":"Point < T , S > pMin { std :: numeric_limits < T >:: max ()}; left bottom corner of the bounds","title":"variable pMin"},{"location":"Classes/classdakku_1_1BoundsBase/#variable-pmax","text":"Point < T , S > pMax { std :: numeric_limits < T >:: lowest ()}; right top corner of the bounds","title":"variable pMax"},{"location":"Classes/classdakku_1_1BoundsBase/#friends_1","text":"","title":"Friends"},{"location":"Classes/classdakku_1_1BoundsBase/#friend-overlaps","text":"friend bool overlaps ( const BoundsBase & a , const BoundsBase & b ); check whether two bounds overlaps","title":"friend overlaps"},{"location":"Classes/classdakku_1_1BoundsBase/#friend-inside","text":"friend bool inside ( const Point < T , S > & p , const BoundsBase & b ); check whether point is inside the bounds (exclusive) Parameters : p the point b the bounds","title":"friend inside"},{"location":"Classes/classdakku_1_1BoundsBase/#friend-insideexclusive","text":"friend bool insideExclusive ( const Point < T , S > & p , const BoundsBase & b ); check whether point is inside the bounds (inclusive) Parameters : p the point b the bounds","title":"friend insideExclusive"},{"location":"Classes/classdakku_1_1BoundsBase/#friend-distancesquared","text":"friend decltype ( auto ) distanceSquared ( const Point < T , S > & p , const BoundsBase & b ); minimum squared distance between point and bounds, if inside return 0 Parameters : p the point b the bounds Return : the squared distance","title":"friend distanceSquared"},{"location":"Classes/classdakku_1_1BoundsBase/#friend-distance","text":"friend decltype ( auto ) distance ( const Point < T , S > & p , const BoundsBase & b ); minimum distance between point and bounds, if inside return 0 Parameters : p the point b the bounds Return : the distance Updated on 2022-04-07 at 06:53:17 +0000","title":"friend distance"},{"location":"Classes/classdakku_1_1Class/","text":"dakku::Class RTTI support. #include <class.h> Public Functions Name Class & instance () get the class instance (singleton) Public Functions Documentation function instance static Class & instance () get the class instance (singleton) Return : the instance Updated on 2022-04-07 at 06:53:17 +0000","title":"dakku::Class"},{"location":"Classes/classdakku_1_1Class/#dakkuclass","text":"RTTI support. #include <class.h>","title":"dakku::Class"},{"location":"Classes/classdakku_1_1Class/#public-functions","text":"Name Class & instance () get the class instance (singleton)","title":"Public Functions"},{"location":"Classes/classdakku_1_1Class/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Classes/classdakku_1_1Class/#function-instance","text":"static Class & instance () get the class instance (singleton) Return : the instance Updated on 2022-04-07 at 06:53:17 +0000","title":"function instance"},{"location":"Classes/classdakku_1_1Logger/","text":"dakku::Logger logger class #include <logger.h> Public Functions Name const Logger & get () get logger instance spdlog::logger * handle () const get raw spdlog::logger handle Public Functions Documentation function get static const Logger & get () get logger instance Return : the logger instance function handle inline spdlog :: logger * handle () const get raw spdlog::logger handle Return : the corresponding spdlog::logger Updated on 2022-04-07 at 06:53:17 +0000","title":"dakku::Logger"},{"location":"Classes/classdakku_1_1Logger/#dakkulogger","text":"logger class #include <logger.h>","title":"dakku::Logger"},{"location":"Classes/classdakku_1_1Logger/#public-functions","text":"Name const Logger & get () get logger instance spdlog::logger * handle () const get raw spdlog::logger handle","title":"Public Functions"},{"location":"Classes/classdakku_1_1Logger/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Classes/classdakku_1_1Logger/#function-get","text":"static const Logger & get () get logger instance Return : the logger instance","title":"function get"},{"location":"Classes/classdakku_1_1Logger/#function-handle","text":"inline spdlog :: logger * handle () const get raw spdlog::logger handle Return : the corresponding spdlog::logger Updated on 2022-04-07 at 06:53:17 +0000","title":"function handle"},{"location":"Classes/classdakku_1_1Normal/","text":"dakku::Normal normal More... #include <vector.h> Inherits from dakku::VectorBase< T, S, Normal< T, S > > Friends Name Normal operator- (const Normal & a, const Normal & b) subtraction between two normals Additional inherited members Public Functions inherited from dakku::VectorBase< T, S, Normal< T, S > > Name VectorBase () Construct a new Vector Base object with all components initialized to zero. template <ArithmeticType Arg> VectorBase (Arg value) Construct a new Vector Base object with all components initialized to value template <ArithmeticType Other,typename OtherDerived > VectorBase (const VectorBase < Other, S, OtherDerived > & other) Construct a new Vector Base object with a vector expression. VectorBase (const VectorBase & other) VectorBase ( VectorBase && other) VectorBase & operator= (const VectorBase & other) VectorBase & operator= ( VectorBase && other) template <ArithmeticType Arg> void set (Arg value) Construct a new Vector Base object with given values. template <ArithmeticType Arg> void setByIndex (size_t index, Arg value) set data[index] to value template <ArithmeticType... Args,size_t... Is> void set (std::index_sequence< Is... > , Args &&... args) set data to args template <ArithmeticType... Args> void set (Args &&... args) set data to args template <ArithmeticType Other,typename OtherDerived > void set (const VectorBase < Other, S, OtherDerived > & rhs) set data by rhs 's data bool hasNaNs () const check whether there are nan components const T & get (size_t i) const get i'th component std::string toString () const convert vector to string size_t size () const size of the vector const T & operator[] (size_t i) const get i'th value T & operator[] (size_t i) get i'th value const Derived & derived () const get derived class Derived & derived () get derived class Derived & operator+= (const Derived & rhs) addition template <ArithmeticType V> Derived & operator+= (const V & rhs) addition Derived & operator-= (const Derived & rhs) subtraction template <ArithmeticType V> Derived & operator-= (const V & rhs) subtraction Derived & operator*= (const Derived & rhs) multiplication template <ArithmeticType V> Derived & operator*= (const V & rhs) multiplication Derived & operator/= (const Derived & rhs) division template <ArithmeticType V> Derived & operator/= (const V & rhs) division std::vector< float > toFloatVector () const convert this to float vector (Property::VECTOR) VectorBase (const std::vector< float > & v) Construct a new Vector Base object with std::vector (Property::VECTOR) decltype(auto) x () const get the first element decltype(auto) x () get the first element decltype(auto) y () const get the second element decltype(auto) y () get the second element decltype(auto) z () const get the third element decltype(auto) z () get the fourth element decltype(auto) w () const get the fourth element decltype(auto) w () get the third element size_t maxElementIndex () const get the index of the max element decltype(auto) maxElement () const get the max element in the vector decltype(auto) begin () decltype(auto) begin () const decltype(auto) end () decltype(auto) end () const template <typename OtherDerived > decltype(auto) dot (const VectorBase < T, S, OtherDerived > & rhs) const dot product between two vectors decltype(auto) squaredNorm () const squared norm decltype(auto) norm () const norm decltype(auto) length () const length Protected Attributes inherited from dakku::VectorBase< T, S, Normal< T, S > > Name std::array< T, S > _data vector base data Friends inherited from dakku::VectorBase< T, S, Normal< T, S > > Name std::ostream & operator<< (std::ostream & os, const VectorBase & vec) output the vector Derived operator+ (const Derived & a, const Derived & b) addition Derived operator+ (const Derived & a, const U & b) addition Derived operator+ (const U & a, const Derived & b) addition Derived operator* (const Derived & a, const Derived & b) multiplication Derived operator* (const Derived & a, const U & b) multiplication Derived operator* (const U & a, const Derived & b) multiplication Derived operator/ (const Derived & a, const Derived & b) division Derived operator/ (const Derived & a, const U & b) division Derived operator/ (const U & a, const Derived & b) division bool operator== (const Derived & a, const Derived & b) a == b (element wise) bool operator!= (const Derived & a, const Derived & b) a != b (element wise) Derived max (const Derived & a, const Derived & b) element wise max Derived min (const Derived & a, const Derived & b) element wise min decltype(auto) distance (const Derived & a, const Derived & b) the distance Detailed Description template < ArithmeticType T , size_t S > class dakku :: Normal ; normal Template Parameters : T data type S size Friends friend operator- friend Normal operator - ( const Normal & a , const Normal & b ); subtraction between two normals Updated on 2022-04-07 at 06:53:17 +0000","title":"dakku::Normal"},{"location":"Classes/classdakku_1_1Normal/#dakkunormal","text":"normal More... #include <vector.h> Inherits from dakku::VectorBase< T, S, Normal< T, S > >","title":"dakku::Normal"},{"location":"Classes/classdakku_1_1Normal/#friends","text":"Name Normal operator- (const Normal & a, const Normal & b) subtraction between two normals","title":"Friends"},{"location":"Classes/classdakku_1_1Normal/#additional-inherited-members","text":"Public Functions inherited from dakku::VectorBase< T, S, Normal< T, S > > Name VectorBase () Construct a new Vector Base object with all components initialized to zero. template <ArithmeticType Arg> VectorBase (Arg value) Construct a new Vector Base object with all components initialized to value template <ArithmeticType Other,typename OtherDerived > VectorBase (const VectorBase < Other, S, OtherDerived > & other) Construct a new Vector Base object with a vector expression. VectorBase (const VectorBase & other) VectorBase ( VectorBase && other) VectorBase & operator= (const VectorBase & other) VectorBase & operator= ( VectorBase && other) template <ArithmeticType Arg> void set (Arg value) Construct a new Vector Base object with given values. template <ArithmeticType Arg> void setByIndex (size_t index, Arg value) set data[index] to value template <ArithmeticType... Args,size_t... Is> void set (std::index_sequence< Is... > , Args &&... args) set data to args template <ArithmeticType... Args> void set (Args &&... args) set data to args template <ArithmeticType Other,typename OtherDerived > void set (const VectorBase < Other, S, OtherDerived > & rhs) set data by rhs 's data bool hasNaNs () const check whether there are nan components const T & get (size_t i) const get i'th component std::string toString () const convert vector to string size_t size () const size of the vector const T & operator[] (size_t i) const get i'th value T & operator[] (size_t i) get i'th value const Derived & derived () const get derived class Derived & derived () get derived class Derived & operator+= (const Derived & rhs) addition template <ArithmeticType V> Derived & operator+= (const V & rhs) addition Derived & operator-= (const Derived & rhs) subtraction template <ArithmeticType V> Derived & operator-= (const V & rhs) subtraction Derived & operator*= (const Derived & rhs) multiplication template <ArithmeticType V> Derived & operator*= (const V & rhs) multiplication Derived & operator/= (const Derived & rhs) division template <ArithmeticType V> Derived & operator/= (const V & rhs) division std::vector< float > toFloatVector () const convert this to float vector (Property::VECTOR) VectorBase (const std::vector< float > & v) Construct a new Vector Base object with std::vector (Property::VECTOR) decltype(auto) x () const get the first element decltype(auto) x () get the first element decltype(auto) y () const get the second element decltype(auto) y () get the second element decltype(auto) z () const get the third element decltype(auto) z () get the fourth element decltype(auto) w () const get the fourth element decltype(auto) w () get the third element size_t maxElementIndex () const get the index of the max element decltype(auto) maxElement () const get the max element in the vector decltype(auto) begin () decltype(auto) begin () const decltype(auto) end () decltype(auto) end () const template <typename OtherDerived > decltype(auto) dot (const VectorBase < T, S, OtherDerived > & rhs) const dot product between two vectors decltype(auto) squaredNorm () const squared norm decltype(auto) norm () const norm decltype(auto) length () const length Protected Attributes inherited from dakku::VectorBase< T, S, Normal< T, S > > Name std::array< T, S > _data vector base data Friends inherited from dakku::VectorBase< T, S, Normal< T, S > > Name std::ostream & operator<< (std::ostream & os, const VectorBase & vec) output the vector Derived operator+ (const Derived & a, const Derived & b) addition Derived operator+ (const Derived & a, const U & b) addition Derived operator+ (const U & a, const Derived & b) addition Derived operator* (const Derived & a, const Derived & b) multiplication Derived operator* (const Derived & a, const U & b) multiplication Derived operator* (const U & a, const Derived & b) multiplication Derived operator/ (const Derived & a, const Derived & b) division Derived operator/ (const Derived & a, const U & b) division Derived operator/ (const U & a, const Derived & b) division bool operator== (const Derived & a, const Derived & b) a == b (element wise) bool operator!= (const Derived & a, const Derived & b) a != b (element wise) Derived max (const Derived & a, const Derived & b) element wise max Derived min (const Derived & a, const Derived & b) element wise min decltype(auto) distance (const Derived & a, const Derived & b) the distance","title":"Additional inherited members"},{"location":"Classes/classdakku_1_1Normal/#detailed-description","text":"template < ArithmeticType T , size_t S > class dakku :: Normal ; normal Template Parameters : T data type S size","title":"Detailed Description"},{"location":"Classes/classdakku_1_1Normal/#friends_1","text":"","title":"Friends"},{"location":"Classes/classdakku_1_1Normal/#friend-operator-","text":"friend Normal operator - ( const Normal & a , const Normal & b ); subtraction between two normals Updated on 2022-04-07 at 06:53:17 +0000","title":"friend operator-"},{"location":"Classes/classdakku_1_1Point/","text":"dakku::Point point More... #include <vector.h> Inherits from dakku::VectorBase< T, S, Point< T, S > > Friends Name Vector < T, S > operator- (const Point & a, const Point & b) subtraction between two points yields vectors Point operator- (const Point & a, const Vector < T, S > & b) point - vector => point Point operator+ (const Point & a, const Vector < T, S > & b) point + vector => point Additional inherited members Public Functions inherited from dakku::VectorBase< T, S, Point< T, S > > Name VectorBase () Construct a new Vector Base object with all components initialized to zero. template <ArithmeticType Arg> VectorBase (Arg value) Construct a new Vector Base object with all components initialized to value template <ArithmeticType Other,typename OtherDerived > VectorBase (const VectorBase < Other, S, OtherDerived > & other) Construct a new Vector Base object with a vector expression. VectorBase (const VectorBase & other) VectorBase ( VectorBase && other) VectorBase & operator= (const VectorBase & other) VectorBase & operator= ( VectorBase && other) template <ArithmeticType Arg> void set (Arg value) Construct a new Vector Base object with given values. template <ArithmeticType Arg> void setByIndex (size_t index, Arg value) set data[index] to value template <ArithmeticType... Args,size_t... Is> void set (std::index_sequence< Is... > , Args &&... args) set data to args template <ArithmeticType... Args> void set (Args &&... args) set data to args template <ArithmeticType Other,typename OtherDerived > void set (const VectorBase < Other, S, OtherDerived > & rhs) set data by rhs 's data bool hasNaNs () const check whether there are nan components const T & get (size_t i) const get i'th component std::string toString () const convert vector to string size_t size () const size of the vector const T & operator[] (size_t i) const get i'th value T & operator[] (size_t i) get i'th value const Derived & derived () const get derived class Derived & derived () get derived class Derived & operator+= (const Derived & rhs) addition template <ArithmeticType V> Derived & operator+= (const V & rhs) addition Derived & operator-= (const Derived & rhs) subtraction template <ArithmeticType V> Derived & operator-= (const V & rhs) subtraction Derived & operator*= (const Derived & rhs) multiplication template <ArithmeticType V> Derived & operator*= (const V & rhs) multiplication Derived & operator/= (const Derived & rhs) division template <ArithmeticType V> Derived & operator/= (const V & rhs) division std::vector< float > toFloatVector () const convert this to float vector (Property::VECTOR) VectorBase (const std::vector< float > & v) Construct a new Vector Base object with std::vector (Property::VECTOR) decltype(auto) x () const get the first element decltype(auto) x () get the first element decltype(auto) y () const get the second element decltype(auto) y () get the second element decltype(auto) z () const get the third element decltype(auto) z () get the fourth element decltype(auto) w () const get the fourth element decltype(auto) w () get the third element size_t maxElementIndex () const get the index of the max element decltype(auto) maxElement () const get the max element in the vector decltype(auto) begin () decltype(auto) begin () const decltype(auto) end () decltype(auto) end () const template <typename OtherDerived > decltype(auto) dot (const VectorBase < T, S, OtherDerived > & rhs) const dot product between two vectors decltype(auto) squaredNorm () const squared norm decltype(auto) norm () const norm decltype(auto) length () const length Protected Attributes inherited from dakku::VectorBase< T, S, Point< T, S > > Name std::array< T, S > _data vector base data Friends inherited from dakku::VectorBase< T, S, Point< T, S > > Name std::ostream & operator<< (std::ostream & os, const VectorBase & vec) output the vector Derived operator* (const Derived & a, const Derived & b) multiplication Derived operator* (const Derived & a, const U & b) multiplication Derived operator* (const U & a, const Derived & b) multiplication Derived operator/ (const Derived & a, const Derived & b) division Derived operator/ (const Derived & a, const U & b) division Derived operator/ (const U & a, const Derived & b) division bool operator== (const Derived & a, const Derived & b) a == b (element wise) bool operator!= (const Derived & a, const Derived & b) a != b (element wise) Derived max (const Derived & a, const Derived & b) element wise max Derived min (const Derived & a, const Derived & b) element wise min decltype(auto) distance (const Derived & a, const Derived & b) the distance Detailed Description template < ArithmeticType T , size_t S > class dakku :: Point ; point Template Parameters : T data type S size Friends friend operator- friend Vector < T , S > operator - ( const Point & a , const Point & b ); subtraction between two points yields vectors friend operator- friend Point operator - ( const Point & a , const Vector < T , S > & b ); point - vector => point friend operator+ friend Point operator + ( const Point & a , const Vector < T , S > & b ); point + vector => point Updated on 2022-04-07 at 06:53:17 +0000","title":"dakku::Point"},{"location":"Classes/classdakku_1_1Point/#dakkupoint","text":"point More... #include <vector.h> Inherits from dakku::VectorBase< T, S, Point< T, S > >","title":"dakku::Point"},{"location":"Classes/classdakku_1_1Point/#friends","text":"Name Vector < T, S > operator- (const Point & a, const Point & b) subtraction between two points yields vectors Point operator- (const Point & a, const Vector < T, S > & b) point - vector => point Point operator+ (const Point & a, const Vector < T, S > & b) point + vector => point","title":"Friends"},{"location":"Classes/classdakku_1_1Point/#additional-inherited-members","text":"Public Functions inherited from dakku::VectorBase< T, S, Point< T, S > > Name VectorBase () Construct a new Vector Base object with all components initialized to zero. template <ArithmeticType Arg> VectorBase (Arg value) Construct a new Vector Base object with all components initialized to value template <ArithmeticType Other,typename OtherDerived > VectorBase (const VectorBase < Other, S, OtherDerived > & other) Construct a new Vector Base object with a vector expression. VectorBase (const VectorBase & other) VectorBase ( VectorBase && other) VectorBase & operator= (const VectorBase & other) VectorBase & operator= ( VectorBase && other) template <ArithmeticType Arg> void set (Arg value) Construct a new Vector Base object with given values. template <ArithmeticType Arg> void setByIndex (size_t index, Arg value) set data[index] to value template <ArithmeticType... Args,size_t... Is> void set (std::index_sequence< Is... > , Args &&... args) set data to args template <ArithmeticType... Args> void set (Args &&... args) set data to args template <ArithmeticType Other,typename OtherDerived > void set (const VectorBase < Other, S, OtherDerived > & rhs) set data by rhs 's data bool hasNaNs () const check whether there are nan components const T & get (size_t i) const get i'th component std::string toString () const convert vector to string size_t size () const size of the vector const T & operator[] (size_t i) const get i'th value T & operator[] (size_t i) get i'th value const Derived & derived () const get derived class Derived & derived () get derived class Derived & operator+= (const Derived & rhs) addition template <ArithmeticType V> Derived & operator+= (const V & rhs) addition Derived & operator-= (const Derived & rhs) subtraction template <ArithmeticType V> Derived & operator-= (const V & rhs) subtraction Derived & operator*= (const Derived & rhs) multiplication template <ArithmeticType V> Derived & operator*= (const V & rhs) multiplication Derived & operator/= (const Derived & rhs) division template <ArithmeticType V> Derived & operator/= (const V & rhs) division std::vector< float > toFloatVector () const convert this to float vector (Property::VECTOR) VectorBase (const std::vector< float > & v) Construct a new Vector Base object with std::vector (Property::VECTOR) decltype(auto) x () const get the first element decltype(auto) x () get the first element decltype(auto) y () const get the second element decltype(auto) y () get the second element decltype(auto) z () const get the third element decltype(auto) z () get the fourth element decltype(auto) w () const get the fourth element decltype(auto) w () get the third element size_t maxElementIndex () const get the index of the max element decltype(auto) maxElement () const get the max element in the vector decltype(auto) begin () decltype(auto) begin () const decltype(auto) end () decltype(auto) end () const template <typename OtherDerived > decltype(auto) dot (const VectorBase < T, S, OtherDerived > & rhs) const dot product between two vectors decltype(auto) squaredNorm () const squared norm decltype(auto) norm () const norm decltype(auto) length () const length Protected Attributes inherited from dakku::VectorBase< T, S, Point< T, S > > Name std::array< T, S > _data vector base data Friends inherited from dakku::VectorBase< T, S, Point< T, S > > Name std::ostream & operator<< (std::ostream & os, const VectorBase & vec) output the vector Derived operator* (const Derived & a, const Derived & b) multiplication Derived operator* (const Derived & a, const U & b) multiplication Derived operator* (const U & a, const Derived & b) multiplication Derived operator/ (const Derived & a, const Derived & b) division Derived operator/ (const Derived & a, const U & b) division Derived operator/ (const U & a, const Derived & b) division bool operator== (const Derived & a, const Derived & b) a == b (element wise) bool operator!= (const Derived & a, const Derived & b) a != b (element wise) Derived max (const Derived & a, const Derived & b) element wise max Derived min (const Derived & a, const Derived & b) element wise min decltype(auto) distance (const Derived & a, const Derived & b) the distance","title":"Additional inherited members"},{"location":"Classes/classdakku_1_1Point/#detailed-description","text":"template < ArithmeticType T , size_t S > class dakku :: Point ; point Template Parameters : T data type S size","title":"Detailed Description"},{"location":"Classes/classdakku_1_1Point/#friends_1","text":"","title":"Friends"},{"location":"Classes/classdakku_1_1Point/#friend-operator-","text":"friend Vector < T , S > operator - ( const Point & a , const Point & b ); subtraction between two points yields vectors","title":"friend operator-"},{"location":"Classes/classdakku_1_1Point/#friend-operator-_1","text":"friend Point operator - ( const Point & a , const Vector < T , S > & b ); point - vector => point","title":"friend operator-"},{"location":"Classes/classdakku_1_1Point/#friend-operator","text":"friend Point operator + ( const Point & a , const Vector < T , S > & b ); point + vector => point Updated on 2022-04-07 at 06:53:17 +0000","title":"friend operator+"},{"location":"Classes/classdakku_1_1Property/","text":"dakku::Property property class, containing many data types, similar to json #include <property.h> Public Types Name using std::map< std::string, Property , std::less<> > ObjectType using std::vector< Property > ArrayType using float NumberType using std::vector< float > VectorType Public Functions Name Property () =default Construct a new empty Property object. template <ArithmeticType T> Property (const T & v) Construct a new Property object with a number. template <ArithmeticType T,size_t S,typename D > Property (const VectorBase < T, S, D > & v) Construct a new Property object with a vector. decltype(auto) getPropertyType () const get the type of current property template <PropertyType type> decltype(auto) get () get the property data according to given type decltype(auto) getObject () get object decltype(auto) getArray () get array decltype(auto) getNumber () get number decltype(auto) getVector () get vector bool isObjectType () const is this an object bool isArrayType () const is this an array bool isNumberType () const is this a number bool isVectorType () const is this a vector decltype(auto) operator[] (const std::string & key) index key , if this is NONE, then => OBJECT decltype(auto) operator[] (size_t i) index i, if this is NONE, then => ARRAY if i >= size, it will grow automatically std::string toString () const to string Friends Name std::ostream & operator<< (std::ostream & os, const Property & property) output the property Public Types Documentation using ObjectType using dakku :: Property :: ObjectType = std :: map < std :: string , Property , std :: less <> > ; using ArrayType using dakku :: Property :: ArrayType = std :: vector < Property > ; using NumberType using dakku :: Property :: NumberType = float ; using VectorType using dakku :: Property :: VectorType = std :: vector < float > ; Public Functions Documentation function Property Property () = default Construct a new empty Property object. function Property template < ArithmeticType T > inline Property ( const T & v ) Construct a new Property object with a number. Parameters : v number value function Property template < ArithmeticType T , size_t S , typename D > inline Property ( const VectorBase < T , S , D > & v ) Construct a new Property object with a vector. Parameters : v vector function getPropertyType inline decltype ( auto ) getPropertyType () const get the type of current property Return : the property type function get template < PropertyType type > inline decltype ( auto ) get () get the property data according to given type Template Parameters : type the type to get Return : the data function getObject inline decltype ( auto ) getObject () get object function getArray inline decltype ( auto ) getArray () get array function getNumber inline decltype ( auto ) getNumber () get number function getVector inline decltype ( auto ) getVector () get vector function isObjectType inline bool isObjectType () const is this an object function isArrayType inline bool isArrayType () const is this an array function isNumberType inline bool isNumberType () const is this a number function isVectorType inline bool isVectorType () const is this a vector function operator[] inline decltype ( auto ) operator []( const std :: string & key ) index key , if this is NONE, then => OBJECT Parameters : key key to index Return : value function operator[] inline decltype ( auto ) operator []( size_t i ) index i, if this is NONE, then => ARRAY if i >= size, it will grow automatically Parameters : i the index Return : the data function toString std :: string toString () const to string Friends friend operator<< friend std :: ostream & operator << ( std :: ostream & os , const Property & property ); output the property Updated on 2022-04-07 at 06:53:17 +0000","title":"dakku::Property"},{"location":"Classes/classdakku_1_1Property/#dakkuproperty","text":"property class, containing many data types, similar to json #include <property.h>","title":"dakku::Property"},{"location":"Classes/classdakku_1_1Property/#public-types","text":"Name using std::map< std::string, Property , std::less<> > ObjectType using std::vector< Property > ArrayType using float NumberType using std::vector< float > VectorType","title":"Public Types"},{"location":"Classes/classdakku_1_1Property/#public-functions","text":"Name Property () =default Construct a new empty Property object. template <ArithmeticType T> Property (const T & v) Construct a new Property object with a number. template <ArithmeticType T,size_t S,typename D > Property (const VectorBase < T, S, D > & v) Construct a new Property object with a vector. decltype(auto) getPropertyType () const get the type of current property template <PropertyType type> decltype(auto) get () get the property data according to given type decltype(auto) getObject () get object decltype(auto) getArray () get array decltype(auto) getNumber () get number decltype(auto) getVector () get vector bool isObjectType () const is this an object bool isArrayType () const is this an array bool isNumberType () const is this a number bool isVectorType () const is this a vector decltype(auto) operator[] (const std::string & key) index key , if this is NONE, then => OBJECT decltype(auto) operator[] (size_t i) index i, if this is NONE, then => ARRAY if i >= size, it will grow automatically std::string toString () const to string","title":"Public Functions"},{"location":"Classes/classdakku_1_1Property/#friends","text":"Name std::ostream & operator<< (std::ostream & os, const Property & property) output the property","title":"Friends"},{"location":"Classes/classdakku_1_1Property/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Classes/classdakku_1_1Property/#using-objecttype","text":"using dakku :: Property :: ObjectType = std :: map < std :: string , Property , std :: less <> > ;","title":"using ObjectType"},{"location":"Classes/classdakku_1_1Property/#using-arraytype","text":"using dakku :: Property :: ArrayType = std :: vector < Property > ;","title":"using ArrayType"},{"location":"Classes/classdakku_1_1Property/#using-numbertype","text":"using dakku :: Property :: NumberType = float ;","title":"using NumberType"},{"location":"Classes/classdakku_1_1Property/#using-vectortype","text":"using dakku :: Property :: VectorType = std :: vector < float > ;","title":"using VectorType"},{"location":"Classes/classdakku_1_1Property/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Classes/classdakku_1_1Property/#function-property","text":"Property () = default Construct a new empty Property object.","title":"function Property"},{"location":"Classes/classdakku_1_1Property/#function-property_1","text":"template < ArithmeticType T > inline Property ( const T & v ) Construct a new Property object with a number. Parameters : v number value","title":"function Property"},{"location":"Classes/classdakku_1_1Property/#function-property_2","text":"template < ArithmeticType T , size_t S , typename D > inline Property ( const VectorBase < T , S , D > & v ) Construct a new Property object with a vector. Parameters : v vector","title":"function Property"},{"location":"Classes/classdakku_1_1Property/#function-getpropertytype","text":"inline decltype ( auto ) getPropertyType () const get the type of current property Return : the property type","title":"function getPropertyType"},{"location":"Classes/classdakku_1_1Property/#function-get","text":"template < PropertyType type > inline decltype ( auto ) get () get the property data according to given type Template Parameters : type the type to get Return : the data","title":"function get"},{"location":"Classes/classdakku_1_1Property/#function-getobject","text":"inline decltype ( auto ) getObject () get object","title":"function getObject"},{"location":"Classes/classdakku_1_1Property/#function-getarray","text":"inline decltype ( auto ) getArray () get array","title":"function getArray"},{"location":"Classes/classdakku_1_1Property/#function-getnumber","text":"inline decltype ( auto ) getNumber () get number","title":"function getNumber"},{"location":"Classes/classdakku_1_1Property/#function-getvector","text":"inline decltype ( auto ) getVector () get vector","title":"function getVector"},{"location":"Classes/classdakku_1_1Property/#function-isobjecttype","text":"inline bool isObjectType () const is this an object","title":"function isObjectType"},{"location":"Classes/classdakku_1_1Property/#function-isarraytype","text":"inline bool isArrayType () const is this an array","title":"function isArrayType"},{"location":"Classes/classdakku_1_1Property/#function-isnumbertype","text":"inline bool isNumberType () const is this a number","title":"function isNumberType"},{"location":"Classes/classdakku_1_1Property/#function-isvectortype","text":"inline bool isVectorType () const is this a vector","title":"function isVectorType"},{"location":"Classes/classdakku_1_1Property/#function-operator","text":"inline decltype ( auto ) operator []( const std :: string & key ) index key , if this is NONE, then => OBJECT Parameters : key key to index Return : value","title":"function operator[]"},{"location":"Classes/classdakku_1_1Property/#function-operator_1","text":"inline decltype ( auto ) operator []( size_t i ) index i, if this is NONE, then => ARRAY if i >= size, it will grow automatically Parameters : i the index Return : the data","title":"function operator[]"},{"location":"Classes/classdakku_1_1Property/#function-tostring","text":"std :: string toString () const to string","title":"function toString"},{"location":"Classes/classdakku_1_1Property/#friends_1","text":"","title":"Friends"},{"location":"Classes/classdakku_1_1Property/#friend-operator","text":"friend std :: ostream & operator << ( std :: ostream & os , const Property & property ); output the property Updated on 2022-04-07 at 06:53:17 +0000","title":"friend operator&lt;&lt;"},{"location":"Classes/classdakku_1_1Vector/","text":"dakku::Vector vector More... #include <vector.h> Inherits from dakku::VectorBase< T, S, Vector< T, S > > Friends Name Vector operator- (const Vector & a, const Vector & b) subtraction between vectors Additional inherited members Public Functions inherited from dakku::VectorBase< T, S, Vector< T, S > > Name VectorBase () Construct a new Vector Base object with all components initialized to zero. template <ArithmeticType Arg> VectorBase (Arg value) Construct a new Vector Base object with all components initialized to value template <ArithmeticType Other,typename OtherDerived > VectorBase (const VectorBase < Other, S, OtherDerived > & other) Construct a new Vector Base object with a vector expression. VectorBase (const VectorBase & other) VectorBase ( VectorBase && other) VectorBase & operator= (const VectorBase & other) VectorBase & operator= ( VectorBase && other) template <ArithmeticType Arg> void set (Arg value) Construct a new Vector Base object with given values. template <ArithmeticType Arg> void setByIndex (size_t index, Arg value) set data[index] to value template <ArithmeticType... Args,size_t... Is> void set (std::index_sequence< Is... > , Args &&... args) set data to args template <ArithmeticType... Args> void set (Args &&... args) set data to args template <ArithmeticType Other,typename OtherDerived > void set (const VectorBase < Other, S, OtherDerived > & rhs) set data by rhs 's data bool hasNaNs () const check whether there are nan components const T & get (size_t i) const get i'th component std::string toString () const convert vector to string size_t size () const size of the vector const T & operator[] (size_t i) const get i'th value T & operator[] (size_t i) get i'th value const Derived & derived () const get derived class Derived & derived () get derived class Derived & operator+= (const Derived & rhs) addition template <ArithmeticType V> Derived & operator+= (const V & rhs) addition Derived & operator-= (const Derived & rhs) subtraction template <ArithmeticType V> Derived & operator-= (const V & rhs) subtraction Derived & operator*= (const Derived & rhs) multiplication template <ArithmeticType V> Derived & operator*= (const V & rhs) multiplication Derived & operator/= (const Derived & rhs) division template <ArithmeticType V> Derived & operator/= (const V & rhs) division std::vector< float > toFloatVector () const convert this to float vector (Property::VECTOR) VectorBase (const std::vector< float > & v) Construct a new Vector Base object with std::vector (Property::VECTOR) decltype(auto) x () const get the first element decltype(auto) x () get the first element decltype(auto) y () const get the second element decltype(auto) y () get the second element decltype(auto) z () const get the third element decltype(auto) z () get the fourth element decltype(auto) w () const get the fourth element decltype(auto) w () get the third element size_t maxElementIndex () const get the index of the max element decltype(auto) maxElement () const get the max element in the vector decltype(auto) begin () decltype(auto) begin () const decltype(auto) end () decltype(auto) end () const template <typename OtherDerived > decltype(auto) dot (const VectorBase < T, S, OtherDerived > & rhs) const dot product between two vectors decltype(auto) squaredNorm () const squared norm decltype(auto) norm () const norm decltype(auto) length () const length Protected Attributes inherited from dakku::VectorBase< T, S, Vector< T, S > > Name std::array< T, S > _data vector base data Friends inherited from dakku::VectorBase< T, S, Vector< T, S > > Name std::ostream & operator<< (std::ostream & os, const VectorBase & vec) output the vector Derived operator+ (const Derived & a, const Derived & b) addition Derived operator+ (const Derived & a, const U & b) addition Derived operator+ (const U & a, const Derived & b) addition Derived operator* (const Derived & a, const Derived & b) multiplication Derived operator* (const Derived & a, const U & b) multiplication Derived operator* (const U & a, const Derived & b) multiplication Derived operator/ (const Derived & a, const Derived & b) division Derived operator/ (const Derived & a, const U & b) division Derived operator/ (const U & a, const Derived & b) division bool operator== (const Derived & a, const Derived & b) a == b (element wise) bool operator!= (const Derived & a, const Derived & b) a != b (element wise) Derived max (const Derived & a, const Derived & b) element wise max Derived min (const Derived & a, const Derived & b) element wise min decltype(auto) distance (const Derived & a, const Derived & b) the distance Detailed Description template < ArithmeticType T , size_t S > class dakku :: Vector ; vector Template Parameters : T data type S size Friends friend operator- friend Vector operator - ( const Vector & a , const Vector & b ); subtraction between vectors Updated on 2022-04-07 at 06:53:17 +0000","title":"dakku::Vector"},{"location":"Classes/classdakku_1_1Vector/#dakkuvector","text":"vector More... #include <vector.h> Inherits from dakku::VectorBase< T, S, Vector< T, S > >","title":"dakku::Vector"},{"location":"Classes/classdakku_1_1Vector/#friends","text":"Name Vector operator- (const Vector & a, const Vector & b) subtraction between vectors","title":"Friends"},{"location":"Classes/classdakku_1_1Vector/#additional-inherited-members","text":"Public Functions inherited from dakku::VectorBase< T, S, Vector< T, S > > Name VectorBase () Construct a new Vector Base object with all components initialized to zero. template <ArithmeticType Arg> VectorBase (Arg value) Construct a new Vector Base object with all components initialized to value template <ArithmeticType Other,typename OtherDerived > VectorBase (const VectorBase < Other, S, OtherDerived > & other) Construct a new Vector Base object with a vector expression. VectorBase (const VectorBase & other) VectorBase ( VectorBase && other) VectorBase & operator= (const VectorBase & other) VectorBase & operator= ( VectorBase && other) template <ArithmeticType Arg> void set (Arg value) Construct a new Vector Base object with given values. template <ArithmeticType Arg> void setByIndex (size_t index, Arg value) set data[index] to value template <ArithmeticType... Args,size_t... Is> void set (std::index_sequence< Is... > , Args &&... args) set data to args template <ArithmeticType... Args> void set (Args &&... args) set data to args template <ArithmeticType Other,typename OtherDerived > void set (const VectorBase < Other, S, OtherDerived > & rhs) set data by rhs 's data bool hasNaNs () const check whether there are nan components const T & get (size_t i) const get i'th component std::string toString () const convert vector to string size_t size () const size of the vector const T & operator[] (size_t i) const get i'th value T & operator[] (size_t i) get i'th value const Derived & derived () const get derived class Derived & derived () get derived class Derived & operator+= (const Derived & rhs) addition template <ArithmeticType V> Derived & operator+= (const V & rhs) addition Derived & operator-= (const Derived & rhs) subtraction template <ArithmeticType V> Derived & operator-= (const V & rhs) subtraction Derived & operator*= (const Derived & rhs) multiplication template <ArithmeticType V> Derived & operator*= (const V & rhs) multiplication Derived & operator/= (const Derived & rhs) division template <ArithmeticType V> Derived & operator/= (const V & rhs) division std::vector< float > toFloatVector () const convert this to float vector (Property::VECTOR) VectorBase (const std::vector< float > & v) Construct a new Vector Base object with std::vector (Property::VECTOR) decltype(auto) x () const get the first element decltype(auto) x () get the first element decltype(auto) y () const get the second element decltype(auto) y () get the second element decltype(auto) z () const get the third element decltype(auto) z () get the fourth element decltype(auto) w () const get the fourth element decltype(auto) w () get the third element size_t maxElementIndex () const get the index of the max element decltype(auto) maxElement () const get the max element in the vector decltype(auto) begin () decltype(auto) begin () const decltype(auto) end () decltype(auto) end () const template <typename OtherDerived > decltype(auto) dot (const VectorBase < T, S, OtherDerived > & rhs) const dot product between two vectors decltype(auto) squaredNorm () const squared norm decltype(auto) norm () const norm decltype(auto) length () const length Protected Attributes inherited from dakku::VectorBase< T, S, Vector< T, S > > Name std::array< T, S > _data vector base data Friends inherited from dakku::VectorBase< T, S, Vector< T, S > > Name std::ostream & operator<< (std::ostream & os, const VectorBase & vec) output the vector Derived operator+ (const Derived & a, const Derived & b) addition Derived operator+ (const Derived & a, const U & b) addition Derived operator+ (const U & a, const Derived & b) addition Derived operator* (const Derived & a, const Derived & b) multiplication Derived operator* (const Derived & a, const U & b) multiplication Derived operator* (const U & a, const Derived & b) multiplication Derived operator/ (const Derived & a, const Derived & b) division Derived operator/ (const Derived & a, const U & b) division Derived operator/ (const U & a, const Derived & b) division bool operator== (const Derived & a, const Derived & b) a == b (element wise) bool operator!= (const Derived & a, const Derived & b) a != b (element wise) Derived max (const Derived & a, const Derived & b) element wise max Derived min (const Derived & a, const Derived & b) element wise min decltype(auto) distance (const Derived & a, const Derived & b) the distance","title":"Additional inherited members"},{"location":"Classes/classdakku_1_1Vector/#detailed-description","text":"template < ArithmeticType T , size_t S > class dakku :: Vector ; vector Template Parameters : T data type S size","title":"Detailed Description"},{"location":"Classes/classdakku_1_1Vector/#friends_1","text":"","title":"Friends"},{"location":"Classes/classdakku_1_1Vector/#friend-operator-","text":"friend Vector operator - ( const Vector & a , const Vector & b ); subtraction between vectors Updated on 2022-04-07 at 06:53:17 +0000","title":"friend operator-"},{"location":"Classes/classdakku_1_1VectorBase/","text":"dakku::VectorBase vector base class More... #include <vector_base.h> Public Functions Name VectorBase () Construct a new Vector Base object with all components initialized to zero. template <ArithmeticType Arg> VectorBase (Arg value) Construct a new Vector Base object with all components initialized to value template <ArithmeticType Other,typename OtherDerived > VectorBase (const VectorBase < Other, S, OtherDerived > & other) Construct a new Vector Base object with a vector expression. VectorBase (const VectorBase & other) VectorBase ( VectorBase && other) VectorBase & operator= (const VectorBase & other) VectorBase & operator= ( VectorBase && other) template <ArithmeticType Arg> void set (Arg value) Construct a new Vector Base object with given values. template <ArithmeticType Arg> void setByIndex (size_t index, Arg value) set data[index] to value template <ArithmeticType... Args,size_t... Is> void set (std::index_sequence< Is... > , Args &&... args) set data to args template <ArithmeticType... Args> void set (Args &&... args) set data to args template <ArithmeticType Other,typename OtherDerived > void set (const VectorBase < Other, S, OtherDerived > & rhs) set data by rhs 's data bool hasNaNs () const check whether there are nan components const T & get (size_t i) const get i'th component std::string toString () const convert vector to string size_t size () const size of the vector const T & operator[] (size_t i) const get i'th value T & operator[] (size_t i) get i'th value Derived operator- () const negation of the vector const Derived & derived () const get derived class Derived & derived () get derived class Derived & operator+= (const Derived & rhs) addition template <ArithmeticType V> Derived & operator+= (const V & rhs) addition Derived & operator-= (const Derived & rhs) subtraction template <ArithmeticType V> Derived & operator-= (const V & rhs) subtraction Derived & operator*= (const Derived & rhs) multiplication template <ArithmeticType V> Derived & operator*= (const V & rhs) multiplication Derived & operator/= (const Derived & rhs) division template <ArithmeticType V> Derived & operator/= (const V & rhs) division std::vector< float > toFloatVector () const convert this to float vector (Property::VECTOR) VectorBase (const std::vector< float > & v) Construct a new Vector Base object with std::vector (Property::VECTOR) decltype(auto) x () const get the first element decltype(auto) x () get the first element decltype(auto) y () const get the second element decltype(auto) y () get the second element decltype(auto) z () const get the third element decltype(auto) z () get the fourth element decltype(auto) w () const get the fourth element decltype(auto) w () get the third element size_t maxElementIndex () const get the index of the max element decltype(auto) maxElement () const get the max element in the vector decltype(auto) begin () decltype(auto) begin () const decltype(auto) end () decltype(auto) end () const template <typename OtherDerived > decltype(auto) dot (const VectorBase < T, S, OtherDerived > & rhs) const dot product between two vectors decltype(auto) squaredNorm () const squared norm decltype(auto) norm () const norm decltype(auto) length () const length Protected Attributes Name std::array< T, S > _data vector base data Friends Name std::ostream & operator<< (std::ostream & os, const VectorBase & vec) output the vector Derived operator+ (const Derived & a, const Derived & b) addition Derived operator+ (const Derived & a, const U & b) addition Derived operator+ (const U & a, const Derived & b) addition Derived operator- (const Derived & a, const U & b) subtraction Derived operator- (const U & a, const Derived & b) subtraction Derived operator* (const Derived & a, const Derived & b) multiplication Derived operator* (const Derived & a, const U & b) multiplication Derived operator* (const U & a, const Derived & b) multiplication Derived operator/ (const Derived & a, const Derived & b) division Derived operator/ (const Derived & a, const U & b) division Derived operator/ (const U & a, const Derived & b) division bool operator== (const Derived & a, const Derived & b) a == b (element wise) bool operator!= (const Derived & a, const Derived & b) a != b (element wise) Derived max (const Derived & a, const Derived & b) element wise max Derived min (const Derived & a, const Derived & b) element wise min decltype(auto) distance (const Derived & a, const Derived & b) the distance Detailed Description template < ArithmeticType T , size_t S , typename Derived > class dakku :: VectorBase ; vector base class Template Parameters : T type size dimension of the vector Derived derived class type Public Functions Documentation function VectorBase inline explicit VectorBase () Construct a new Vector Base object with all components initialized to zero. function VectorBase template < ArithmeticType Arg > inline VectorBase ( Arg value ) Construct a new Vector Base object with all components initialized to value Parameters : value init value Template Parameters : Arg value type function VectorBase template < ArithmeticType Other , typename OtherDerived > inline explicit VectorBase ( const VectorBase < Other , S , OtherDerived > & other ) Construct a new Vector Base object with a vector expression. Parameters : expr the given expression Template Parameters : Other OtherDerived Expr function VectorBase inline VectorBase ( const VectorBase & other ) function VectorBase inline VectorBase ( VectorBase && other ) function operator= inline VectorBase & operator = ( const VectorBase & other ) function operator= inline VectorBase & operator = ( VectorBase && other ) function set template < ArithmeticType Arg > inline void set ( Arg value ) Construct a new Vector Base object with given values. Parameters : args init values value the given value Template Parameters : Args value types Arg value type set all components to value function setByIndex template < ArithmeticType Arg > inline void setByIndex ( size_t index , Arg value ) set data[index] to value Parameters : index the index of the component value the given value Template Parameters : Arg value type function set template < ArithmeticType ... Args , size_t ... Is > inline void set ( std :: index_sequence < Is ... > , Args && ... args ) set data to args Parameters : args values Template Parameters : Args value types Is indices (generated by std::index_sequence_for) function set template < ArithmeticType ... Args > inline void set ( Args && ... args ) set data to args Parameters : args values Template Parameters : Args value types function set template < ArithmeticType Other , typename OtherDerived > inline void set ( const VectorBase < Other , S , OtherDerived > & rhs ) set data by rhs 's data Parameters : rhs the given vector Template Parameters : Other rhs type OtherDerived rhs derived type function hasNaNs inline bool hasNaNs () const check whether there are nan components Return : true vector contains nan false vector does not contain nans function get inline const T & get ( size_t i ) const get i'th component Parameters : i the index Return : the value function toString inline std :: string toString () const convert vector to string Return : the converted string function size inline size_t size () const size of the vector Return : size function operator[] inline const T & operator []( size_t i ) const get i'th value Parameters : i index Return : value function operator[] inline T & operator []( size_t i ) get i'th value Parameters : i index Return : value function operator- inline Derived operator - () const negation of the vector Return : \\(-\\vec v\\) function derived inline const Derived & derived () const get derived class function derived inline Derived & derived () get derived class function operator+= inline Derived & operator += ( const Derived & rhs ) addition Parameters : rhs another vector Return : this function operator+= template < ArithmeticType V > inline Derived & operator += ( const V & rhs ) addition Parameters : rhs scalar Return : this function operator-= inline Derived & operator -= ( const Derived & rhs ) subtraction Parameters : rhs another vector Return : this function operator-= template < ArithmeticType V > inline Derived & operator -= ( const V & rhs ) subtraction Parameters : rhs scalar Return : this function operator*= inline Derived & operator *= ( const Derived & rhs ) multiplication Parameters : rhs another vector Return : this function operator*= template < ArithmeticType V > inline Derived & operator *= ( const V & rhs ) multiplication Parameters : rhs scalar Return : this function operator/= inline Derived & operator /= ( const Derived & rhs ) division Parameters : rhs another vector Return : this function operator/= template < ArithmeticType V > inline Derived & operator /= ( const V & rhs ) division Parameters : rhs scalar Return : this function toFloatVector inline std :: vector < float > toFloatVector () const convert this to float vector (Property::VECTOR) Return : the float vector function VectorBase inline VectorBase ( const std :: vector < float > & v ) Construct a new Vector Base object with std::vector (Property::VECTOR) Parameters : v the float vector function x inline decltype ( auto ) x () const get the first element function x inline decltype ( auto ) x () get the first element function y inline decltype ( auto ) y () const get the second element function y inline decltype ( auto ) y () get the second element function z inline decltype ( auto ) z () const get the third element function z inline decltype ( auto ) z () get the fourth element function w inline decltype ( auto ) w () const get the fourth element function w inline decltype ( auto ) w () get the third element function maxElementIndex inline size_t maxElementIndex () const get the index of the max element Return : the index function maxElement inline decltype ( auto ) maxElement () const get the max element in the vector Return : the max value function begin inline decltype ( auto ) begin () function begin inline decltype ( auto ) begin () const function end inline decltype ( auto ) end () function end inline decltype ( auto ) end () const function dot template < typename OtherDerived > inline decltype ( auto ) dot ( const VectorBase < T , S , OtherDerived > & rhs ) const dot product between two vectors Return : \\(\\vec a \\cdot \\vec b\\) function squaredNorm inline decltype ( auto ) squaredNorm () const squared norm Return : \\(||v|| ^ 2\\) function norm inline decltype ( auto ) norm () const norm Return : \\(||v||\\) function length inline decltype ( auto ) length () const length Return : \\(||v||\\) Protected Attributes Documentation variable _data std :: array < T , S > _data ; vector base data Friends friend operator<< friend std :: ostream & operator << ( std :: ostream & os , const VectorBase & vec ); output the vector Parameters : os ostream vec the vector to output Return : ostream friend operator+ friend Derived operator + ( const Derived & a , const Derived & b ); addition Parameters : a vector \\(\\vec a\\) b vector \\(\\vec b\\) Return : \\(\\vec a + \\vec b\\) friend operator+ friend Derived operator + ( const Derived & a , const U & b ); addition Parameters : a \\(\\vec a\\) b \\(bb\\) Return : elementwise add b friend operator+ friend Derived operator + ( const U & a , const Derived & b ); addition Parameters : a \\(aa\\) b \\(\\vec b\\) Return : elementwise add a friend operator- friend Derived operator - ( const Derived & a , const U & b ); subtraction Parameters : a \\(\\vec a\\) b \\(bb\\) Return : elementwise sub friend operator- friend Derived operator - ( const U & a , const Derived & b ); subtraction Parameters : a \\(aa\\) b \\(\\vec b\\) Return : elementwise sub friend operator* friend Derived operator * ( const Derived & a , const Derived & b ); multiplication Parameters : a vector \\(\\vec a\\) b vector \\(\\vec b\\) Return : elementwise mul friend operator* friend Derived operator * ( const Derived & a , const U & b ); multiplication Parameters : a \\(\\vec a\\) b \\(bb\\) Return : \\(b\\vec a\\) friend operator* friend Derived operator * ( const U & a , const Derived & b ); multiplication Parameters : a \\(aa\\) b \\(\\vec b\\) Return : elementwise mul friend operator/ friend Derived operator / ( const Derived & a , const Derived & b ); division Parameters : a vector \\(\\vec a\\) b vector \\(\\vec b\\) Return : elementwise div friend operator/ friend Derived operator / ( const Derived & a , const U & b ); division Parameters : a \\(\\vec a\\) b \\(bb\\) Return : \\(\\vec a / b\\) friend operator/ friend Derived operator / ( const U & a , const Derived & b ); division Parameters : a \\(aa\\) b \\(\\vec b\\) Return : elementwise div (broad cast \\(a\\) ) friend operator== friend bool operator == ( const Derived & a , const Derived & b ); a == b (element wise) friend operator!= friend bool operator != ( const Derived & a , const Derived & b ); a != b (element wise) friend max friend Derived max ( const Derived & a , const Derived & b ); element wise max friend min friend Derived min ( const Derived & a , const Derived & b ); element wise min friend distance friend decltype ( auto ) distance ( const Derived & a , const Derived & b ); the distance Updated on 2022-04-07 at 06:53:17 +0000","title":"dakku::VectorBase"},{"location":"Classes/classdakku_1_1VectorBase/#dakkuvectorbase","text":"vector base class More... #include <vector_base.h>","title":"dakku::VectorBase"},{"location":"Classes/classdakku_1_1VectorBase/#public-functions","text":"Name VectorBase () Construct a new Vector Base object with all components initialized to zero. template <ArithmeticType Arg> VectorBase (Arg value) Construct a new Vector Base object with all components initialized to value template <ArithmeticType Other,typename OtherDerived > VectorBase (const VectorBase < Other, S, OtherDerived > & other) Construct a new Vector Base object with a vector expression. VectorBase (const VectorBase & other) VectorBase ( VectorBase && other) VectorBase & operator= (const VectorBase & other) VectorBase & operator= ( VectorBase && other) template <ArithmeticType Arg> void set (Arg value) Construct a new Vector Base object with given values. template <ArithmeticType Arg> void setByIndex (size_t index, Arg value) set data[index] to value template <ArithmeticType... Args,size_t... Is> void set (std::index_sequence< Is... > , Args &&... args) set data to args template <ArithmeticType... Args> void set (Args &&... args) set data to args template <ArithmeticType Other,typename OtherDerived > void set (const VectorBase < Other, S, OtherDerived > & rhs) set data by rhs 's data bool hasNaNs () const check whether there are nan components const T & get (size_t i) const get i'th component std::string toString () const convert vector to string size_t size () const size of the vector const T & operator[] (size_t i) const get i'th value T & operator[] (size_t i) get i'th value Derived operator- () const negation of the vector const Derived & derived () const get derived class Derived & derived () get derived class Derived & operator+= (const Derived & rhs) addition template <ArithmeticType V> Derived & operator+= (const V & rhs) addition Derived & operator-= (const Derived & rhs) subtraction template <ArithmeticType V> Derived & operator-= (const V & rhs) subtraction Derived & operator*= (const Derived & rhs) multiplication template <ArithmeticType V> Derived & operator*= (const V & rhs) multiplication Derived & operator/= (const Derived & rhs) division template <ArithmeticType V> Derived & operator/= (const V & rhs) division std::vector< float > toFloatVector () const convert this to float vector (Property::VECTOR) VectorBase (const std::vector< float > & v) Construct a new Vector Base object with std::vector (Property::VECTOR) decltype(auto) x () const get the first element decltype(auto) x () get the first element decltype(auto) y () const get the second element decltype(auto) y () get the second element decltype(auto) z () const get the third element decltype(auto) z () get the fourth element decltype(auto) w () const get the fourth element decltype(auto) w () get the third element size_t maxElementIndex () const get the index of the max element decltype(auto) maxElement () const get the max element in the vector decltype(auto) begin () decltype(auto) begin () const decltype(auto) end () decltype(auto) end () const template <typename OtherDerived > decltype(auto) dot (const VectorBase < T, S, OtherDerived > & rhs) const dot product between two vectors decltype(auto) squaredNorm () const squared norm decltype(auto) norm () const norm decltype(auto) length () const length","title":"Public Functions"},{"location":"Classes/classdakku_1_1VectorBase/#protected-attributes","text":"Name std::array< T, S > _data vector base data","title":"Protected Attributes"},{"location":"Classes/classdakku_1_1VectorBase/#friends","text":"Name std::ostream & operator<< (std::ostream & os, const VectorBase & vec) output the vector Derived operator+ (const Derived & a, const Derived & b) addition Derived operator+ (const Derived & a, const U & b) addition Derived operator+ (const U & a, const Derived & b) addition Derived operator- (const Derived & a, const U & b) subtraction Derived operator- (const U & a, const Derived & b) subtraction Derived operator* (const Derived & a, const Derived & b) multiplication Derived operator* (const Derived & a, const U & b) multiplication Derived operator* (const U & a, const Derived & b) multiplication Derived operator/ (const Derived & a, const Derived & b) division Derived operator/ (const Derived & a, const U & b) division Derived operator/ (const U & a, const Derived & b) division bool operator== (const Derived & a, const Derived & b) a == b (element wise) bool operator!= (const Derived & a, const Derived & b) a != b (element wise) Derived max (const Derived & a, const Derived & b) element wise max Derived min (const Derived & a, const Derived & b) element wise min decltype(auto) distance (const Derived & a, const Derived & b) the distance","title":"Friends"},{"location":"Classes/classdakku_1_1VectorBase/#detailed-description","text":"template < ArithmeticType T , size_t S , typename Derived > class dakku :: VectorBase ; vector base class Template Parameters : T type size dimension of the vector Derived derived class type","title":"Detailed Description"},{"location":"Classes/classdakku_1_1VectorBase/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Classes/classdakku_1_1VectorBase/#function-vectorbase","text":"inline explicit VectorBase () Construct a new Vector Base object with all components initialized to zero.","title":"function VectorBase"},{"location":"Classes/classdakku_1_1VectorBase/#function-vectorbase_1","text":"template < ArithmeticType Arg > inline VectorBase ( Arg value ) Construct a new Vector Base object with all components initialized to value Parameters : value init value Template Parameters : Arg value type","title":"function VectorBase"},{"location":"Classes/classdakku_1_1VectorBase/#function-vectorbase_2","text":"template < ArithmeticType Other , typename OtherDerived > inline explicit VectorBase ( const VectorBase < Other , S , OtherDerived > & other ) Construct a new Vector Base object with a vector expression. Parameters : expr the given expression Template Parameters : Other OtherDerived Expr","title":"function VectorBase"},{"location":"Classes/classdakku_1_1VectorBase/#function-vectorbase_3","text":"inline VectorBase ( const VectorBase & other )","title":"function VectorBase"},{"location":"Classes/classdakku_1_1VectorBase/#function-vectorbase_4","text":"inline VectorBase ( VectorBase && other )","title":"function VectorBase"},{"location":"Classes/classdakku_1_1VectorBase/#function-operator","text":"inline VectorBase & operator = ( const VectorBase & other )","title":"function operator="},{"location":"Classes/classdakku_1_1VectorBase/#function-operator_1","text":"inline VectorBase & operator = ( VectorBase && other )","title":"function operator="},{"location":"Classes/classdakku_1_1VectorBase/#function-set","text":"template < ArithmeticType Arg > inline void set ( Arg value ) Construct a new Vector Base object with given values. Parameters : args init values value the given value Template Parameters : Args value types Arg value type set all components to value","title":"function set"},{"location":"Classes/classdakku_1_1VectorBase/#function-setbyindex","text":"template < ArithmeticType Arg > inline void setByIndex ( size_t index , Arg value ) set data[index] to value Parameters : index the index of the component value the given value Template Parameters : Arg value type","title":"function setByIndex"},{"location":"Classes/classdakku_1_1VectorBase/#function-set_1","text":"template < ArithmeticType ... Args , size_t ... Is > inline void set ( std :: index_sequence < Is ... > , Args && ... args ) set data to args Parameters : args values Template Parameters : Args value types Is indices (generated by std::index_sequence_for)","title":"function set"},{"location":"Classes/classdakku_1_1VectorBase/#function-set_2","text":"template < ArithmeticType ... Args > inline void set ( Args && ... args ) set data to args Parameters : args values Template Parameters : Args value types","title":"function set"},{"location":"Classes/classdakku_1_1VectorBase/#function-set_3","text":"template < ArithmeticType Other , typename OtherDerived > inline void set ( const VectorBase < Other , S , OtherDerived > & rhs ) set data by rhs 's data Parameters : rhs the given vector Template Parameters : Other rhs type OtherDerived rhs derived type","title":"function set"},{"location":"Classes/classdakku_1_1VectorBase/#function-hasnans","text":"inline bool hasNaNs () const check whether there are nan components Return : true vector contains nan false vector does not contain nans","title":"function hasNaNs"},{"location":"Classes/classdakku_1_1VectorBase/#function-get","text":"inline const T & get ( size_t i ) const get i'th component Parameters : i the index Return : the value","title":"function get"},{"location":"Classes/classdakku_1_1VectorBase/#function-tostring","text":"inline std :: string toString () const convert vector to string Return : the converted string","title":"function toString"},{"location":"Classes/classdakku_1_1VectorBase/#function-size","text":"inline size_t size () const size of the vector Return : size","title":"function size"},{"location":"Classes/classdakku_1_1VectorBase/#function-operator_2","text":"inline const T & operator []( size_t i ) const get i'th value Parameters : i index Return : value","title":"function operator[]"},{"location":"Classes/classdakku_1_1VectorBase/#function-operator_3","text":"inline T & operator []( size_t i ) get i'th value Parameters : i index Return : value","title":"function operator[]"},{"location":"Classes/classdakku_1_1VectorBase/#function-operator-","text":"inline Derived operator - () const negation of the vector Return : \\(-\\vec v\\)","title":"function operator-"},{"location":"Classes/classdakku_1_1VectorBase/#function-derived","text":"inline const Derived & derived () const get derived class","title":"function derived"},{"location":"Classes/classdakku_1_1VectorBase/#function-derived_1","text":"inline Derived & derived () get derived class","title":"function derived"},{"location":"Classes/classdakku_1_1VectorBase/#function-operator_4","text":"inline Derived & operator += ( const Derived & rhs ) addition Parameters : rhs another vector Return : this","title":"function operator+="},{"location":"Classes/classdakku_1_1VectorBase/#function-operator_5","text":"template < ArithmeticType V > inline Derived & operator += ( const V & rhs ) addition Parameters : rhs scalar Return : this","title":"function operator+="},{"location":"Classes/classdakku_1_1VectorBase/#function-operator-_1","text":"inline Derived & operator -= ( const Derived & rhs ) subtraction Parameters : rhs another vector Return : this","title":"function operator-="},{"location":"Classes/classdakku_1_1VectorBase/#function-operator-_2","text":"template < ArithmeticType V > inline Derived & operator -= ( const V & rhs ) subtraction Parameters : rhs scalar Return : this","title":"function operator-="},{"location":"Classes/classdakku_1_1VectorBase/#function-operator_6","text":"inline Derived & operator *= ( const Derived & rhs ) multiplication Parameters : rhs another vector Return : this","title":"function operator*="},{"location":"Classes/classdakku_1_1VectorBase/#function-operator_7","text":"template < ArithmeticType V > inline Derived & operator *= ( const V & rhs ) multiplication Parameters : rhs scalar Return : this","title":"function operator*="},{"location":"Classes/classdakku_1_1VectorBase/#function-operator_8","text":"inline Derived & operator /= ( const Derived & rhs ) division Parameters : rhs another vector Return : this","title":"function operator/="},{"location":"Classes/classdakku_1_1VectorBase/#function-operator_9","text":"template < ArithmeticType V > inline Derived & operator /= ( const V & rhs ) division Parameters : rhs scalar Return : this","title":"function operator/="},{"location":"Classes/classdakku_1_1VectorBase/#function-tofloatvector","text":"inline std :: vector < float > toFloatVector () const convert this to float vector (Property::VECTOR) Return : the float vector","title":"function toFloatVector"},{"location":"Classes/classdakku_1_1VectorBase/#function-vectorbase_5","text":"inline VectorBase ( const std :: vector < float > & v ) Construct a new Vector Base object with std::vector (Property::VECTOR) Parameters : v the float vector","title":"function VectorBase"},{"location":"Classes/classdakku_1_1VectorBase/#function-x","text":"inline decltype ( auto ) x () const get the first element","title":"function x"},{"location":"Classes/classdakku_1_1VectorBase/#function-x_1","text":"inline decltype ( auto ) x () get the first element","title":"function x"},{"location":"Classes/classdakku_1_1VectorBase/#function-y","text":"inline decltype ( auto ) y () const get the second element","title":"function y"},{"location":"Classes/classdakku_1_1VectorBase/#function-y_1","text":"inline decltype ( auto ) y () get the second element","title":"function y"},{"location":"Classes/classdakku_1_1VectorBase/#function-z","text":"inline decltype ( auto ) z () const get the third element","title":"function z"},{"location":"Classes/classdakku_1_1VectorBase/#function-z_1","text":"inline decltype ( auto ) z () get the fourth element","title":"function z"},{"location":"Classes/classdakku_1_1VectorBase/#function-w","text":"inline decltype ( auto ) w () const get the fourth element","title":"function w"},{"location":"Classes/classdakku_1_1VectorBase/#function-w_1","text":"inline decltype ( auto ) w () get the third element","title":"function w"},{"location":"Classes/classdakku_1_1VectorBase/#function-maxelementindex","text":"inline size_t maxElementIndex () const get the index of the max element Return : the index","title":"function maxElementIndex"},{"location":"Classes/classdakku_1_1VectorBase/#function-maxelement","text":"inline decltype ( auto ) maxElement () const get the max element in the vector Return : the max value","title":"function maxElement"},{"location":"Classes/classdakku_1_1VectorBase/#function-begin","text":"inline decltype ( auto ) begin ()","title":"function begin"},{"location":"Classes/classdakku_1_1VectorBase/#function-begin_1","text":"inline decltype ( auto ) begin () const","title":"function begin"},{"location":"Classes/classdakku_1_1VectorBase/#function-end","text":"inline decltype ( auto ) end ()","title":"function end"},{"location":"Classes/classdakku_1_1VectorBase/#function-end_1","text":"inline decltype ( auto ) end () const","title":"function end"},{"location":"Classes/classdakku_1_1VectorBase/#function-dot","text":"template < typename OtherDerived > inline decltype ( auto ) dot ( const VectorBase < T , S , OtherDerived > & rhs ) const dot product between two vectors Return : \\(\\vec a \\cdot \\vec b\\)","title":"function dot"},{"location":"Classes/classdakku_1_1VectorBase/#function-squarednorm","text":"inline decltype ( auto ) squaredNorm () const squared norm Return : \\(||v|| ^ 2\\)","title":"function squaredNorm"},{"location":"Classes/classdakku_1_1VectorBase/#function-norm","text":"inline decltype ( auto ) norm () const norm Return : \\(||v||\\)","title":"function norm"},{"location":"Classes/classdakku_1_1VectorBase/#function-length","text":"inline decltype ( auto ) length () const length Return : \\(||v||\\)","title":"function length"},{"location":"Classes/classdakku_1_1VectorBase/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"Classes/classdakku_1_1VectorBase/#variable-_data","text":"std :: array < T , S > _data ; vector base data","title":"variable _data"},{"location":"Classes/classdakku_1_1VectorBase/#friends_1","text":"","title":"Friends"},{"location":"Classes/classdakku_1_1VectorBase/#friend-operator","text":"friend std :: ostream & operator << ( std :: ostream & os , const VectorBase & vec ); output the vector Parameters : os ostream vec the vector to output Return : ostream","title":"friend operator&lt;&lt;"},{"location":"Classes/classdakku_1_1VectorBase/#friend-operator_1","text":"friend Derived operator + ( const Derived & a , const Derived & b ); addition Parameters : a vector \\(\\vec a\\) b vector \\(\\vec b\\) Return : \\(\\vec a + \\vec b\\)","title":"friend operator+"},{"location":"Classes/classdakku_1_1VectorBase/#friend-operator_2","text":"friend Derived operator + ( const Derived & a , const U & b ); addition Parameters : a \\(\\vec a\\) b \\(bb\\) Return : elementwise add b","title":"friend operator+"},{"location":"Classes/classdakku_1_1VectorBase/#friend-operator_3","text":"friend Derived operator + ( const U & a , const Derived & b ); addition Parameters : a \\(aa\\) b \\(\\vec b\\) Return : elementwise add a","title":"friend operator+"},{"location":"Classes/classdakku_1_1VectorBase/#friend-operator-","text":"friend Derived operator - ( const Derived & a , const U & b ); subtraction Parameters : a \\(\\vec a\\) b \\(bb\\) Return : elementwise sub","title":"friend operator-"},{"location":"Classes/classdakku_1_1VectorBase/#friend-operator-_1","text":"friend Derived operator - ( const U & a , const Derived & b ); subtraction Parameters : a \\(aa\\) b \\(\\vec b\\) Return : elementwise sub","title":"friend operator-"},{"location":"Classes/classdakku_1_1VectorBase/#friend-operator_4","text":"friend Derived operator * ( const Derived & a , const Derived & b ); multiplication Parameters : a vector \\(\\vec a\\) b vector \\(\\vec b\\) Return : elementwise mul","title":"friend operator*"},{"location":"Classes/classdakku_1_1VectorBase/#friend-operator_5","text":"friend Derived operator * ( const Derived & a , const U & b ); multiplication Parameters : a \\(\\vec a\\) b \\(bb\\) Return : \\(b\\vec a\\)","title":"friend operator*"},{"location":"Classes/classdakku_1_1VectorBase/#friend-operator_6","text":"friend Derived operator * ( const U & a , const Derived & b ); multiplication Parameters : a \\(aa\\) b \\(\\vec b\\) Return : elementwise mul","title":"friend operator*"},{"location":"Classes/classdakku_1_1VectorBase/#friend-operator_7","text":"friend Derived operator / ( const Derived & a , const Derived & b ); division Parameters : a vector \\(\\vec a\\) b vector \\(\\vec b\\) Return : elementwise div","title":"friend operator/"},{"location":"Classes/classdakku_1_1VectorBase/#friend-operator_8","text":"friend Derived operator / ( const Derived & a , const U & b ); division Parameters : a \\(\\vec a\\) b \\(bb\\) Return : \\(\\vec a / b\\)","title":"friend operator/"},{"location":"Classes/classdakku_1_1VectorBase/#friend-operator_9","text":"friend Derived operator / ( const U & a , const Derived & b ); division Parameters : a \\(aa\\) b \\(\\vec b\\) Return : elementwise div (broad cast \\(a\\) )","title":"friend operator/"},{"location":"Classes/classdakku_1_1VectorBase/#friend-operator_10","text":"friend bool operator == ( const Derived & a , const Derived & b ); a == b (element wise)","title":"friend operator=="},{"location":"Classes/classdakku_1_1VectorBase/#friend-operator_11","text":"friend bool operator != ( const Derived & a , const Derived & b ); a != b (element wise)","title":"friend operator!="},{"location":"Classes/classdakku_1_1VectorBase/#friend-max","text":"friend Derived max ( const Derived & a , const Derived & b ); element wise max","title":"friend max"},{"location":"Classes/classdakku_1_1VectorBase/#friend-min","text":"friend Derived min ( const Derived & a , const Derived & b ); element wise min","title":"friend min"},{"location":"Classes/classdakku_1_1VectorBase/#friend-distance","text":"friend decltype ( auto ) distance ( const Derived & a , const Derived & b ); the distance Updated on 2022-04-07 at 06:53:17 +0000","title":"friend distance"},{"location":"Classes/structdakku_1_1Matrix4x4/","text":"dakku::Matrix4x4 4x4 matrix #include <transform.h> Public Functions Name Matrix4x4 () Construct a new Matrix 4x 4 object. Matrix4x4 (float t00, float t01, float t02, float t03, float t10, float t11, float t12, float t13, float t20, float t21, float t22, float t23, float t30, float t31, float t32, float t33) decltype(auto) operator[] (size_t i) const decltype(auto) operator[] (size_t i) void setIdentity () Public Attributes Name std::array< std::array< float, 4 >, 4 > m Friends Name Matrix4x4 transpose (const Matrix4x4 & m) Public Functions Documentation function Matrix4x4 inline Matrix4x4 () Construct a new Matrix 4x 4 object. function Matrix4x4 inline Matrix4x4 ( float t00 , float t01 , float t02 , float t03 , float t10 , float t11 , float t12 , float t13 , float t20 , float t21 , float t22 , float t23 , float t30 , float t31 , float t32 , float t33 ) function operator[] inline decltype ( auto ) operator []( size_t i ) const function operator[] inline decltype ( auto ) operator []( size_t i ) function setIdentity inline void setIdentity () Public Attributes Documentation variable m std :: array < std :: array < float , 4 > , 4 > m ; Friends friend transpose friend Matrix4x4 transpose ( const Matrix4x4 & m ); Updated on 2022-04-07 at 06:53:17 +0000","title":"dakku::Matrix4x4"},{"location":"Classes/structdakku_1_1Matrix4x4/#dakkumatrix4x4","text":"4x4 matrix #include <transform.h>","title":"dakku::Matrix4x4"},{"location":"Classes/structdakku_1_1Matrix4x4/#public-functions","text":"Name Matrix4x4 () Construct a new Matrix 4x 4 object. Matrix4x4 (float t00, float t01, float t02, float t03, float t10, float t11, float t12, float t13, float t20, float t21, float t22, float t23, float t30, float t31, float t32, float t33) decltype(auto) operator[] (size_t i) const decltype(auto) operator[] (size_t i) void setIdentity ()","title":"Public Functions"},{"location":"Classes/structdakku_1_1Matrix4x4/#public-attributes","text":"Name std::array< std::array< float, 4 >, 4 > m","title":"Public Attributes"},{"location":"Classes/structdakku_1_1Matrix4x4/#friends","text":"Name Matrix4x4 transpose (const Matrix4x4 & m)","title":"Friends"},{"location":"Classes/structdakku_1_1Matrix4x4/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Classes/structdakku_1_1Matrix4x4/#function-matrix4x4","text":"inline Matrix4x4 () Construct a new Matrix 4x 4 object.","title":"function Matrix4x4"},{"location":"Classes/structdakku_1_1Matrix4x4/#function-matrix4x4_1","text":"inline Matrix4x4 ( float t00 , float t01 , float t02 , float t03 , float t10 , float t11 , float t12 , float t13 , float t20 , float t21 , float t22 , float t23 , float t30 , float t31 , float t32 , float t33 )","title":"function Matrix4x4"},{"location":"Classes/structdakku_1_1Matrix4x4/#function-operator","text":"inline decltype ( auto ) operator []( size_t i ) const","title":"function operator[]"},{"location":"Classes/structdakku_1_1Matrix4x4/#function-operator_1","text":"inline decltype ( auto ) operator []( size_t i )","title":"function operator[]"},{"location":"Classes/structdakku_1_1Matrix4x4/#function-setidentity","text":"inline void setIdentity ()","title":"function setIdentity"},{"location":"Classes/structdakku_1_1Matrix4x4/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"Classes/structdakku_1_1Matrix4x4/#variable-m","text":"std :: array < std :: array < float , 4 > , 4 > m ;","title":"variable m"},{"location":"Classes/structdakku_1_1Matrix4x4/#friends_1","text":"","title":"Friends"},{"location":"Classes/structdakku_1_1Matrix4x4/#friend-transpose","text":"friend Matrix4x4 transpose ( const Matrix4x4 & m ); Updated on 2022-04-07 at 06:53:17 +0000","title":"friend transpose"},{"location":"Examples/","text":"Examples Updated on 2022-04-07 at 06:53:17 +0000","title":"Examples"},{"location":"Examples/#examples","text":"Updated on 2022-04-07 at 06:53:17 +0000","title":"Examples"},{"location":"Files/","text":"Files dir src file src/platform.h dir src/core file src/core/bounds.h file src/core/class.h file src/core/fwd.h file src/core/logger.h file src/core/property.h file src/core/transform.h file src/core/vector.h file src/core/vector_base.h Updated on 2022-04-07 at 06:53:17 +0000","title":"Files"},{"location":"Files/#files","text":"dir src file src/platform.h dir src/core file src/core/bounds.h file src/core/class.h file src/core/fwd.h file src/core/logger.h file src/core/property.h file src/core/transform.h file src/core/vector.h file src/core/vector_base.h Updated on 2022-04-07 at 06:53:17 +0000","title":"Files"},{"location":"Files/bounds_8h/","text":"src/core/bounds.h Namespaces Name dakku dakku namespace Classes Name class dakku::BoundsBase bounding box base class dakku::Bounds2 2d bounding box class dakku::Bounds3 3d bounding box class dakku::Bounds2iIterator 2d integer bounds iterator, iterate all pixels inside Source code #ifndef DAKKU_CORE_BOUNDS_H_ #define DAKKU_CORE_BOUNDS_H_ #include <core/vector.h> #include <iterator> namespace dakku { template < ArithmeticType T , size_t S > class BoundsBase { public : BoundsBase () = default ; explicit BoundsBase ( const Point < T , S > & p ) : pMin ( p ), pMax ( p ) {} BoundsBase ( const Point < T , S > & p1 , const Point < T , S > & p2 ) : pMin ( min ( p1 , p2 )), pMax ( max ( p1 , p2 )) {} template < ArithmeticType U > explicit operator BoundsBase < U , S > () const { return BoundsBase < U , S > ( Point < U , S > ( pMin ), Point < U , S > ( pMax )); } [[ nodiscard ]] Vector < T , S > diagonal () const { return pMax - pMin ; } [[ nodiscard ]] size_t maxExtent () const { return this -> diagonal (). maxElementIndex (); } bool operator == ( const BoundsBase & rhs ) const { return pMin == rhs . pMin && pMax == rhs . pMax ; } bool operator != ( const BoundsBase & rhs ) const { return pMin != rhs . pMin || pMax != rhs . pMax ; } [[ nodiscard ]] Point < T , S > lerp ( const Point < float , S > & t ) const { Point < T , S > ret ; for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = std :: lerp ( pMin [ i ], pMax [ i ], t [ i ]); return ret ; } [[ nodiscard ]] Vector < T , S > offset ( const Point < T , S > & p ) const { Vector < T , S > o = p - pMin ; for ( size_t i = 0 ; i < S ; ++ i ) if ( pMax [ i ] > pMin [ i ]) o [ i ] /= pMax [ i ] - pMin [ i ]; return o ; } friend bool overlaps ( const BoundsBase & a , const BoundsBase & b ) { for ( size_t i = 0 ; i < S ; ++ i ) if ( ! ( a . pMax [ i ] >= b . pMin [ i ] && a . pMin [ i ] <= b . pMax [ i ])) return false ; return true ; } friend bool inside ( const Point < T , S > & p , const BoundsBase & b ) { for ( size_t i = 0 ; i < S ; ++ i ) if ( ! ( p [ i ] >= b . pMin [ i ] && p [ i ] <= b . pMax [ i ])) return false ; return true ; } friend bool insideExclusive ( const Point < T , S > & p , const BoundsBase & b ) { for ( size_t i = 0 ; i < S ; ++ i ) if ( ! ( p [ i ] >= b . pMin [ i ] && p [ i ] < b . pMax [ i ])) return false ; return true ; } friend decltype ( auto ) distanceSquared ( const Point < T , S > & p , const BoundsBase & b ) { return max ( Vector < T , S > {}, max ( b . pMin - p , p - b . pMax )). squaredNorm (); } friend decltype ( auto ) distance ( const Point < T , S > & p , const BoundsBase & b ) { return std :: sqrt ( distanceSquared ( p , b )); } void boundingSphere ( Point < T , S > & center , float & rad ) { center = ( pMin + pMax ) / 2 ; rad = inside ( center , * this ) ? distance ( center , pMax ) : 0 ; } Point < T , S > pMin { std :: numeric_limits < T >:: max ()}; Point < T , S > pMax { std :: numeric_limits < T >:: lowest ()}; }; template < ArithmeticType T > class Bounds2 : public BoundsBase < T , 2 > { public : using BoundsBase < T , 2 >:: BoundsBase ; [[ nodiscard ]] decltype ( auto ) area () const { auto d = this -> diagonal (); return d . x () * d . y (); } }; using Bounds2f = Bounds2 < float > ; using Bounds2i = Bounds2 < int > ; template < ArithmeticType T > class Bounds3 : public BoundsBase < T , 3 > { public : using BoundsBase < T , 3 >:: BoundsBase ; }; class Bounds2iIterator : public std :: forward_iterator_tag { public : explicit Bounds2iIterator ( const Bounds2i & b , const Point2i & p ) : b ( b ), p ( p ) {} Bounds2iIterator operator ++ () { advance (); return * this ; } Bounds2iIterator operator ++ ( int ) { Bounds2iIterator ret = * this ; advance (); return ret ; } bool operator == ( const Bounds2iIterator & rhs ) const { return p == rhs . p && ( & b == & rhs . b ); } bool operator != ( const Bounds2iIterator & rhs ) const { return p != rhs . p || ( & b != & rhs . b ); } Point2i operator * () const { return p ; } private : void advance () { ++ p . x (); if ( p . x () == b . pMax . x ()) { p . x () = b . pMin . x (); ++ p . y (); } } const Bounds2i & b ; Point2i p ; }; inline Bounds2iIterator begin ( const Bounds2i & b ) { return Bounds2iIterator { b , b . pMin }; } inline Bounds2iIterator end ( const Bounds2i & b ) { // normally, the ending point is at the minimum x value and one past // the last valid y value. Point2i pEnd ( b . pMin . x (), b . pMax . y ()); // however, if the bounds are degenerate, override the end point to // equal the start point so that any attempt to iterate over the bounds // exits out immediately. if ( b . pMin . x () >= b . pMax . x () || b . pMin . y () >= b . pMax . y ()) pEnd = b . pMin ; return Bounds2iIterator { b , pEnd }; } } // namespace dakku #endif Updated on 2022-04-07 at 06:53:17 +0000","title":"src/core/bounds.h"},{"location":"Files/bounds_8h/#srccoreboundsh","text":"","title":"src/core/bounds.h"},{"location":"Files/bounds_8h/#namespaces","text":"Name dakku dakku namespace","title":"Namespaces"},{"location":"Files/bounds_8h/#classes","text":"Name class dakku::BoundsBase bounding box base class dakku::Bounds2 2d bounding box class dakku::Bounds3 3d bounding box class dakku::Bounds2iIterator 2d integer bounds iterator, iterate all pixels inside","title":"Classes"},{"location":"Files/bounds_8h/#source-code","text":"#ifndef DAKKU_CORE_BOUNDS_H_ #define DAKKU_CORE_BOUNDS_H_ #include <core/vector.h> #include <iterator> namespace dakku { template < ArithmeticType T , size_t S > class BoundsBase { public : BoundsBase () = default ; explicit BoundsBase ( const Point < T , S > & p ) : pMin ( p ), pMax ( p ) {} BoundsBase ( const Point < T , S > & p1 , const Point < T , S > & p2 ) : pMin ( min ( p1 , p2 )), pMax ( max ( p1 , p2 )) {} template < ArithmeticType U > explicit operator BoundsBase < U , S > () const { return BoundsBase < U , S > ( Point < U , S > ( pMin ), Point < U , S > ( pMax )); } [[ nodiscard ]] Vector < T , S > diagonal () const { return pMax - pMin ; } [[ nodiscard ]] size_t maxExtent () const { return this -> diagonal (). maxElementIndex (); } bool operator == ( const BoundsBase & rhs ) const { return pMin == rhs . pMin && pMax == rhs . pMax ; } bool operator != ( const BoundsBase & rhs ) const { return pMin != rhs . pMin || pMax != rhs . pMax ; } [[ nodiscard ]] Point < T , S > lerp ( const Point < float , S > & t ) const { Point < T , S > ret ; for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = std :: lerp ( pMin [ i ], pMax [ i ], t [ i ]); return ret ; } [[ nodiscard ]] Vector < T , S > offset ( const Point < T , S > & p ) const { Vector < T , S > o = p - pMin ; for ( size_t i = 0 ; i < S ; ++ i ) if ( pMax [ i ] > pMin [ i ]) o [ i ] /= pMax [ i ] - pMin [ i ]; return o ; } friend bool overlaps ( const BoundsBase & a , const BoundsBase & b ) { for ( size_t i = 0 ; i < S ; ++ i ) if ( ! ( a . pMax [ i ] >= b . pMin [ i ] && a . pMin [ i ] <= b . pMax [ i ])) return false ; return true ; } friend bool inside ( const Point < T , S > & p , const BoundsBase & b ) { for ( size_t i = 0 ; i < S ; ++ i ) if ( ! ( p [ i ] >= b . pMin [ i ] && p [ i ] <= b . pMax [ i ])) return false ; return true ; } friend bool insideExclusive ( const Point < T , S > & p , const BoundsBase & b ) { for ( size_t i = 0 ; i < S ; ++ i ) if ( ! ( p [ i ] >= b . pMin [ i ] && p [ i ] < b . pMax [ i ])) return false ; return true ; } friend decltype ( auto ) distanceSquared ( const Point < T , S > & p , const BoundsBase & b ) { return max ( Vector < T , S > {}, max ( b . pMin - p , p - b . pMax )). squaredNorm (); } friend decltype ( auto ) distance ( const Point < T , S > & p , const BoundsBase & b ) { return std :: sqrt ( distanceSquared ( p , b )); } void boundingSphere ( Point < T , S > & center , float & rad ) { center = ( pMin + pMax ) / 2 ; rad = inside ( center , * this ) ? distance ( center , pMax ) : 0 ; } Point < T , S > pMin { std :: numeric_limits < T >:: max ()}; Point < T , S > pMax { std :: numeric_limits < T >:: lowest ()}; }; template < ArithmeticType T > class Bounds2 : public BoundsBase < T , 2 > { public : using BoundsBase < T , 2 >:: BoundsBase ; [[ nodiscard ]] decltype ( auto ) area () const { auto d = this -> diagonal (); return d . x () * d . y (); } }; using Bounds2f = Bounds2 < float > ; using Bounds2i = Bounds2 < int > ; template < ArithmeticType T > class Bounds3 : public BoundsBase < T , 3 > { public : using BoundsBase < T , 3 >:: BoundsBase ; }; class Bounds2iIterator : public std :: forward_iterator_tag { public : explicit Bounds2iIterator ( const Bounds2i & b , const Point2i & p ) : b ( b ), p ( p ) {} Bounds2iIterator operator ++ () { advance (); return * this ; } Bounds2iIterator operator ++ ( int ) { Bounds2iIterator ret = * this ; advance (); return ret ; } bool operator == ( const Bounds2iIterator & rhs ) const { return p == rhs . p && ( & b == & rhs . b ); } bool operator != ( const Bounds2iIterator & rhs ) const { return p != rhs . p || ( & b != & rhs . b ); } Point2i operator * () const { return p ; } private : void advance () { ++ p . x (); if ( p . x () == b . pMax . x ()) { p . x () = b . pMin . x (); ++ p . y (); } } const Bounds2i & b ; Point2i p ; }; inline Bounds2iIterator begin ( const Bounds2i & b ) { return Bounds2iIterator { b , b . pMin }; } inline Bounds2iIterator end ( const Bounds2i & b ) { // normally, the ending point is at the minimum x value and one past // the last valid y value. Point2i pEnd ( b . pMin . x (), b . pMax . y ()); // however, if the bounds are degenerate, override the end point to // equal the start point so that any attempt to iterate over the bounds // exits out immediately. if ( b . pMin . x () >= b . pMax . x () || b . pMin . y () >= b . pMax . y ()) pEnd = b . pMin ; return Bounds2iIterator { b , pEnd }; } } // namespace dakku #endif Updated on 2022-04-07 at 06:53:17 +0000","title":"Source code"},{"location":"Files/class_8h/","text":"src/core/class.h Namespaces Name dakku dakku namespace Classes Name class dakku::Class RTTI support. Source code #ifndef DAKKU_CORE_CLASS_H_ #define DAKKU_CORE_CLASS_H_ #include <core/fwd.h> namespace dakku { class DAKKU_EXPORT_CORE Class { public : static Class & instance (); private : }; } // namespace dakku #endif Updated on 2022-04-07 at 06:53:17 +0000","title":"src/core/class.h"},{"location":"Files/class_8h/#srccoreclassh","text":"","title":"src/core/class.h"},{"location":"Files/class_8h/#namespaces","text":"Name dakku dakku namespace","title":"Namespaces"},{"location":"Files/class_8h/#classes","text":"Name class dakku::Class RTTI support.","title":"Classes"},{"location":"Files/class_8h/#source-code","text":"#ifndef DAKKU_CORE_CLASS_H_ #define DAKKU_CORE_CLASS_H_ #include <core/fwd.h> namespace dakku { class DAKKU_EXPORT_CORE Class { public : static Class & instance (); private : }; } // namespace dakku #endif Updated on 2022-04-07 at 06:53:17 +0000","title":"Source code"},{"location":"Files/dir_68267d1309a1af8e8297ef4c3efbcdba/","text":"src Directories Name src/core Files Name src/platform.h Updated on 2022-04-07 at 06:53:17 +0000","title":"src"},{"location":"Files/dir_68267d1309a1af8e8297ef4c3efbcdba/#src","text":"","title":"src"},{"location":"Files/dir_68267d1309a1af8e8297ef4c3efbcdba/#directories","text":"Name src/core","title":"Directories"},{"location":"Files/dir_68267d1309a1af8e8297ef4c3efbcdba/#files","text":"Name src/platform.h Updated on 2022-04-07 at 06:53:17 +0000","title":"Files"},{"location":"Files/dir_aebb8dcc11953d78e620bbef0b9e2183/","text":"src/core Files Name src/core/bounds.h src/core/class.h src/core/fwd.h src/core/logger.h src/core/property.h src/core/transform.h src/core/vector.h src/core/vector_base.h Updated on 2022-04-07 at 06:53:17 +0000","title":"src/core"},{"location":"Files/dir_aebb8dcc11953d78e620bbef0b9e2183/#srccore","text":"","title":"src/core"},{"location":"Files/dir_aebb8dcc11953d78e620bbef0b9e2183/#files","text":"Name src/core/bounds.h src/core/class.h src/core/fwd.h src/core/logger.h src/core/property.h src/core/transform.h src/core/vector.h src/core/vector_base.h Updated on 2022-04-07 at 06:53:17 +0000","title":"Files"},{"location":"Files/fwd_8h/","text":"src/core/fwd.h Namespaces Name dakku dakku namespace Defines Name DAKKU_EXPORT_CORE Macros Documentation define DAKKU_EXPORT_CORE #define DAKKU_EXPORT_CORE DAKKU_EXPORT Source code #ifndef DAKKU_CORE_FWD_H_ #define DAKKU_CORE_FWD_H_ #include <platform.h> #include <type_traits> #include <limits> #include <numbers> #include <cmath> namespace dakku { #if DAKKU_BUILD_MODULE != DAKKU_CORE_MODULE #define DAKKU_EXPORT_CORE DAKKU_IMPORT #else #define DAKKU_EXPORT_CORE DAKKU_EXPORT #endif static constexpr float INF = std :: numeric_limits < float >:: infinity (); template < typename T > concept ArithmeticType = std :: is_arithmetic_v < std :: decay_t < T >> ; template < typename T > requires std :: is_floating_point_v < T > DAKKU_INLINE bool isNaN ( T x ) { return std :: isnan ( x ); } template < typename T > requires std :: is_integral_v < T > DAKKU_INLINE bool isNaN ( T ) { return false ; } class Transform ; } // namespace dakku #endif Updated on 2022-04-07 at 06:53:17 +0000","title":"src/core/fwd.h"},{"location":"Files/fwd_8h/#srccorefwdh","text":"","title":"src/core/fwd.h"},{"location":"Files/fwd_8h/#namespaces","text":"Name dakku dakku namespace","title":"Namespaces"},{"location":"Files/fwd_8h/#defines","text":"Name DAKKU_EXPORT_CORE","title":"Defines"},{"location":"Files/fwd_8h/#macros-documentation","text":"","title":"Macros Documentation"},{"location":"Files/fwd_8h/#define-dakku_export_core","text":"#define DAKKU_EXPORT_CORE DAKKU_EXPORT","title":"define DAKKU_EXPORT_CORE"},{"location":"Files/fwd_8h/#source-code","text":"#ifndef DAKKU_CORE_FWD_H_ #define DAKKU_CORE_FWD_H_ #include <platform.h> #include <type_traits> #include <limits> #include <numbers> #include <cmath> namespace dakku { #if DAKKU_BUILD_MODULE != DAKKU_CORE_MODULE #define DAKKU_EXPORT_CORE DAKKU_IMPORT #else #define DAKKU_EXPORT_CORE DAKKU_EXPORT #endif static constexpr float INF = std :: numeric_limits < float >:: infinity (); template < typename T > concept ArithmeticType = std :: is_arithmetic_v < std :: decay_t < T >> ; template < typename T > requires std :: is_floating_point_v < T > DAKKU_INLINE bool isNaN ( T x ) { return std :: isnan ( x ); } template < typename T > requires std :: is_integral_v < T > DAKKU_INLINE bool isNaN ( T ) { return false ; } class Transform ; } // namespace dakku #endif Updated on 2022-04-07 at 06:53:17 +0000","title":"Source code"},{"location":"Files/logger_8h/","text":"src/core/logger.h Namespaces Name dakku dakku namespace Classes Name class dakku::Logger logger class Defines Name DAKKU_ERR (...) log error message DAKKU_INFO (...) log info message DAKKU_WARN (...) log warning message DAKKU_DEBUG (...) log debug message DAKKU_CHECK (...) check whether the condition val is true, if not log error messages Macros Documentation define DAKKU_ERR #define DAKKU_ERR( ... ) SPDLOG_LOGGER_CALL ( Logger :: get (). handle (), spdlog :: level :: err , __VA_ARGS__ ) log error message define DAKKU_INFO #define DAKKU_INFO( ... ) SPDLOG_LOGGER_CALL ( Logger :: get (). handle (), spdlog :: level :: info , __VA_ARGS__ ) log info message define DAKKU_WARN #define DAKKU_WARN( ... ) SPDLOG_LOGGER_CALL ( Logger :: get (). handle (), spdlog :: level :: warn , __VA_ARGS__ ) log warning message define DAKKU_DEBUG #define DAKKU_DEBUG( ... ) static_cast < void > ( 0 ) log debug message define DAKKU_CHECK #define DAKKU_CHECK( ... ) static_cast < void > ( 0 ) check whether the condition val is true, if not log error messages Source code #ifndef DAKKU_CORE_LOGGER_H_ #define DAKKU_CORE_LOGGER_H_ #include <core/fwd.h> #include <spdlog/spdlog.h> #include <spdlog/fmt/ostr.h> #include <cstdlib> namespace dakku { class DAKKU_EXPORT_CORE Logger { public : static const Logger & get (); [[ nodiscard ]] spdlog :: logger * handle () const { return _logger . get (); } private : explicit Logger ( std :: shared_ptr < spdlog :: logger > _logger ); std :: shared_ptr < spdlog :: logger > _logger ; }; #define DAKKU_ERR(...) \\ SPDLOG_LOGGER_CALL(Logger::get().handle(), spdlog::level::err, __VA_ARGS__) #define DAKKU_INFO(...) \\ SPDLOG_LOGGER_CALL(Logger::get().handle(), spdlog::level::info, __VA_ARGS__) #define DAKKU_WARN(...) \\ SPDLOG_LOGGER_CALL(Logger::get().handle(), spdlog::level::warn, __VA_ARGS__) #ifdef DAKKU_BUILD_DEBUG #define DAKKU_DEBUG(...) \\ SPDLOG_LOGGER_CALL(Logger::get().handle(), spdlog::level::debug, __VA_ARGS__) #else #define DAKKU_DEBUG(...) static_cast<void>(0) #endif #ifdef DAKKU_BUILD_CHECK #define DAKKU_CHECK(val, ...) \\ do { \\ if (!(val)) { \\ DAKKU_ERR(__VA_ARGS__); \\ std::exit(-1); \\ } \\ } while (0) #else #define DAKKU_CHECK(...) static_cast<void>(0) #endif } // namespace dakku #endif Updated on 2022-04-07 at 06:53:17 +0000","title":"src/core/logger.h"},{"location":"Files/logger_8h/#srccoreloggerh","text":"","title":"src/core/logger.h"},{"location":"Files/logger_8h/#namespaces","text":"Name dakku dakku namespace","title":"Namespaces"},{"location":"Files/logger_8h/#classes","text":"Name class dakku::Logger logger class","title":"Classes"},{"location":"Files/logger_8h/#defines","text":"Name DAKKU_ERR (...) log error message DAKKU_INFO (...) log info message DAKKU_WARN (...) log warning message DAKKU_DEBUG (...) log debug message DAKKU_CHECK (...) check whether the condition val is true, if not log error messages","title":"Defines"},{"location":"Files/logger_8h/#macros-documentation","text":"","title":"Macros Documentation"},{"location":"Files/logger_8h/#define-dakku_err","text":"#define DAKKU_ERR( ... ) SPDLOG_LOGGER_CALL ( Logger :: get (). handle (), spdlog :: level :: err , __VA_ARGS__ ) log error message","title":"define DAKKU_ERR"},{"location":"Files/logger_8h/#define-dakku_info","text":"#define DAKKU_INFO( ... ) SPDLOG_LOGGER_CALL ( Logger :: get (). handle (), spdlog :: level :: info , __VA_ARGS__ ) log info message","title":"define DAKKU_INFO"},{"location":"Files/logger_8h/#define-dakku_warn","text":"#define DAKKU_WARN( ... ) SPDLOG_LOGGER_CALL ( Logger :: get (). handle (), spdlog :: level :: warn , __VA_ARGS__ ) log warning message","title":"define DAKKU_WARN"},{"location":"Files/logger_8h/#define-dakku_debug","text":"#define DAKKU_DEBUG( ... ) static_cast < void > ( 0 ) log debug message","title":"define DAKKU_DEBUG"},{"location":"Files/logger_8h/#define-dakku_check","text":"#define DAKKU_CHECK( ... ) static_cast < void > ( 0 ) check whether the condition val is true, if not log error messages","title":"define DAKKU_CHECK"},{"location":"Files/logger_8h/#source-code","text":"#ifndef DAKKU_CORE_LOGGER_H_ #define DAKKU_CORE_LOGGER_H_ #include <core/fwd.h> #include <spdlog/spdlog.h> #include <spdlog/fmt/ostr.h> #include <cstdlib> namespace dakku { class DAKKU_EXPORT_CORE Logger { public : static const Logger & get (); [[ nodiscard ]] spdlog :: logger * handle () const { return _logger . get (); } private : explicit Logger ( std :: shared_ptr < spdlog :: logger > _logger ); std :: shared_ptr < spdlog :: logger > _logger ; }; #define DAKKU_ERR(...) \\ SPDLOG_LOGGER_CALL(Logger::get().handle(), spdlog::level::err, __VA_ARGS__) #define DAKKU_INFO(...) \\ SPDLOG_LOGGER_CALL(Logger::get().handle(), spdlog::level::info, __VA_ARGS__) #define DAKKU_WARN(...) \\ SPDLOG_LOGGER_CALL(Logger::get().handle(), spdlog::level::warn, __VA_ARGS__) #ifdef DAKKU_BUILD_DEBUG #define DAKKU_DEBUG(...) \\ SPDLOG_LOGGER_CALL(Logger::get().handle(), spdlog::level::debug, __VA_ARGS__) #else #define DAKKU_DEBUG(...) static_cast<void>(0) #endif #ifdef DAKKU_BUILD_CHECK #define DAKKU_CHECK(val, ...) \\ do { \\ if (!(val)) { \\ DAKKU_ERR(__VA_ARGS__); \\ std::exit(-1); \\ } \\ } while (0) #else #define DAKKU_CHECK(...) static_cast<void>(0) #endif } // namespace dakku #endif Updated on 2022-04-07 at 06:53:17 +0000","title":"Source code"},{"location":"Files/platform_8h/","text":"src/platform.h Namespaces Name dakku dakku namespace Defines Name DAKKU_INLINE DAKKU_EXPORT DAKKU_IMPORT DAKKU_CORE_MODULE dakku logger module DAKKU_MAIN_MODULE dakku main module Macros Documentation define DAKKU_INLINE #define DAKKU_INLINE __attribute__((always_inline)) inline define DAKKU_EXPORT #define DAKKU_EXPORT __attribute__((visibility(\"default\"))) define DAKKU_IMPORT #define DAKKU_IMPORT define DAKKU_CORE_MODULE #define DAKKU_CORE_MODULE 1 dakku logger module define DAKKU_MAIN_MODULE #define DAKKU_MAIN_MODULE 10 dakku main module Source code #ifndef DAKKU_PLATFORM_H_ #define DAKKU_PLATFORM_H_ #if defined(_MSC_VER) #if !defined(_USE_MATH_DEFINES) #define _USE_MATH_DEFINES #endif #endif namespace dakku { #if defined(_MSC_VER) #define DAKKU_INLINE __forceinline #define DAKKU_EXPORT __declspec(dllexport) #define DAKKU_IMPORT __declspec(dllimport) #else #define DAKKU_INLINE __attribute__((always_inline)) inline #define DAKKU_EXPORT __attribute__((visibility(\"default\"))) #define DAKKU_IMPORT #endif #define DAKKU_CORE_MODULE 1 #define DAKKU_MAIN_MODULE 10 } // namespace dakku #endif Updated on 2022-04-07 at 06:53:17 +0000","title":"src/platform.h"},{"location":"Files/platform_8h/#srcplatformh","text":"","title":"src/platform.h"},{"location":"Files/platform_8h/#namespaces","text":"Name dakku dakku namespace","title":"Namespaces"},{"location":"Files/platform_8h/#defines","text":"Name DAKKU_INLINE DAKKU_EXPORT DAKKU_IMPORT DAKKU_CORE_MODULE dakku logger module DAKKU_MAIN_MODULE dakku main module","title":"Defines"},{"location":"Files/platform_8h/#macros-documentation","text":"","title":"Macros Documentation"},{"location":"Files/platform_8h/#define-dakku_inline","text":"#define DAKKU_INLINE __attribute__((always_inline)) inline","title":"define DAKKU_INLINE"},{"location":"Files/platform_8h/#define-dakku_export","text":"#define DAKKU_EXPORT __attribute__((visibility(\"default\")))","title":"define DAKKU_EXPORT"},{"location":"Files/platform_8h/#define-dakku_import","text":"#define DAKKU_IMPORT","title":"define DAKKU_IMPORT"},{"location":"Files/platform_8h/#define-dakku_core_module","text":"#define DAKKU_CORE_MODULE 1 dakku logger module","title":"define DAKKU_CORE_MODULE"},{"location":"Files/platform_8h/#define-dakku_main_module","text":"#define DAKKU_MAIN_MODULE 10 dakku main module","title":"define DAKKU_MAIN_MODULE"},{"location":"Files/platform_8h/#source-code","text":"#ifndef DAKKU_PLATFORM_H_ #define DAKKU_PLATFORM_H_ #if defined(_MSC_VER) #if !defined(_USE_MATH_DEFINES) #define _USE_MATH_DEFINES #endif #endif namespace dakku { #if defined(_MSC_VER) #define DAKKU_INLINE __forceinline #define DAKKU_EXPORT __declspec(dllexport) #define DAKKU_IMPORT __declspec(dllimport) #else #define DAKKU_INLINE __attribute__((always_inline)) inline #define DAKKU_EXPORT __attribute__((visibility(\"default\"))) #define DAKKU_IMPORT #endif #define DAKKU_CORE_MODULE 1 #define DAKKU_MAIN_MODULE 10 } // namespace dakku #endif Updated on 2022-04-07 at 06:53:17 +0000","title":"Source code"},{"location":"Files/property_8h/","text":"src/core/property.h Namespaces Name dakku dakku namespace Classes Name class dakku::Property property class, containing many data types, similar to json Source code #ifndef DAKKU_CORE_PROPERTY_H_ #define DAKKU_CORE_PROPERTY_H_ #include <core/vector.h> #include <map> #include <string> #include <variant> namespace dakku { enum class PropertyType { NONE , ARRAY , OBJECT , NUMBER , VECTOR }; class DAKKU_EXPORT_CORE Property { public : using ObjectType = std :: map < std :: string , Property , std :: less <>> ; using ArrayType = std :: vector < Property > ; using NumberType = float ; using VectorType = std :: vector < float > ; Property () = default ; template < ArithmeticType T > Property ( const T & v ) : data ( static_cast < float > ( v )), type ( PropertyType :: NUMBER ) {} template < ArithmeticType T , size_t S , typename D > Property ( const VectorBase < T , S , D > & v ) : data ( v . toFloatVector ()), type ( PropertyType :: VECTOR ) {} [[ nodiscard ]] decltype ( auto ) getPropertyType () const { return type ; } template < PropertyType type > [[ nodiscard ]] decltype ( auto ) get () { if constexpr ( type == PropertyType :: OBJECT ) { return std :: get < ObjectType > ( data ); } else if constexpr ( type == PropertyType :: ARRAY ) { return std :: get < ArrayType > ( data ); } else if constexpr ( type == PropertyType :: NUMBER ) { return std :: get < NumberType > ( data ); } else if constexpr ( type == PropertyType :: VECTOR ) { return std :: get < VectorType > ( data ); } else { if constexpr ( type == PropertyType :: NONE ) { DAKKU_WARN ( \"none property type\" ); } else { DAKKU_WARN ( \"invalid property type: {}\" , type ); } return nullptr ; } } [[ nodiscard ]] decltype ( auto ) getObject () { return get < PropertyType :: OBJECT > (); } [[ nodiscard ]] decltype ( auto ) getArray () { return get < PropertyType :: ARRAY > (); } [[ nodiscard ]] decltype ( auto ) getNumber () { return get < PropertyType :: NUMBER > (); } [[ nodiscard ]] decltype ( auto ) getVector () { return get < PropertyType :: VECTOR > (); } [[ nodiscard ]] bool isObjectType () const { return type == PropertyType :: OBJECT ; } [[ nodiscard ]] bool isArrayType () const { return type == PropertyType :: ARRAY ; } [[ nodiscard ]] bool isNumberType () const { return type == PropertyType :: NUMBER ; } [[ nodiscard ]] bool isVectorType () const { return type == PropertyType :: VECTOR ; } decltype ( auto ) operator []( const std :: string & key ) { if ( type == PropertyType :: NONE ) [[ unlikely ]] { data = ObjectType {}; type = PropertyType :: OBJECT ; } DAKKU_CHECK ( isObjectType (), \"looking up {} in a non-object property\" , key ); return getObject ()[ key ]; } decltype ( auto ) operator []( size_t i ) { if ( type == PropertyType :: NONE ) [[ unlikely ]] { data = ArrayType {}; type = PropertyType :: ARRAY ; getArray (). reserve (( i + 1 ) * 2 ); } DAKKU_CHECK ( isArrayType (), \"index {} in a non-array property\" , i ); auto & arr = getArray (); if ( i >= arr . size ()) { arr . reserve (( i + 1 ) * 2 ); arr . resize ( i + 1 ); } return getArray ()[ i ]; } [[ nodiscard ]] std :: string toString () const ; friend std :: ostream & operator << ( std :: ostream & os , const Property & property ) { return os << property . toString (); } private : std :: variant < ObjectType , ArrayType , NumberType , VectorType > data ; PropertyType type { PropertyType :: NONE }; }; } // namespace dakku #endif Updated on 2022-04-07 at 06:53:17 +0000","title":"src/core/property.h"},{"location":"Files/property_8h/#srccorepropertyh","text":"","title":"src/core/property.h"},{"location":"Files/property_8h/#namespaces","text":"Name dakku dakku namespace","title":"Namespaces"},{"location":"Files/property_8h/#classes","text":"Name class dakku::Property property class, containing many data types, similar to json","title":"Classes"},{"location":"Files/property_8h/#source-code","text":"#ifndef DAKKU_CORE_PROPERTY_H_ #define DAKKU_CORE_PROPERTY_H_ #include <core/vector.h> #include <map> #include <string> #include <variant> namespace dakku { enum class PropertyType { NONE , ARRAY , OBJECT , NUMBER , VECTOR }; class DAKKU_EXPORT_CORE Property { public : using ObjectType = std :: map < std :: string , Property , std :: less <>> ; using ArrayType = std :: vector < Property > ; using NumberType = float ; using VectorType = std :: vector < float > ; Property () = default ; template < ArithmeticType T > Property ( const T & v ) : data ( static_cast < float > ( v )), type ( PropertyType :: NUMBER ) {} template < ArithmeticType T , size_t S , typename D > Property ( const VectorBase < T , S , D > & v ) : data ( v . toFloatVector ()), type ( PropertyType :: VECTOR ) {} [[ nodiscard ]] decltype ( auto ) getPropertyType () const { return type ; } template < PropertyType type > [[ nodiscard ]] decltype ( auto ) get () { if constexpr ( type == PropertyType :: OBJECT ) { return std :: get < ObjectType > ( data ); } else if constexpr ( type == PropertyType :: ARRAY ) { return std :: get < ArrayType > ( data ); } else if constexpr ( type == PropertyType :: NUMBER ) { return std :: get < NumberType > ( data ); } else if constexpr ( type == PropertyType :: VECTOR ) { return std :: get < VectorType > ( data ); } else { if constexpr ( type == PropertyType :: NONE ) { DAKKU_WARN ( \"none property type\" ); } else { DAKKU_WARN ( \"invalid property type: {}\" , type ); } return nullptr ; } } [[ nodiscard ]] decltype ( auto ) getObject () { return get < PropertyType :: OBJECT > (); } [[ nodiscard ]] decltype ( auto ) getArray () { return get < PropertyType :: ARRAY > (); } [[ nodiscard ]] decltype ( auto ) getNumber () { return get < PropertyType :: NUMBER > (); } [[ nodiscard ]] decltype ( auto ) getVector () { return get < PropertyType :: VECTOR > (); } [[ nodiscard ]] bool isObjectType () const { return type == PropertyType :: OBJECT ; } [[ nodiscard ]] bool isArrayType () const { return type == PropertyType :: ARRAY ; } [[ nodiscard ]] bool isNumberType () const { return type == PropertyType :: NUMBER ; } [[ nodiscard ]] bool isVectorType () const { return type == PropertyType :: VECTOR ; } decltype ( auto ) operator []( const std :: string & key ) { if ( type == PropertyType :: NONE ) [[ unlikely ]] { data = ObjectType {}; type = PropertyType :: OBJECT ; } DAKKU_CHECK ( isObjectType (), \"looking up {} in a non-object property\" , key ); return getObject ()[ key ]; } decltype ( auto ) operator []( size_t i ) { if ( type == PropertyType :: NONE ) [[ unlikely ]] { data = ArrayType {}; type = PropertyType :: ARRAY ; getArray (). reserve (( i + 1 ) * 2 ); } DAKKU_CHECK ( isArrayType (), \"index {} in a non-array property\" , i ); auto & arr = getArray (); if ( i >= arr . size ()) { arr . reserve (( i + 1 ) * 2 ); arr . resize ( i + 1 ); } return getArray ()[ i ]; } [[ nodiscard ]] std :: string toString () const ; friend std :: ostream & operator << ( std :: ostream & os , const Property & property ) { return os << property . toString (); } private : std :: variant < ObjectType , ArrayType , NumberType , VectorType > data ; PropertyType type { PropertyType :: NONE }; }; } // namespace dakku #endif Updated on 2022-04-07 at 06:53:17 +0000","title":"Source code"},{"location":"Files/transform_8h/","text":"src/core/transform.h Namespaces Name dakku dakku namespace Classes Name struct dakku::Matrix4x4 4x4 matrix Source code #ifndef DAKKU_CORE_TRANSFORM_H_ #define DAKKU_CORE_TRANSFORM_H_ #include <core/vector.h> namespace dakku { struct Matrix4x4 { Matrix4x4 () { setIdentity (); } Matrix4x4 ( float t00 , float t01 , float t02 , float t03 , float t10 , float t11 , float t12 , float t13 , float t20 , float t21 , float t22 , float t23 , float t30 , float t31 , float t32 , float t33 ) { m [ 0 ][ 0 ] = t00 ; m [ 0 ][ 1 ] = t01 ; m [ 0 ][ 2 ] = t02 ; m [ 0 ][ 3 ] = t03 ; m [ 1 ][ 0 ] = t10 ; m [ 1 ][ 1 ] = t11 ; m [ 1 ][ 2 ] = t12 ; m [ 1 ][ 3 ] = t13 ; m [ 2 ][ 0 ] = t20 ; m [ 2 ][ 1 ] = t21 ; m [ 2 ][ 2 ] = t22 ; m [ 2 ][ 3 ] = t23 ; m [ 3 ][ 0 ] = t30 ; m [ 3 ][ 1 ] = t31 ; m [ 3 ][ 2 ] = t32 ; m [ 3 ][ 3 ] = t33 ; } friend Matrix4x4 transpose ( const Matrix4x4 & m ); decltype ( auto ) operator []( size_t i ) const { return m [ i ]; } decltype ( auto ) operator []( size_t i ) { return m [ i ]; } void setIdentity () { m [ 0 ][ 1 ] = m [ 0 ][ 2 ] = m [ 0 ][ 3 ] = m [ 1 ][ 0 ] = m [ 1 ][ 2 ] = m [ 1 ][ 3 ] = m [ 2 ][ 0 ] = m [ 2 ][ 1 ] = m [ 2 ][ 3 ] = m [ 3 ][ 0 ] = m [ 3 ][ 1 ] = m [ 3 ][ 2 ] = 0 ; m [ 0 ][ 0 ] = m [ 1 ][ 1 ] = m [ 2 ][ 2 ] = m [ 3 ][ 3 ] = 1 ; } std :: array < std :: array < float , 4 > , 4 > m ; }; } // namespace dakku #endif Updated on 2022-04-07 at 06:53:17 +0000","title":"src/core/transform.h"},{"location":"Files/transform_8h/#srccoretransformh","text":"","title":"src/core/transform.h"},{"location":"Files/transform_8h/#namespaces","text":"Name dakku dakku namespace","title":"Namespaces"},{"location":"Files/transform_8h/#classes","text":"Name struct dakku::Matrix4x4 4x4 matrix","title":"Classes"},{"location":"Files/transform_8h/#source-code","text":"#ifndef DAKKU_CORE_TRANSFORM_H_ #define DAKKU_CORE_TRANSFORM_H_ #include <core/vector.h> namespace dakku { struct Matrix4x4 { Matrix4x4 () { setIdentity (); } Matrix4x4 ( float t00 , float t01 , float t02 , float t03 , float t10 , float t11 , float t12 , float t13 , float t20 , float t21 , float t22 , float t23 , float t30 , float t31 , float t32 , float t33 ) { m [ 0 ][ 0 ] = t00 ; m [ 0 ][ 1 ] = t01 ; m [ 0 ][ 2 ] = t02 ; m [ 0 ][ 3 ] = t03 ; m [ 1 ][ 0 ] = t10 ; m [ 1 ][ 1 ] = t11 ; m [ 1 ][ 2 ] = t12 ; m [ 1 ][ 3 ] = t13 ; m [ 2 ][ 0 ] = t20 ; m [ 2 ][ 1 ] = t21 ; m [ 2 ][ 2 ] = t22 ; m [ 2 ][ 3 ] = t23 ; m [ 3 ][ 0 ] = t30 ; m [ 3 ][ 1 ] = t31 ; m [ 3 ][ 2 ] = t32 ; m [ 3 ][ 3 ] = t33 ; } friend Matrix4x4 transpose ( const Matrix4x4 & m ); decltype ( auto ) operator []( size_t i ) const { return m [ i ]; } decltype ( auto ) operator []( size_t i ) { return m [ i ]; } void setIdentity () { m [ 0 ][ 1 ] = m [ 0 ][ 2 ] = m [ 0 ][ 3 ] = m [ 1 ][ 0 ] = m [ 1 ][ 2 ] = m [ 1 ][ 3 ] = m [ 2 ][ 0 ] = m [ 2 ][ 1 ] = m [ 2 ][ 3 ] = m [ 3 ][ 0 ] = m [ 3 ][ 1 ] = m [ 3 ][ 2 ] = 0 ; m [ 0 ][ 0 ] = m [ 1 ][ 1 ] = m [ 2 ][ 2 ] = m [ 3 ][ 3 ] = 1 ; } std :: array < std :: array < float , 4 > , 4 > m ; }; } // namespace dakku #endif Updated on 2022-04-07 at 06:53:17 +0000","title":"Source code"},{"location":"Files/vector_8h/","text":"src/core/vector.h Namespaces Name dakku dakku namespace Classes Name class dakku::Vector vector class dakku::Point point class dakku::Normal normal Source code #ifndef DAKKU_CORE_VECTOR_H_ #define DAKKU_CORE_VECTOR_H_ #include <core/vector_base.h> namespace dakku { template < ArithmeticType T , size_t S > class Vector : public VectorBase < T , S , Vector < T , S >> { public : using VectorBase < T , S , Vector < T , S >>:: VectorBase ; friend Vector operator - ( const Vector & a , const Vector & b ) { Vector ret = a ; ret -= b ; return ret ; } }; template < ArithmeticType T , size_t S > class Point : public VectorBase < T , S , Point < T , S >> { public : using VectorBase < T , S , Point < T , S >>:: VectorBase ; friend Vector < T , S > operator - ( const Point & a , const Point & b ) { return Vector < T , S > ( a ) - Vector < T , S > ( b ); } friend Point operator - ( const Point & a , const Vector < T , S > & b ) { return a - Point ( b ); } friend Point operator + ( const Point & a , const Vector < T , S > & b ) { return a + Point ( b ); } }; template < ArithmeticType T , size_t S > class Normal : public VectorBase < T , S , Normal < T , S >> { public : using VectorBase < T , S , Normal < T , S >>:: VectorBase ; friend Normal operator - ( const Normal & a , const Normal & b ) { Normal ret = a ; ret -= b ; return ret ; } }; template < ArithmeticType T > using Vector2 = Vector < T , 2 > ; template < ArithmeticType T > using Vector3 = Vector < T , 3 > ; using Vector2f = Vector2 < float > ; using Vector3f = Vector3 < float > ; template < ArithmeticType T > using Point2 = Point < T , 2 > ; template < ArithmeticType T > using Point3 = Point < T , 3 > ; using Point2f = Point2 < float > ; using Point2i = Point2 < int > ; using Point3f = Point3 < float > ; template < ArithmeticType T > using Normal3 = Normal < T , 3 > ; using Normal3f = Normal3 < float > ; } // namespace dakku #endif Updated on 2022-04-07 at 06:53:17 +0000","title":"src/core/vector.h"},{"location":"Files/vector_8h/#srccorevectorh","text":"","title":"src/core/vector.h"},{"location":"Files/vector_8h/#namespaces","text":"Name dakku dakku namespace","title":"Namespaces"},{"location":"Files/vector_8h/#classes","text":"Name class dakku::Vector vector class dakku::Point point class dakku::Normal normal","title":"Classes"},{"location":"Files/vector_8h/#source-code","text":"#ifndef DAKKU_CORE_VECTOR_H_ #define DAKKU_CORE_VECTOR_H_ #include <core/vector_base.h> namespace dakku { template < ArithmeticType T , size_t S > class Vector : public VectorBase < T , S , Vector < T , S >> { public : using VectorBase < T , S , Vector < T , S >>:: VectorBase ; friend Vector operator - ( const Vector & a , const Vector & b ) { Vector ret = a ; ret -= b ; return ret ; } }; template < ArithmeticType T , size_t S > class Point : public VectorBase < T , S , Point < T , S >> { public : using VectorBase < T , S , Point < T , S >>:: VectorBase ; friend Vector < T , S > operator - ( const Point & a , const Point & b ) { return Vector < T , S > ( a ) - Vector < T , S > ( b ); } friend Point operator - ( const Point & a , const Vector < T , S > & b ) { return a - Point ( b ); } friend Point operator + ( const Point & a , const Vector < T , S > & b ) { return a + Point ( b ); } }; template < ArithmeticType T , size_t S > class Normal : public VectorBase < T , S , Normal < T , S >> { public : using VectorBase < T , S , Normal < T , S >>:: VectorBase ; friend Normal operator - ( const Normal & a , const Normal & b ) { Normal ret = a ; ret -= b ; return ret ; } }; template < ArithmeticType T > using Vector2 = Vector < T , 2 > ; template < ArithmeticType T > using Vector3 = Vector < T , 3 > ; using Vector2f = Vector2 < float > ; using Vector3f = Vector3 < float > ; template < ArithmeticType T > using Point2 = Point < T , 2 > ; template < ArithmeticType T > using Point3 = Point < T , 3 > ; using Point2f = Point2 < float > ; using Point2i = Point2 < int > ; using Point3f = Point3 < float > ; template < ArithmeticType T > using Normal3 = Normal < T , 3 > ; using Normal3f = Normal3 < float > ; } // namespace dakku #endif Updated on 2022-04-07 at 06:53:17 +0000","title":"Source code"},{"location":"Files/vector__base_8h/","text":"src/core/vector_base.h Namespaces Name dakku dakku namespace Classes Name class dakku::VectorBase vector base class Source code #ifndef DAKKU_CORE_VECTOR_BASE_H_ #define DAKKU_CORE_VECTOR_BASE_H_ #include <core/logger.h> #include <array> #include <algorithm> #include <string> #include <ostream> #include <numeric> namespace dakku { template < ArithmeticType T , size_t S , typename Derived > class VectorBase { public : explicit VectorBase () : _data () {} template < ArithmeticType Arg > VectorBase ( Arg value ) { set ( value ); DAKKU_CHECK ( ! hasNaNs (), \"has nan\" ); } template < ArithmeticType Other , typename OtherDerived > explicit VectorBase ( const VectorBase < Other , S , OtherDerived > & other ) { set ( other ); DAKKU_CHECK ( ! hasNaNs (), \"has nan\" ); } VectorBase ( const VectorBase & other ) : _data ( other . _data ) { DAKKU_CHECK ( ! hasNaNs (), \"has nan\" ); } VectorBase ( VectorBase && other ) noexcept : _data ( std :: move ( other . _data )) { DAKKU_CHECK ( ! hasNaNs (), \"has nan\" ); } VectorBase & operator = ( const VectorBase & other ) { if ( this == & other ) return * this ; _data = other . _data ; DAKKU_CHECK ( ! hasNaNs (), \"has nan\" ); return * this ; } VectorBase & operator = ( VectorBase && other ) noexcept { if ( this == & other ) return * this ; _data = std :: move ( other . _data ); DAKKU_CHECK ( ! hasNaNs (), \"has nan\" ); return * this ; } template < ArithmeticType ... Args > requires ( sizeof ...( Args ) == S ) VectorBase ( Args && ... args ) { set ( std :: forward < Args > ( args )...); } template < ArithmeticType Arg > void set ( Arg value ) { _data . fill ( static_cast < T > ( value )); } template < ArithmeticType Arg > void setByIndex ( size_t index , Arg value ) { DAKKU_CHECK ( 0 <= index && index < S , \"index out of range: {} >= {}\" , index , S ); _data [ index ] = static_cast < T > ( value ); } template < ArithmeticType ... Args , size_t ... Is > requires ( sizeof ...( Args ) == S ) void set ( std :: index_sequence < Is ... > , Args && ... args ) { ( setByIndex ( Is , std :: forward < Args > ( args )), ...); } template < ArithmeticType ... Args > requires ( sizeof ...( Args ) == S ) void set ( Args && ... args ) { set ( std :: index_sequence_for < Args ... > {}, std :: forward < Args > ( args )...); } template < ArithmeticType Other , typename OtherDerived > void set ( const VectorBase < Other , S , OtherDerived > & rhs ) { for ( size_t i = 0 ; i < S ; ++ i ) _data [ i ] = static_cast < T > ( rhs [ i ]); } [[ nodiscard ]] bool hasNaNs () const { return std :: any_of ( std :: begin ( _data ), std :: end ( _data ), []( T x ) { return isNaN ( x ); }); } const T & get ( size_t i ) const { return _data [ i ]; } [[ nodiscard ]] std :: string toString () const { std :: string ret { \"[\" }; for ( size_t i = 0 ; i < _data . size (); ++ i ) { ret += std :: to_string ( _data [ i ]); if ( i + 1 != _data . size ()) ret += \", \" ; } return ret + \"]\" ; } friend std :: ostream & operator << ( std :: ostream & os , const VectorBase & vec ) { return os << vec . toString (); } [[ nodiscard ]] size_t size () const { return S ; } const T & operator []( size_t i ) const { return _data [ i ]; } T & operator []( size_t i ) { return const_cast < T &> ( static_cast < const VectorBase &> ( * this )[ i ]); } Derived operator - () const { Derived ret = derived (); for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = - ret [ i ]; return ret ; } const Derived & derived () const { return static_cast < const Derived &> ( * this ); } Derived & derived () { return const_cast < Derived &> ( static_cast < const VectorBase &> ( * this ). derived ()); } Derived & operator += ( const Derived & rhs ) { for ( size_t i = 0 ; i < S ; ++ i ) _data [ i ] += rhs [ i ]; return derived (); } template < ArithmeticType V > Derived & operator += ( const V & rhs ) { for ( size_t i = 0 ; i < S ; ++ i ) _data [ i ] += rhs ; return derived (); } friend Derived operator + ( const Derived & a , const Derived & b ) { Derived ret = a ; ret += b ; return ret ; } template < ArithmeticType U > friend Derived operator + ( const Derived & a , const U & b ) { Derived ret = a ; ret += b ; return ret ; } template < ArithmeticType U > friend Derived operator + ( const U & a , const Derived & b ) { return b + a ; } Derived & operator -= ( const Derived & rhs ) { for ( size_t i = 0 ; i < S ; ++ i ) _data [ i ] -= rhs [ i ]; return derived (); } template < ArithmeticType V > Derived & operator -= ( const V & rhs ) { for ( size_t i = 0 ; i < S ; ++ i ) _data [ i ] -= rhs ; return derived (); } template < ArithmeticType U > friend Derived operator - ( const Derived & a , const U & b ) { Derived ret = a ; ret -= b ; return ret ; } template < ArithmeticType U > friend Derived operator - ( const U & a , const Derived & b ) { Derived ret = - b ; ret += a ; return ret ; } Derived & operator *= ( const Derived & rhs ) { for ( size_t i = 0 ; i < S ; ++ i ) _data [ i ] *= rhs [ i ]; return derived (); } template < ArithmeticType V > Derived & operator *= ( const V & rhs ) { for ( size_t i = 0 ; i < S ; ++ i ) _data [ i ] *= rhs ; return derived (); } friend Derived operator * ( const Derived & a , const Derived & b ) { Derived ret = a ; ret *= b ; return ret ; } template < ArithmeticType U > friend Derived operator * ( const Derived & a , const U & b ) { Derived ret = a ; ret *= b ; return ret ; } template < ArithmeticType U > friend Derived operator * ( const U & a , const Derived & b ) { return b * a ; } Derived & operator /= ( const Derived & rhs ) { for ( size_t i = 0 ; i < S ; ++ i ) _data [ i ] /= rhs [ i ]; return derived (); } template < ArithmeticType V > Derived & operator /= ( const V & rhs ) { return derived () *= static_cast < T > ( T { 1 } / rhs ); } friend Derived operator / ( const Derived & a , const Derived & b ) { Derived ret = a ; ret /= b ; return ret ; } template < ArithmeticType U > friend Derived operator / ( const Derived & a , const U & b ) { Derived ret = a ; ret /= b ; return ret ; } template < ArithmeticType U > friend Derived operator / ( const U & a , const Derived & b ) { return Derived ( a ) / b ; } [[ nodiscard ]] std :: vector < float > toFloatVector () const { std :: vector < float > ret ( S ); for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = static_cast < float > ( _data [ i ]); return ret ; } VectorBase ( const std :: vector < float > & v ) { DAKKU_CHECK ( v . size () == S , \"invalid vector size: {}, expected: {}\" , v . size (), S ); for ( size_t i = 0 ; i < S ; ++ i ) _data [ i ] = v [ i ]; } decltype ( auto ) x () const { static_assert ( S >= 1 , \"not enough size to get x\" ); return _data [ 0 ]; } decltype ( auto ) x () { static_assert ( S >= 1 , \"not enough size to get x\" ); return _data [ 0 ]; } decltype ( auto ) y () const { static_assert ( S >= 2 , \"not enough size to get y\" ); return _data [ 1 ]; } decltype ( auto ) y () { static_assert ( S >= 2 , \"not enough size to get y\" ); return _data [ 1 ]; } decltype ( auto ) z () const { static_assert ( S >= 3 , \"not enough size to get z\" ); return _data [ 2 ]; } decltype ( auto ) z () { static_assert ( S >= 4 , \"not enough size to get w\" ); return _data [ 3 ]; } decltype ( auto ) w () const { static_assert ( S >= 4 , \"not enough size to get w\" ); return _data [ 3 ]; } decltype ( auto ) w () { static_assert ( S >= 3 , \"not enough size to get z\" ); return _data [ 2 ]; } [[ nodiscard ]] size_t maxElementIndex () const { return std :: distance ( begin (), std :: max_element ( begin (), end ())); } decltype ( auto ) maxElement () const { return _data [ maxElementIndex ()]; } decltype ( auto ) begin () { return _data . begin (); } decltype ( auto ) begin () const { return _data . begin (); } decltype ( auto ) end () { return _data . end (); } decltype ( auto ) end () const { return _data . end (); } friend bool operator == ( const Derived & a , const Derived & b ) { return a . _data == b . _data ; } friend bool operator != ( const Derived & a , const Derived & b ) { return a . _data != b . _data ; } friend Derived max ( const Derived & a , const Derived & b ) { Derived ret = a ; for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = std :: max ( ret [ i ], b [ i ]); return ret ; } friend Derived min ( const Derived & a , const Derived & b ) { Derived ret = a ; for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = std :: min ( ret [ i ], b [ i ]); return ret ; } template < typename OtherDerived > decltype ( auto ) dot ( const VectorBase < T , S , OtherDerived > & rhs ) const { return std :: inner_product ( begin (), end (), rhs . begin (), T {}); } decltype ( auto ) squaredNorm () const { return this -> dot ( * this ); } decltype ( auto ) norm () const { return std :: sqrt ( squaredNorm ()); } decltype ( auto ) length () const { return norm (); } friend decltype ( auto ) distance ( const Derived & a , const Derived & b ) { return ( a - b ). length (); } protected : std :: array < T , S > _data ; }; template < ArithmeticType T , size_t S , typename D1 , typename D2 > inline decltype ( auto ) dot ( const VectorBase < T , S , D1 > & a , const VectorBase < T , S , D2 > & b ) { return a . dot ( b ); } } // namespace dakku #endif Updated on 2022-04-07 at 06:53:17 +0000","title":"src/core/vector_base.h"},{"location":"Files/vector__base_8h/#srccorevector_baseh","text":"","title":"src/core/vector_base.h"},{"location":"Files/vector__base_8h/#namespaces","text":"Name dakku dakku namespace","title":"Namespaces"},{"location":"Files/vector__base_8h/#classes","text":"Name class dakku::VectorBase vector base class","title":"Classes"},{"location":"Files/vector__base_8h/#source-code","text":"#ifndef DAKKU_CORE_VECTOR_BASE_H_ #define DAKKU_CORE_VECTOR_BASE_H_ #include <core/logger.h> #include <array> #include <algorithm> #include <string> #include <ostream> #include <numeric> namespace dakku { template < ArithmeticType T , size_t S , typename Derived > class VectorBase { public : explicit VectorBase () : _data () {} template < ArithmeticType Arg > VectorBase ( Arg value ) { set ( value ); DAKKU_CHECK ( ! hasNaNs (), \"has nan\" ); } template < ArithmeticType Other , typename OtherDerived > explicit VectorBase ( const VectorBase < Other , S , OtherDerived > & other ) { set ( other ); DAKKU_CHECK ( ! hasNaNs (), \"has nan\" ); } VectorBase ( const VectorBase & other ) : _data ( other . _data ) { DAKKU_CHECK ( ! hasNaNs (), \"has nan\" ); } VectorBase ( VectorBase && other ) noexcept : _data ( std :: move ( other . _data )) { DAKKU_CHECK ( ! hasNaNs (), \"has nan\" ); } VectorBase & operator = ( const VectorBase & other ) { if ( this == & other ) return * this ; _data = other . _data ; DAKKU_CHECK ( ! hasNaNs (), \"has nan\" ); return * this ; } VectorBase & operator = ( VectorBase && other ) noexcept { if ( this == & other ) return * this ; _data = std :: move ( other . _data ); DAKKU_CHECK ( ! hasNaNs (), \"has nan\" ); return * this ; } template < ArithmeticType ... Args > requires ( sizeof ...( Args ) == S ) VectorBase ( Args && ... args ) { set ( std :: forward < Args > ( args )...); } template < ArithmeticType Arg > void set ( Arg value ) { _data . fill ( static_cast < T > ( value )); } template < ArithmeticType Arg > void setByIndex ( size_t index , Arg value ) { DAKKU_CHECK ( 0 <= index && index < S , \"index out of range: {} >= {}\" , index , S ); _data [ index ] = static_cast < T > ( value ); } template < ArithmeticType ... Args , size_t ... Is > requires ( sizeof ...( Args ) == S ) void set ( std :: index_sequence < Is ... > , Args && ... args ) { ( setByIndex ( Is , std :: forward < Args > ( args )), ...); } template < ArithmeticType ... Args > requires ( sizeof ...( Args ) == S ) void set ( Args && ... args ) { set ( std :: index_sequence_for < Args ... > {}, std :: forward < Args > ( args )...); } template < ArithmeticType Other , typename OtherDerived > void set ( const VectorBase < Other , S , OtherDerived > & rhs ) { for ( size_t i = 0 ; i < S ; ++ i ) _data [ i ] = static_cast < T > ( rhs [ i ]); } [[ nodiscard ]] bool hasNaNs () const { return std :: any_of ( std :: begin ( _data ), std :: end ( _data ), []( T x ) { return isNaN ( x ); }); } const T & get ( size_t i ) const { return _data [ i ]; } [[ nodiscard ]] std :: string toString () const { std :: string ret { \"[\" }; for ( size_t i = 0 ; i < _data . size (); ++ i ) { ret += std :: to_string ( _data [ i ]); if ( i + 1 != _data . size ()) ret += \", \" ; } return ret + \"]\" ; } friend std :: ostream & operator << ( std :: ostream & os , const VectorBase & vec ) { return os << vec . toString (); } [[ nodiscard ]] size_t size () const { return S ; } const T & operator []( size_t i ) const { return _data [ i ]; } T & operator []( size_t i ) { return const_cast < T &> ( static_cast < const VectorBase &> ( * this )[ i ]); } Derived operator - () const { Derived ret = derived (); for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = - ret [ i ]; return ret ; } const Derived & derived () const { return static_cast < const Derived &> ( * this ); } Derived & derived () { return const_cast < Derived &> ( static_cast < const VectorBase &> ( * this ). derived ()); } Derived & operator += ( const Derived & rhs ) { for ( size_t i = 0 ; i < S ; ++ i ) _data [ i ] += rhs [ i ]; return derived (); } template < ArithmeticType V > Derived & operator += ( const V & rhs ) { for ( size_t i = 0 ; i < S ; ++ i ) _data [ i ] += rhs ; return derived (); } friend Derived operator + ( const Derived & a , const Derived & b ) { Derived ret = a ; ret += b ; return ret ; } template < ArithmeticType U > friend Derived operator + ( const Derived & a , const U & b ) { Derived ret = a ; ret += b ; return ret ; } template < ArithmeticType U > friend Derived operator + ( const U & a , const Derived & b ) { return b + a ; } Derived & operator -= ( const Derived & rhs ) { for ( size_t i = 0 ; i < S ; ++ i ) _data [ i ] -= rhs [ i ]; return derived (); } template < ArithmeticType V > Derived & operator -= ( const V & rhs ) { for ( size_t i = 0 ; i < S ; ++ i ) _data [ i ] -= rhs ; return derived (); } template < ArithmeticType U > friend Derived operator - ( const Derived & a , const U & b ) { Derived ret = a ; ret -= b ; return ret ; } template < ArithmeticType U > friend Derived operator - ( const U & a , const Derived & b ) { Derived ret = - b ; ret += a ; return ret ; } Derived & operator *= ( const Derived & rhs ) { for ( size_t i = 0 ; i < S ; ++ i ) _data [ i ] *= rhs [ i ]; return derived (); } template < ArithmeticType V > Derived & operator *= ( const V & rhs ) { for ( size_t i = 0 ; i < S ; ++ i ) _data [ i ] *= rhs ; return derived (); } friend Derived operator * ( const Derived & a , const Derived & b ) { Derived ret = a ; ret *= b ; return ret ; } template < ArithmeticType U > friend Derived operator * ( const Derived & a , const U & b ) { Derived ret = a ; ret *= b ; return ret ; } template < ArithmeticType U > friend Derived operator * ( const U & a , const Derived & b ) { return b * a ; } Derived & operator /= ( const Derived & rhs ) { for ( size_t i = 0 ; i < S ; ++ i ) _data [ i ] /= rhs [ i ]; return derived (); } template < ArithmeticType V > Derived & operator /= ( const V & rhs ) { return derived () *= static_cast < T > ( T { 1 } / rhs ); } friend Derived operator / ( const Derived & a , const Derived & b ) { Derived ret = a ; ret /= b ; return ret ; } template < ArithmeticType U > friend Derived operator / ( const Derived & a , const U & b ) { Derived ret = a ; ret /= b ; return ret ; } template < ArithmeticType U > friend Derived operator / ( const U & a , const Derived & b ) { return Derived ( a ) / b ; } [[ nodiscard ]] std :: vector < float > toFloatVector () const { std :: vector < float > ret ( S ); for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = static_cast < float > ( _data [ i ]); return ret ; } VectorBase ( const std :: vector < float > & v ) { DAKKU_CHECK ( v . size () == S , \"invalid vector size: {}, expected: {}\" , v . size (), S ); for ( size_t i = 0 ; i < S ; ++ i ) _data [ i ] = v [ i ]; } decltype ( auto ) x () const { static_assert ( S >= 1 , \"not enough size to get x\" ); return _data [ 0 ]; } decltype ( auto ) x () { static_assert ( S >= 1 , \"not enough size to get x\" ); return _data [ 0 ]; } decltype ( auto ) y () const { static_assert ( S >= 2 , \"not enough size to get y\" ); return _data [ 1 ]; } decltype ( auto ) y () { static_assert ( S >= 2 , \"not enough size to get y\" ); return _data [ 1 ]; } decltype ( auto ) z () const { static_assert ( S >= 3 , \"not enough size to get z\" ); return _data [ 2 ]; } decltype ( auto ) z () { static_assert ( S >= 4 , \"not enough size to get w\" ); return _data [ 3 ]; } decltype ( auto ) w () const { static_assert ( S >= 4 , \"not enough size to get w\" ); return _data [ 3 ]; } decltype ( auto ) w () { static_assert ( S >= 3 , \"not enough size to get z\" ); return _data [ 2 ]; } [[ nodiscard ]] size_t maxElementIndex () const { return std :: distance ( begin (), std :: max_element ( begin (), end ())); } decltype ( auto ) maxElement () const { return _data [ maxElementIndex ()]; } decltype ( auto ) begin () { return _data . begin (); } decltype ( auto ) begin () const { return _data . begin (); } decltype ( auto ) end () { return _data . end (); } decltype ( auto ) end () const { return _data . end (); } friend bool operator == ( const Derived & a , const Derived & b ) { return a . _data == b . _data ; } friend bool operator != ( const Derived & a , const Derived & b ) { return a . _data != b . _data ; } friend Derived max ( const Derived & a , const Derived & b ) { Derived ret = a ; for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = std :: max ( ret [ i ], b [ i ]); return ret ; } friend Derived min ( const Derived & a , const Derived & b ) { Derived ret = a ; for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = std :: min ( ret [ i ], b [ i ]); return ret ; } template < typename OtherDerived > decltype ( auto ) dot ( const VectorBase < T , S , OtherDerived > & rhs ) const { return std :: inner_product ( begin (), end (), rhs . begin (), T {}); } decltype ( auto ) squaredNorm () const { return this -> dot ( * this ); } decltype ( auto ) norm () const { return std :: sqrt ( squaredNorm ()); } decltype ( auto ) length () const { return norm (); } friend decltype ( auto ) distance ( const Derived & a , const Derived & b ) { return ( a - b ). length (); } protected : std :: array < T , S > _data ; }; template < ArithmeticType T , size_t S , typename D1 , typename D2 > inline decltype ( auto ) dot ( const VectorBase < T , S , D1 > & a , const VectorBase < T , S , D2 > & b ) { return a . dot ( b ); } } // namespace dakku #endif Updated on 2022-04-07 at 06:53:17 +0000","title":"Source code"},{"location":"Modules/","text":"Modules Updated on 2022-04-07 at 06:53:17 +0000","title":"Modules"},{"location":"Modules/#modules","text":"Updated on 2022-04-07 at 06:53:17 +0000","title":"Modules"},{"location":"Namespaces/","text":"Namespaces namespace dakku dakku namespace namespace std Updated on 2022-04-07 at 06:53:17 +0000","title":"Namespaces"},{"location":"Namespaces/#namespaces","text":"namespace dakku dakku namespace namespace std Updated on 2022-04-07 at 06:53:17 +0000","title":"Namespaces"},{"location":"Namespaces/namespacedakku/","text":"dakku dakku namespace Classes Name class dakku::Bounds2 2d bounding box class dakku::Bounds2iIterator 2d integer bounds iterator, iterate all pixels inside class dakku::Bounds3 3d bounding box class dakku::BoundsBase bounding box base class dakku::Class RTTI support. class dakku::Logger logger class struct dakku::Matrix4x4 4x4 matrix class dakku::Normal normal class dakku::Point point class dakku::Property property class, containing many data types, similar to json class dakku::Vector vector class dakku::VectorBase vector base class Types Name enum class PropertyType { NONE, ARRAY, OBJECT, NUMBER, VECTOR} property type using Bounds2 < float > Bounds2f using Bounds2 < int > Bounds2i template <ArithmeticType T> using Vector < T, 2 > Vector2 2d vectors template <ArithmeticType T> using Vector < T, 3 > Vector3 3d vectors using Vector2 < float > Vector2f 2d float vector using Vector3 < float > Vector3f 3d float vector template <ArithmeticType T> using Point < T, 2 > Point2 2d point template <ArithmeticType T> using Point < T, 3 > Point3 3d point using Point2 < float > Point2f 2d float point using Point2 < int > Point2i 2d int point using Point3 < float > Point3f 3d float point template <ArithmeticType T> using Normal < T, 3 > Normal3 3d normal using Normal3 < float > Normal3f 3d float normal Functions Name Bounds2iIterator begin (const Bounds2i & b) begin of the bounds2i iteration Bounds2iIterator end (const Bounds2i & b) end of the bounds2i iteration template <typename T > DAKKU_INLINE bool isNaN (T x) check whether x is not a number template <typename T > DAKKU_INLINE bool isNaN (T ) check whether x is not a number template <ArithmeticType T,size_t S,typename D1 ,typename D2 > decltype(auto) dot (const VectorBase < T, S, D1 > & a, const VectorBase < T, S, D2 > & b) dot product between two vectors Attributes Name constexpr float INF infinity Types Documentation enum PropertyType Enumerator Value Description NONE ARRAY OBJECT NUMBER VECTOR property type using Bounds2f using dakku :: Bounds2f = typedef Bounds2 < float > ; using Bounds2i using dakku :: Bounds2i = typedef Bounds2 < int > ; using Vector2 template < ArithmeticType T > using dakku :: Vector2 = typedef Vector < T , 2 > ; 2d vectors Template Parameters : T data type using Vector3 template < ArithmeticType T > using dakku :: Vector3 = typedef Vector < T , 3 > ; 3d vectors Template Parameters : T data type using Vector2f using dakku :: Vector2f = typedef Vector2 < float > ; 2d float vector using Vector3f using dakku :: Vector3f = typedef Vector3 < float > ; 3d float vector using Point2 template < ArithmeticType T > using dakku :: Point2 = typedef Point < T , 2 > ; 2d point Template Parameters : T data type using Point3 template < ArithmeticType T > using dakku :: Point3 = typedef Point < T , 3 > ; 3d point Template Parameters : T data type using Point2f using dakku :: Point2f = typedef Point2 < float > ; 2d float point using Point2i using dakku :: Point2i = typedef Point2 < int > ; 2d int point using Point3f using dakku :: Point3f = typedef Point3 < float > ; 3d float point using Normal3 template < ArithmeticType T > using dakku :: Normal3 = typedef Normal < T , 3 > ; 3d normal Template Parameters : T data type using Normal3f using dakku :: Normal3f = typedef Normal3 < float > ; 3d float normal Functions Documentation function begin inline Bounds2iIterator begin ( const Bounds2i & b ) begin of the bounds2i iteration function end inline Bounds2iIterator end ( const Bounds2i & b ) end of the bounds2i iteration function isNaN template < typename T > DAKKU_INLINE bool isNaN ( T x ) check whether x is not a number Parameters : x given value Template Parameters : T type (floating point) Return : whether x is nan function isNaN template < typename T > DAKKU_INLINE bool isNaN ( T ) check whether x is not a number Template Parameters : T type (integer) Return : false (all integers are not nans) function dot template < ArithmeticType T , size_t S , typename D1 , typename D2 > inline decltype ( auto ) dot ( const VectorBase < T , S , D1 > & a , const VectorBase < T , S , D2 > & b ) dot product between two vectors Parameters : a \\(\\vec a\\) b \\(\\vec b\\) Return : \\(\\vec a \\cdot \\vec b\\) Attributes Documentation variable INF static constexpr float INF = std :: numeric_limits < float >:: infinity (); infinity Updated on 2022-04-07 at 06:53:17 +0000","title":"dakku"},{"location":"Namespaces/namespacedakku/#dakku","text":"dakku namespace","title":"dakku"},{"location":"Namespaces/namespacedakku/#classes","text":"Name class dakku::Bounds2 2d bounding box class dakku::Bounds2iIterator 2d integer bounds iterator, iterate all pixels inside class dakku::Bounds3 3d bounding box class dakku::BoundsBase bounding box base class dakku::Class RTTI support. class dakku::Logger logger class struct dakku::Matrix4x4 4x4 matrix class dakku::Normal normal class dakku::Point point class dakku::Property property class, containing many data types, similar to json class dakku::Vector vector class dakku::VectorBase vector base class","title":"Classes"},{"location":"Namespaces/namespacedakku/#types","text":"Name enum class PropertyType { NONE, ARRAY, OBJECT, NUMBER, VECTOR} property type using Bounds2 < float > Bounds2f using Bounds2 < int > Bounds2i template <ArithmeticType T> using Vector < T, 2 > Vector2 2d vectors template <ArithmeticType T> using Vector < T, 3 > Vector3 3d vectors using Vector2 < float > Vector2f 2d float vector using Vector3 < float > Vector3f 3d float vector template <ArithmeticType T> using Point < T, 2 > Point2 2d point template <ArithmeticType T> using Point < T, 3 > Point3 3d point using Point2 < float > Point2f 2d float point using Point2 < int > Point2i 2d int point using Point3 < float > Point3f 3d float point template <ArithmeticType T> using Normal < T, 3 > Normal3 3d normal using Normal3 < float > Normal3f 3d float normal","title":"Types"},{"location":"Namespaces/namespacedakku/#functions","text":"Name Bounds2iIterator begin (const Bounds2i & b) begin of the bounds2i iteration Bounds2iIterator end (const Bounds2i & b) end of the bounds2i iteration template <typename T > DAKKU_INLINE bool isNaN (T x) check whether x is not a number template <typename T > DAKKU_INLINE bool isNaN (T ) check whether x is not a number template <ArithmeticType T,size_t S,typename D1 ,typename D2 > decltype(auto) dot (const VectorBase < T, S, D1 > & a, const VectorBase < T, S, D2 > & b) dot product between two vectors","title":"Functions"},{"location":"Namespaces/namespacedakku/#attributes","text":"Name constexpr float INF infinity","title":"Attributes"},{"location":"Namespaces/namespacedakku/#types-documentation","text":"","title":"Types Documentation"},{"location":"Namespaces/namespacedakku/#enum-propertytype","text":"Enumerator Value Description NONE ARRAY OBJECT NUMBER VECTOR property type","title":"enum PropertyType"},{"location":"Namespaces/namespacedakku/#using-bounds2f","text":"using dakku :: Bounds2f = typedef Bounds2 < float > ;","title":"using Bounds2f"},{"location":"Namespaces/namespacedakku/#using-bounds2i","text":"using dakku :: Bounds2i = typedef Bounds2 < int > ;","title":"using Bounds2i"},{"location":"Namespaces/namespacedakku/#using-vector2","text":"template < ArithmeticType T > using dakku :: Vector2 = typedef Vector < T , 2 > ; 2d vectors Template Parameters : T data type","title":"using Vector2"},{"location":"Namespaces/namespacedakku/#using-vector3","text":"template < ArithmeticType T > using dakku :: Vector3 = typedef Vector < T , 3 > ; 3d vectors Template Parameters : T data type","title":"using Vector3"},{"location":"Namespaces/namespacedakku/#using-vector2f","text":"using dakku :: Vector2f = typedef Vector2 < float > ; 2d float vector","title":"using Vector2f"},{"location":"Namespaces/namespacedakku/#using-vector3f","text":"using dakku :: Vector3f = typedef Vector3 < float > ; 3d float vector","title":"using Vector3f"},{"location":"Namespaces/namespacedakku/#using-point2","text":"template < ArithmeticType T > using dakku :: Point2 = typedef Point < T , 2 > ; 2d point Template Parameters : T data type","title":"using Point2"},{"location":"Namespaces/namespacedakku/#using-point3","text":"template < ArithmeticType T > using dakku :: Point3 = typedef Point < T , 3 > ; 3d point Template Parameters : T data type","title":"using Point3"},{"location":"Namespaces/namespacedakku/#using-point2f","text":"using dakku :: Point2f = typedef Point2 < float > ; 2d float point","title":"using Point2f"},{"location":"Namespaces/namespacedakku/#using-point2i","text":"using dakku :: Point2i = typedef Point2 < int > ; 2d int point","title":"using Point2i"},{"location":"Namespaces/namespacedakku/#using-point3f","text":"using dakku :: Point3f = typedef Point3 < float > ; 3d float point","title":"using Point3f"},{"location":"Namespaces/namespacedakku/#using-normal3","text":"template < ArithmeticType T > using dakku :: Normal3 = typedef Normal < T , 3 > ; 3d normal Template Parameters : T data type","title":"using Normal3"},{"location":"Namespaces/namespacedakku/#using-normal3f","text":"using dakku :: Normal3f = typedef Normal3 < float > ; 3d float normal","title":"using Normal3f"},{"location":"Namespaces/namespacedakku/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Namespaces/namespacedakku/#function-begin","text":"inline Bounds2iIterator begin ( const Bounds2i & b ) begin of the bounds2i iteration","title":"function begin"},{"location":"Namespaces/namespacedakku/#function-end","text":"inline Bounds2iIterator end ( const Bounds2i & b ) end of the bounds2i iteration","title":"function end"},{"location":"Namespaces/namespacedakku/#function-isnan","text":"template < typename T > DAKKU_INLINE bool isNaN ( T x ) check whether x is not a number Parameters : x given value Template Parameters : T type (floating point) Return : whether x is nan","title":"function isNaN"},{"location":"Namespaces/namespacedakku/#function-isnan_1","text":"template < typename T > DAKKU_INLINE bool isNaN ( T ) check whether x is not a number Template Parameters : T type (integer) Return : false (all integers are not nans)","title":"function isNaN"},{"location":"Namespaces/namespacedakku/#function-dot","text":"template < ArithmeticType T , size_t S , typename D1 , typename D2 > inline decltype ( auto ) dot ( const VectorBase < T , S , D1 > & a , const VectorBase < T , S , D2 > & b ) dot product between two vectors Parameters : a \\(\\vec a\\) b \\(\\vec b\\) Return : \\(\\vec a \\cdot \\vec b\\)","title":"function dot"},{"location":"Namespaces/namespacedakku/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"Namespaces/namespacedakku/#variable-inf","text":"static constexpr float INF = std :: numeric_limits < float >:: infinity (); infinity Updated on 2022-04-07 at 06:53:17 +0000","title":"variable INF"},{"location":"Namespaces/namespacestd/","text":"std Updated on 2022-04-07 at 06:53:17 +0000","title":"std"},{"location":"Namespaces/namespacestd/#std","text":"Updated on 2022-04-07 at 06:53:17 +0000","title":"std"},{"location":"Pages/","text":"Pages page dakku documentation page Vector Base Updated on 2022-04-07 at 06:53:17 +0000","title":"Pages"},{"location":"Pages/#pages","text":"page dakku documentation page Vector Base Updated on 2022-04-07 at 06:53:17 +0000","title":"Pages"},{"location":"Pages/vector_base/","text":"Vector Base dakku currently use naive implementation, may use intrinsics and expression templates later. Updated on 2022-04-07 at 06:53:17 +0000","title":"Vector Base"},{"location":"Pages/vector_base/#vector-base","text":"dakku currently use naive implementation, may use intrinsics and expression templates later. Updated on 2022-04-07 at 06:53:17 +0000","title":"Vector Base"}]}