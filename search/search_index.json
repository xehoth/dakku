{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"dakku documentation This is the documentation of dakku renderer. Updated on 2022-04-25 at 08:42:24 +0000","title":"dakku documentation"},{"location":"#dakku-documentation","text":"This is the documentation of dakku renderer. Updated on 2022-04-25 at 08:42:24 +0000","title":"dakku documentation"},{"location":"Classes/","text":"Classes namespace dakku dakku namespace class Logger logger class class Lua dakku lua state class Normal normal class Point point class Vector vector class VectorBase vector base Updated on 2022-04-25 at 08:42:24 +0000","title":"Classes"},{"location":"Classes/#classes","text":"namespace dakku dakku namespace class Logger logger class class Lua dakku lua state class Normal normal class Point point class Vector vector class VectorBase vector base Updated on 2022-04-25 at 08:42:24 +0000","title":"Classes"},{"location":"Classes/classdakku_1_1Logger/","text":"dakku::Logger logger class #include <logger.h> Public Functions Name const Logger & get () get logger instance spdlog::logger * handle () const get raw spdlog::logger handle Public Functions Documentation function get static const Logger & get () get logger instance Return : the logger instance function handle inline spdlog :: logger * handle () const get raw spdlog::logger handle Return : the corresponding spdlog::logger Updated on 2022-04-25 at 08:42:24 +0000","title":"dakku::Logger"},{"location":"Classes/classdakku_1_1Logger/#dakkulogger","text":"logger class #include <logger.h>","title":"dakku::Logger"},{"location":"Classes/classdakku_1_1Logger/#public-functions","text":"Name const Logger & get () get logger instance spdlog::logger * handle () const get raw spdlog::logger handle","title":"Public Functions"},{"location":"Classes/classdakku_1_1Logger/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Classes/classdakku_1_1Logger/#function-get","text":"static const Logger & get () get logger instance Return : the logger instance","title":"function get"},{"location":"Classes/classdakku_1_1Logger/#function-handle","text":"inline spdlog :: logger * handle () const get raw spdlog::logger handle Return : the corresponding spdlog::logger Updated on 2022-04-25 at 08:42:24 +0000","title":"function handle"},{"location":"Classes/classdakku_1_1Lua/","text":"dakku::Lua dakku lua state #include <lua.h> Public Functions Name Lua & instance () get lua instance sol::state & get_state () get lua state Public Functions Documentation function instance static Lua & instance () get lua instance function get_state sol :: state & get_state () get lua state Updated on 2022-04-25 at 08:42:24 +0000","title":"dakku::Lua"},{"location":"Classes/classdakku_1_1Lua/#dakkulua","text":"dakku lua state #include <lua.h>","title":"dakku::Lua"},{"location":"Classes/classdakku_1_1Lua/#public-functions","text":"Name Lua & instance () get lua instance sol::state & get_state () get lua state","title":"Public Functions"},{"location":"Classes/classdakku_1_1Lua/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Classes/classdakku_1_1Lua/#function-instance","text":"static Lua & instance () get lua instance","title":"function instance"},{"location":"Classes/classdakku_1_1Lua/#function-get_state","text":"sol :: state & get_state () get lua state Updated on 2022-04-25 at 08:42:24 +0000","title":"function get_state"},{"location":"Classes/classdakku_1_1Normal/","text":"dakku::Normal normal More... #include <vector.h> Inherits from dakku::VectorBase< T, S, D > Public Functions Name D operator- () const negation of the vector D operator- (const D & rhs) const subtraction template <ArithmeticType V> D operator- (V rhs) const subtraction Additional inherited members Public Functions inherited from dakku::VectorBase< T, S, D > Name VectorBase () Construct a new Vector Base object all components initialized to zero. template <ArithmeticType Arg> VectorBase (Arg value) Construct a new Vector Base object all components initalized to value VectorBase (const sol::table & table) Construct a new Vector Base object all components initalized to table. template <ArithmeticType Other,typename OtherDerived > VectorBase (const VectorBase < Other, S, OtherDerived > & other) Construct a new Vector Base object with given values. VectorBase (const VectorBase & other) VectorBase ( VectorBase && other) VectorBase & operator= (const VectorBase & other) VectorBase & operator= ( VectorBase && other) const D & derived () const convert to derived type D & derived () convert to derived type template <ArithmeticType Arg> void set (Arg value) set all components to value template <ArithmeticType Arg> void set_by_index (size_t index, Arg value) set data[index] to value template <ArithmeticType... Args,size_t... Is> void set (std::index_sequence< Is... > , Args &&... args) set data to args template <ArithmeticType... Args> void set (Args &&... args) set data to args template <ArithmeticType Other,typename OtherDerived > void set (const VectorBase < Other, S, OtherDerived > & rhs) set data by rhs 's data const T & get (size_t i) const get i'th component size_t size () const size of the vector std::string to_string () const convert vector to string bool has_nans () const check whether there are nan components D clone () const get a copy const T & operator[] (size_t i) const get i'th value T & operator[] (size_t i) get i'th value D & operator+= (const D & rhs) addition template <ArithmeticType V> D & operator+= (V rhs) addition D operator+ (const D & rhs) const addition template <ArithmeticType V> D operator+ (V rhs) const addition D & operator-= (const D & rhs) subtraction template <ArithmeticType V> D & operator-= (V rhs) subtraction D & operator*= (const D & rhs) multiplication template <ArithmeticType V> D & operator*= (V rhs) multiplication D operator* (const D & rhs) const multiplication template <ArithmeticType V> D operator* (V rhs) const multiplication D & operator/= (const D & rhs) division template <ArithmeticType V> D & operator/= (V rhs) division D operator/ (const D & rhs) const division template <ArithmeticType U> D operator/ (U rhs) const division bool operator== (const VectorBase & rhs) const bool operator!= (const VectorBase & rhs) const decltype(auto) x () const get the first element decltype(auto) x () get the first element decltype(auto) y () const get the second element decltype(auto) y () get the second element decltype(auto) z () const get the third element decltype(auto) z () get the fourth element decltype(auto) w () const get the fourth element decltype(auto) w () get the third element size_t max_element_index () const get the index of the max element decltype(auto) max_element () const get the max element in the vector D max (const D & rhs) const element wise max D min (const D & rhs) const element wise min template <typename OtherDerived > decltype(auto) dot (const VectorBase < T, S, OtherDerived > & rhs) const dot product between two vectors decltype(auto) squaredNorm () const squared norm decltype(auto) norm () const norm decltype(auto) length () const length decltype(auto) distance (const D & rhs) const the distance D abs () const abs D cross (const D & rhs) const cross product bool is_zero () const check whether all components are zero D sqrt () const element-wise sqrt template <ArithmeticType E> D pow (E e) const element-wise power D exp () const element-wise exp D floor () const element-wise floor D ceil () const element-wise ceil D lerp (const D & b, T t) const element-wise linear interpolation operator std::span< T, S > () operator std::span< const T, S > () const Friends inherited from dakku::VectorBase< T, S, D > Name D operator+ (U a, const D & b) addition D operator* (U a, const D & b) multiplication D operator/ (U a, const D & b) division std::ostream & operator<< (std::ostream & os, const VectorBase & vec) output the vector D max (const D & v1, const D & v2) element wise max D min (const D & v1, const D & v2) element wise min decltype(auto) distance (const D & a, const D & b) the distance D abs (const D & v) abs D sqrt (const D & v) element-wise sqrt D pow (const D & v, E e) element-wise power D exp (const D & v) element-wise exp D floor (const D & v) element-wise floor D ceil (const D & v) element-wise ceil D lerp (const D & a, const D & b, T t) element-wise linear interpolation Detailed Description template < typename T , size_t S , typename D > class dakku :: Normal ; normal Template Parameters : T type S size D derived Public Functions Documentation function operator- inline D operator - () const negation of the vector Return : \\(-\\vec v\\) function operator- inline D operator - ( const D & rhs ) const subtraction function operator- template < ArithmeticType V > inline D operator - ( V rhs ) const subtraction Updated on 2022-04-25 at 08:42:24 +0000","title":"dakku::Normal"},{"location":"Classes/classdakku_1_1Normal/#dakkunormal","text":"normal More... #include <vector.h> Inherits from dakku::VectorBase< T, S, D >","title":"dakku::Normal"},{"location":"Classes/classdakku_1_1Normal/#public-functions","text":"Name D operator- () const negation of the vector D operator- (const D & rhs) const subtraction template <ArithmeticType V> D operator- (V rhs) const subtraction","title":"Public Functions"},{"location":"Classes/classdakku_1_1Normal/#additional-inherited-members","text":"Public Functions inherited from dakku::VectorBase< T, S, D > Name VectorBase () Construct a new Vector Base object all components initialized to zero. template <ArithmeticType Arg> VectorBase (Arg value) Construct a new Vector Base object all components initalized to value VectorBase (const sol::table & table) Construct a new Vector Base object all components initalized to table. template <ArithmeticType Other,typename OtherDerived > VectorBase (const VectorBase < Other, S, OtherDerived > & other) Construct a new Vector Base object with given values. VectorBase (const VectorBase & other) VectorBase ( VectorBase && other) VectorBase & operator= (const VectorBase & other) VectorBase & operator= ( VectorBase && other) const D & derived () const convert to derived type D & derived () convert to derived type template <ArithmeticType Arg> void set (Arg value) set all components to value template <ArithmeticType Arg> void set_by_index (size_t index, Arg value) set data[index] to value template <ArithmeticType... Args,size_t... Is> void set (std::index_sequence< Is... > , Args &&... args) set data to args template <ArithmeticType... Args> void set (Args &&... args) set data to args template <ArithmeticType Other,typename OtherDerived > void set (const VectorBase < Other, S, OtherDerived > & rhs) set data by rhs 's data const T & get (size_t i) const get i'th component size_t size () const size of the vector std::string to_string () const convert vector to string bool has_nans () const check whether there are nan components D clone () const get a copy const T & operator[] (size_t i) const get i'th value T & operator[] (size_t i) get i'th value D & operator+= (const D & rhs) addition template <ArithmeticType V> D & operator+= (V rhs) addition D operator+ (const D & rhs) const addition template <ArithmeticType V> D operator+ (V rhs) const addition D & operator-= (const D & rhs) subtraction template <ArithmeticType V> D & operator-= (V rhs) subtraction D & operator*= (const D & rhs) multiplication template <ArithmeticType V> D & operator*= (V rhs) multiplication D operator* (const D & rhs) const multiplication template <ArithmeticType V> D operator* (V rhs) const multiplication D & operator/= (const D & rhs) division template <ArithmeticType V> D & operator/= (V rhs) division D operator/ (const D & rhs) const division template <ArithmeticType U> D operator/ (U rhs) const division bool operator== (const VectorBase & rhs) const bool operator!= (const VectorBase & rhs) const decltype(auto) x () const get the first element decltype(auto) x () get the first element decltype(auto) y () const get the second element decltype(auto) y () get the second element decltype(auto) z () const get the third element decltype(auto) z () get the fourth element decltype(auto) w () const get the fourth element decltype(auto) w () get the third element size_t max_element_index () const get the index of the max element decltype(auto) max_element () const get the max element in the vector D max (const D & rhs) const element wise max D min (const D & rhs) const element wise min template <typename OtherDerived > decltype(auto) dot (const VectorBase < T, S, OtherDerived > & rhs) const dot product between two vectors decltype(auto) squaredNorm () const squared norm decltype(auto) norm () const norm decltype(auto) length () const length decltype(auto) distance (const D & rhs) const the distance D abs () const abs D cross (const D & rhs) const cross product bool is_zero () const check whether all components are zero D sqrt () const element-wise sqrt template <ArithmeticType E> D pow (E e) const element-wise power D exp () const element-wise exp D floor () const element-wise floor D ceil () const element-wise ceil D lerp (const D & b, T t) const element-wise linear interpolation operator std::span< T, S > () operator std::span< const T, S > () const Friends inherited from dakku::VectorBase< T, S, D > Name D operator+ (U a, const D & b) addition D operator* (U a, const D & b) multiplication D operator/ (U a, const D & b) division std::ostream & operator<< (std::ostream & os, const VectorBase & vec) output the vector D max (const D & v1, const D & v2) element wise max D min (const D & v1, const D & v2) element wise min decltype(auto) distance (const D & a, const D & b) the distance D abs (const D & v) abs D sqrt (const D & v) element-wise sqrt D pow (const D & v, E e) element-wise power D exp (const D & v) element-wise exp D floor (const D & v) element-wise floor D ceil (const D & v) element-wise ceil D lerp (const D & a, const D & b, T t) element-wise linear interpolation","title":"Additional inherited members"},{"location":"Classes/classdakku_1_1Normal/#detailed-description","text":"template < typename T , size_t S , typename D > class dakku :: Normal ; normal Template Parameters : T type S size D derived","title":"Detailed Description"},{"location":"Classes/classdakku_1_1Normal/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Classes/classdakku_1_1Normal/#function-operator-","text":"inline D operator - () const negation of the vector Return : \\(-\\vec v\\)","title":"function operator-"},{"location":"Classes/classdakku_1_1Normal/#function-operator-_1","text":"inline D operator - ( const D & rhs ) const subtraction","title":"function operator-"},{"location":"Classes/classdakku_1_1Normal/#function-operator-_2","text":"template < ArithmeticType V > inline D operator - ( V rhs ) const subtraction Updated on 2022-04-25 at 08:42:24 +0000","title":"function operator-"},{"location":"Classes/classdakku_1_1Point/","text":"dakku::Point point More... #include <vector.h> Inherits from dakku::VectorBase< T, S, D > Additional inherited members Public Functions inherited from dakku::VectorBase< T, S, D > Name VectorBase () Construct a new Vector Base object all components initialized to zero. template <ArithmeticType Arg> VectorBase (Arg value) Construct a new Vector Base object all components initalized to value VectorBase (const sol::table & table) Construct a new Vector Base object all components initalized to table. template <ArithmeticType Other,typename OtherDerived > VectorBase (const VectorBase < Other, S, OtherDerived > & other) Construct a new Vector Base object with given values. VectorBase (const VectorBase & other) VectorBase ( VectorBase && other) VectorBase & operator= (const VectorBase & other) VectorBase & operator= ( VectorBase && other) const D & derived () const convert to derived type D & derived () convert to derived type template <ArithmeticType Arg> void set (Arg value) set all components to value template <ArithmeticType Arg> void set_by_index (size_t index, Arg value) set data[index] to value template <ArithmeticType... Args,size_t... Is> void set (std::index_sequence< Is... > , Args &&... args) set data to args template <ArithmeticType... Args> void set (Args &&... args) set data to args template <ArithmeticType Other,typename OtherDerived > void set (const VectorBase < Other, S, OtherDerived > & rhs) set data by rhs 's data const T & get (size_t i) const get i'th component size_t size () const size of the vector std::string to_string () const convert vector to string bool has_nans () const check whether there are nan components D clone () const get a copy const T & operator[] (size_t i) const get i'th value T & operator[] (size_t i) get i'th value D & operator+= (const D & rhs) addition template <ArithmeticType V> D & operator+= (V rhs) addition D operator+ (const D & rhs) const addition template <ArithmeticType V> D operator+ (V rhs) const addition D & operator-= (const D & rhs) subtraction template <ArithmeticType V> D & operator-= (V rhs) subtraction D & operator*= (const D & rhs) multiplication template <ArithmeticType V> D & operator*= (V rhs) multiplication D operator* (const D & rhs) const multiplication template <ArithmeticType V> D operator* (V rhs) const multiplication D & operator/= (const D & rhs) division template <ArithmeticType V> D & operator/= (V rhs) division D operator/ (const D & rhs) const division template <ArithmeticType U> D operator/ (U rhs) const division bool operator== (const VectorBase & rhs) const bool operator!= (const VectorBase & rhs) const decltype(auto) x () const get the first element decltype(auto) x () get the first element decltype(auto) y () const get the second element decltype(auto) y () get the second element decltype(auto) z () const get the third element decltype(auto) z () get the fourth element decltype(auto) w () const get the fourth element decltype(auto) w () get the third element size_t max_element_index () const get the index of the max element decltype(auto) max_element () const get the max element in the vector D max (const D & rhs) const element wise max D min (const D & rhs) const element wise min template <typename OtherDerived > decltype(auto) dot (const VectorBase < T, S, OtherDerived > & rhs) const dot product between two vectors decltype(auto) squaredNorm () const squared norm decltype(auto) norm () const norm decltype(auto) length () const length decltype(auto) distance (const D & rhs) const the distance D abs () const abs D cross (const D & rhs) const cross product bool is_zero () const check whether all components are zero D sqrt () const element-wise sqrt template <ArithmeticType E> D pow (E e) const element-wise power D exp () const element-wise exp D floor () const element-wise floor D ceil () const element-wise ceil D lerp (const D & b, T t) const element-wise linear interpolation operator std::span< T, S > () operator std::span< const T, S > () const Friends inherited from dakku::VectorBase< T, S, D > Name D operator+ (U a, const D & b) addition D operator- (U a, const D & b) subtraction D operator* (U a, const D & b) multiplication D operator/ (U a, const D & b) division std::ostream & operator<< (std::ostream & os, const VectorBase & vec) output the vector D max (const D & v1, const D & v2) element wise max D min (const D & v1, const D & v2) element wise min decltype(auto) distance (const D & a, const D & b) the distance D abs (const D & v) abs D sqrt (const D & v) element-wise sqrt D pow (const D & v, E e) element-wise power D exp (const D & v) element-wise exp D floor (const D & v) element-wise floor D ceil (const D & v) element-wise ceil D lerp (const D & a, const D & b, T t) element-wise linear interpolation Detailed Description template < typename T , size_t S , typename D > class dakku :: Point ; point Template Parameters : T type S size D derived Updated on 2022-04-25 at 08:42:24 +0000","title":"dakku::Point"},{"location":"Classes/classdakku_1_1Point/#dakkupoint","text":"point More... #include <vector.h> Inherits from dakku::VectorBase< T, S, D >","title":"dakku::Point"},{"location":"Classes/classdakku_1_1Point/#additional-inherited-members","text":"Public Functions inherited from dakku::VectorBase< T, S, D > Name VectorBase () Construct a new Vector Base object all components initialized to zero. template <ArithmeticType Arg> VectorBase (Arg value) Construct a new Vector Base object all components initalized to value VectorBase (const sol::table & table) Construct a new Vector Base object all components initalized to table. template <ArithmeticType Other,typename OtherDerived > VectorBase (const VectorBase < Other, S, OtherDerived > & other) Construct a new Vector Base object with given values. VectorBase (const VectorBase & other) VectorBase ( VectorBase && other) VectorBase & operator= (const VectorBase & other) VectorBase & operator= ( VectorBase && other) const D & derived () const convert to derived type D & derived () convert to derived type template <ArithmeticType Arg> void set (Arg value) set all components to value template <ArithmeticType Arg> void set_by_index (size_t index, Arg value) set data[index] to value template <ArithmeticType... Args,size_t... Is> void set (std::index_sequence< Is... > , Args &&... args) set data to args template <ArithmeticType... Args> void set (Args &&... args) set data to args template <ArithmeticType Other,typename OtherDerived > void set (const VectorBase < Other, S, OtherDerived > & rhs) set data by rhs 's data const T & get (size_t i) const get i'th component size_t size () const size of the vector std::string to_string () const convert vector to string bool has_nans () const check whether there are nan components D clone () const get a copy const T & operator[] (size_t i) const get i'th value T & operator[] (size_t i) get i'th value D & operator+= (const D & rhs) addition template <ArithmeticType V> D & operator+= (V rhs) addition D operator+ (const D & rhs) const addition template <ArithmeticType V> D operator+ (V rhs) const addition D & operator-= (const D & rhs) subtraction template <ArithmeticType V> D & operator-= (V rhs) subtraction D & operator*= (const D & rhs) multiplication template <ArithmeticType V> D & operator*= (V rhs) multiplication D operator* (const D & rhs) const multiplication template <ArithmeticType V> D operator* (V rhs) const multiplication D & operator/= (const D & rhs) division template <ArithmeticType V> D & operator/= (V rhs) division D operator/ (const D & rhs) const division template <ArithmeticType U> D operator/ (U rhs) const division bool operator== (const VectorBase & rhs) const bool operator!= (const VectorBase & rhs) const decltype(auto) x () const get the first element decltype(auto) x () get the first element decltype(auto) y () const get the second element decltype(auto) y () get the second element decltype(auto) z () const get the third element decltype(auto) z () get the fourth element decltype(auto) w () const get the fourth element decltype(auto) w () get the third element size_t max_element_index () const get the index of the max element decltype(auto) max_element () const get the max element in the vector D max (const D & rhs) const element wise max D min (const D & rhs) const element wise min template <typename OtherDerived > decltype(auto) dot (const VectorBase < T, S, OtherDerived > & rhs) const dot product between two vectors decltype(auto) squaredNorm () const squared norm decltype(auto) norm () const norm decltype(auto) length () const length decltype(auto) distance (const D & rhs) const the distance D abs () const abs D cross (const D & rhs) const cross product bool is_zero () const check whether all components are zero D sqrt () const element-wise sqrt template <ArithmeticType E> D pow (E e) const element-wise power D exp () const element-wise exp D floor () const element-wise floor D ceil () const element-wise ceil D lerp (const D & b, T t) const element-wise linear interpolation operator std::span< T, S > () operator std::span< const T, S > () const Friends inherited from dakku::VectorBase< T, S, D > Name D operator+ (U a, const D & b) addition D operator- (U a, const D & b) subtraction D operator* (U a, const D & b) multiplication D operator/ (U a, const D & b) division std::ostream & operator<< (std::ostream & os, const VectorBase & vec) output the vector D max (const D & v1, const D & v2) element wise max D min (const D & v1, const D & v2) element wise min decltype(auto) distance (const D & a, const D & b) the distance D abs (const D & v) abs D sqrt (const D & v) element-wise sqrt D pow (const D & v, E e) element-wise power D exp (const D & v) element-wise exp D floor (const D & v) element-wise floor D ceil (const D & v) element-wise ceil D lerp (const D & a, const D & b, T t) element-wise linear interpolation","title":"Additional inherited members"},{"location":"Classes/classdakku_1_1Point/#detailed-description","text":"template < typename T , size_t S , typename D > class dakku :: Point ; point Template Parameters : T type S size D derived Updated on 2022-04-25 at 08:42:24 +0000","title":"Detailed Description"},{"location":"Classes/classdakku_1_1Vector/","text":"dakku::Vector vector More... #include <vector.h> Inherits from dakku::VectorBase< T, S, D > Public Functions Name D operator- () const negation of the vector D operator- (const D & rhs) const subtraction template <ArithmeticType V> D operator- (V rhs) const subtraction Additional inherited members Public Functions inherited from dakku::VectorBase< T, S, D > Name VectorBase () Construct a new Vector Base object all components initialized to zero. template <ArithmeticType Arg> VectorBase (Arg value) Construct a new Vector Base object all components initalized to value VectorBase (const sol::table & table) Construct a new Vector Base object all components initalized to table. template <ArithmeticType Other,typename OtherDerived > VectorBase (const VectorBase < Other, S, OtherDerived > & other) Construct a new Vector Base object with given values. VectorBase (const VectorBase & other) VectorBase ( VectorBase && other) VectorBase & operator= (const VectorBase & other) VectorBase & operator= ( VectorBase && other) const D & derived () const convert to derived type D & derived () convert to derived type template <ArithmeticType Arg> void set (Arg value) set all components to value template <ArithmeticType Arg> void set_by_index (size_t index, Arg value) set data[index] to value template <ArithmeticType... Args,size_t... Is> void set (std::index_sequence< Is... > , Args &&... args) set data to args template <ArithmeticType... Args> void set (Args &&... args) set data to args template <ArithmeticType Other,typename OtherDerived > void set (const VectorBase < Other, S, OtherDerived > & rhs) set data by rhs 's data const T & get (size_t i) const get i'th component size_t size () const size of the vector std::string to_string () const convert vector to string bool has_nans () const check whether there are nan components D clone () const get a copy const T & operator[] (size_t i) const get i'th value T & operator[] (size_t i) get i'th value D & operator+= (const D & rhs) addition template <ArithmeticType V> D & operator+= (V rhs) addition D operator+ (const D & rhs) const addition template <ArithmeticType V> D operator+ (V rhs) const addition D & operator-= (const D & rhs) subtraction template <ArithmeticType V> D & operator-= (V rhs) subtraction D & operator*= (const D & rhs) multiplication template <ArithmeticType V> D & operator*= (V rhs) multiplication D operator* (const D & rhs) const multiplication template <ArithmeticType V> D operator* (V rhs) const multiplication D & operator/= (const D & rhs) division template <ArithmeticType V> D & operator/= (V rhs) division D operator/ (const D & rhs) const division template <ArithmeticType U> D operator/ (U rhs) const division bool operator== (const VectorBase & rhs) const bool operator!= (const VectorBase & rhs) const decltype(auto) x () const get the first element decltype(auto) x () get the first element decltype(auto) y () const get the second element decltype(auto) y () get the second element decltype(auto) z () const get the third element decltype(auto) z () get the fourth element decltype(auto) w () const get the fourth element decltype(auto) w () get the third element size_t max_element_index () const get the index of the max element decltype(auto) max_element () const get the max element in the vector D max (const D & rhs) const element wise max D min (const D & rhs) const element wise min template <typename OtherDerived > decltype(auto) dot (const VectorBase < T, S, OtherDerived > & rhs) const dot product between two vectors decltype(auto) squaredNorm () const squared norm decltype(auto) norm () const norm decltype(auto) length () const length decltype(auto) distance (const D & rhs) const the distance D abs () const abs D cross (const D & rhs) const cross product bool is_zero () const check whether all components are zero D sqrt () const element-wise sqrt template <ArithmeticType E> D pow (E e) const element-wise power D exp () const element-wise exp D floor () const element-wise floor D ceil () const element-wise ceil D lerp (const D & b, T t) const element-wise linear interpolation operator std::span< T, S > () operator std::span< const T, S > () const Friends inherited from dakku::VectorBase< T, S, D > Name D operator+ (U a, const D & b) addition D operator* (U a, const D & b) multiplication D operator/ (U a, const D & b) division std::ostream & operator<< (std::ostream & os, const VectorBase & vec) output the vector D max (const D & v1, const D & v2) element wise max D min (const D & v1, const D & v2) element wise min decltype(auto) distance (const D & a, const D & b) the distance D abs (const D & v) abs D sqrt (const D & v) element-wise sqrt D pow (const D & v, E e) element-wise power D exp (const D & v) element-wise exp D floor (const D & v) element-wise floor D ceil (const D & v) element-wise ceil D lerp (const D & a, const D & b, T t) element-wise linear interpolation Detailed Description template < typename T , size_t S , typename D > class dakku :: Vector ; vector Template Parameters : T type S size D derived Public Functions Documentation function operator- inline D operator - () const negation of the vector Return : \\(-\\vec v\\) function operator- inline D operator - ( const D & rhs ) const subtraction function operator- template < ArithmeticType V > inline D operator - ( V rhs ) const subtraction Updated on 2022-04-25 at 08:42:24 +0000","title":"dakku::Vector"},{"location":"Classes/classdakku_1_1Vector/#dakkuvector","text":"vector More... #include <vector.h> Inherits from dakku::VectorBase< T, S, D >","title":"dakku::Vector"},{"location":"Classes/classdakku_1_1Vector/#public-functions","text":"Name D operator- () const negation of the vector D operator- (const D & rhs) const subtraction template <ArithmeticType V> D operator- (V rhs) const subtraction","title":"Public Functions"},{"location":"Classes/classdakku_1_1Vector/#additional-inherited-members","text":"Public Functions inherited from dakku::VectorBase< T, S, D > Name VectorBase () Construct a new Vector Base object all components initialized to zero. template <ArithmeticType Arg> VectorBase (Arg value) Construct a new Vector Base object all components initalized to value VectorBase (const sol::table & table) Construct a new Vector Base object all components initalized to table. template <ArithmeticType Other,typename OtherDerived > VectorBase (const VectorBase < Other, S, OtherDerived > & other) Construct a new Vector Base object with given values. VectorBase (const VectorBase & other) VectorBase ( VectorBase && other) VectorBase & operator= (const VectorBase & other) VectorBase & operator= ( VectorBase && other) const D & derived () const convert to derived type D & derived () convert to derived type template <ArithmeticType Arg> void set (Arg value) set all components to value template <ArithmeticType Arg> void set_by_index (size_t index, Arg value) set data[index] to value template <ArithmeticType... Args,size_t... Is> void set (std::index_sequence< Is... > , Args &&... args) set data to args template <ArithmeticType... Args> void set (Args &&... args) set data to args template <ArithmeticType Other,typename OtherDerived > void set (const VectorBase < Other, S, OtherDerived > & rhs) set data by rhs 's data const T & get (size_t i) const get i'th component size_t size () const size of the vector std::string to_string () const convert vector to string bool has_nans () const check whether there are nan components D clone () const get a copy const T & operator[] (size_t i) const get i'th value T & operator[] (size_t i) get i'th value D & operator+= (const D & rhs) addition template <ArithmeticType V> D & operator+= (V rhs) addition D operator+ (const D & rhs) const addition template <ArithmeticType V> D operator+ (V rhs) const addition D & operator-= (const D & rhs) subtraction template <ArithmeticType V> D & operator-= (V rhs) subtraction D & operator*= (const D & rhs) multiplication template <ArithmeticType V> D & operator*= (V rhs) multiplication D operator* (const D & rhs) const multiplication template <ArithmeticType V> D operator* (V rhs) const multiplication D & operator/= (const D & rhs) division template <ArithmeticType V> D & operator/= (V rhs) division D operator/ (const D & rhs) const division template <ArithmeticType U> D operator/ (U rhs) const division bool operator== (const VectorBase & rhs) const bool operator!= (const VectorBase & rhs) const decltype(auto) x () const get the first element decltype(auto) x () get the first element decltype(auto) y () const get the second element decltype(auto) y () get the second element decltype(auto) z () const get the third element decltype(auto) z () get the fourth element decltype(auto) w () const get the fourth element decltype(auto) w () get the third element size_t max_element_index () const get the index of the max element decltype(auto) max_element () const get the max element in the vector D max (const D & rhs) const element wise max D min (const D & rhs) const element wise min template <typename OtherDerived > decltype(auto) dot (const VectorBase < T, S, OtherDerived > & rhs) const dot product between two vectors decltype(auto) squaredNorm () const squared norm decltype(auto) norm () const norm decltype(auto) length () const length decltype(auto) distance (const D & rhs) const the distance D abs () const abs D cross (const D & rhs) const cross product bool is_zero () const check whether all components are zero D sqrt () const element-wise sqrt template <ArithmeticType E> D pow (E e) const element-wise power D exp () const element-wise exp D floor () const element-wise floor D ceil () const element-wise ceil D lerp (const D & b, T t) const element-wise linear interpolation operator std::span< T, S > () operator std::span< const T, S > () const Friends inherited from dakku::VectorBase< T, S, D > Name D operator+ (U a, const D & b) addition D operator* (U a, const D & b) multiplication D operator/ (U a, const D & b) division std::ostream & operator<< (std::ostream & os, const VectorBase & vec) output the vector D max (const D & v1, const D & v2) element wise max D min (const D & v1, const D & v2) element wise min decltype(auto) distance (const D & a, const D & b) the distance D abs (const D & v) abs D sqrt (const D & v) element-wise sqrt D pow (const D & v, E e) element-wise power D exp (const D & v) element-wise exp D floor (const D & v) element-wise floor D ceil (const D & v) element-wise ceil D lerp (const D & a, const D & b, T t) element-wise linear interpolation","title":"Additional inherited members"},{"location":"Classes/classdakku_1_1Vector/#detailed-description","text":"template < typename T , size_t S , typename D > class dakku :: Vector ; vector Template Parameters : T type S size D derived","title":"Detailed Description"},{"location":"Classes/classdakku_1_1Vector/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Classes/classdakku_1_1Vector/#function-operator-","text":"inline D operator - () const negation of the vector Return : \\(-\\vec v\\)","title":"function operator-"},{"location":"Classes/classdakku_1_1Vector/#function-operator-_1","text":"inline D operator - ( const D & rhs ) const subtraction","title":"function operator-"},{"location":"Classes/classdakku_1_1Vector/#function-operator-_2","text":"template < ArithmeticType V > inline D operator - ( V rhs ) const subtraction Updated on 2022-04-25 at 08:42:24 +0000","title":"function operator-"},{"location":"Classes/classdakku_1_1VectorBase/","text":"dakku::VectorBase vector base More... #include <vector_base.h> Inherited by dakku::Normal< T, S, D > , dakku::Point< T, S, D > , dakku::Vector< T, S, D > Public Functions Name VectorBase () Construct a new Vector Base object all components initialized to zero. template <ArithmeticType Arg> VectorBase (Arg value) Construct a new Vector Base object all components initalized to value VectorBase (const sol::table & table) Construct a new Vector Base object all components initalized to table. template <ArithmeticType Other,typename OtherDerived > VectorBase (const VectorBase < Other, S, OtherDerived > & other) Construct a new Vector Base object with given values. VectorBase (const VectorBase & other) VectorBase ( VectorBase && other) VectorBase & operator= (const VectorBase & other) VectorBase & operator= ( VectorBase && other) const D & derived () const convert to derived type D & derived () convert to derived type template <ArithmeticType Arg> void set (Arg value) set all components to value template <ArithmeticType Arg> void set_by_index (size_t index, Arg value) set data[index] to value template <ArithmeticType... Args,size_t... Is> void set (std::index_sequence< Is... > , Args &&... args) set data to args template <ArithmeticType... Args> void set (Args &&... args) set data to args template <ArithmeticType Other,typename OtherDerived > void set (const VectorBase < Other, S, OtherDerived > & rhs) set data by rhs 's data const T & get (size_t i) const get i'th component size_t size () const size of the vector std::string to_string () const convert vector to string bool has_nans () const check whether there are nan components D clone () const get a copy const T & operator[] (size_t i) const get i'th value T & operator[] (size_t i) get i'th value D & operator+= (const D & rhs) addition template <ArithmeticType V> D & operator+= (V rhs) addition D operator+ (const D & rhs) const addition template <ArithmeticType V> D operator+ (V rhs) const addition D & operator-= (const D & rhs) subtraction template <ArithmeticType V> D & operator-= (V rhs) subtraction D & operator*= (const D & rhs) multiplication template <ArithmeticType V> D & operator*= (V rhs) multiplication D operator* (const D & rhs) const multiplication template <ArithmeticType V> D operator* (V rhs) const multiplication D & operator/= (const D & rhs) division template <ArithmeticType V> D & operator/= (V rhs) division D operator/ (const D & rhs) const division template <ArithmeticType U> D operator/ (U rhs) const division bool operator== (const VectorBase & rhs) const bool operator!= (const VectorBase & rhs) const decltype(auto) x () const get the first element decltype(auto) x () get the first element decltype(auto) y () const get the second element decltype(auto) y () get the second element decltype(auto) z () const get the third element decltype(auto) z () get the fourth element decltype(auto) w () const get the fourth element decltype(auto) w () get the third element size_t max_element_index () const get the index of the max element decltype(auto) max_element () const get the max element in the vector D max (const D & rhs) const element wise max D min (const D & rhs) const element wise min template <typename OtherDerived > decltype(auto) dot (const VectorBase < T, S, OtherDerived > & rhs) const dot product between two vectors decltype(auto) squaredNorm () const squared norm decltype(auto) norm () const norm decltype(auto) length () const length decltype(auto) distance (const D & rhs) const the distance D abs () const abs D cross (const D & rhs) const cross product bool is_zero () const check whether all components are zero D sqrt () const element-wise sqrt template <ArithmeticType E> D pow (E e) const element-wise power D exp () const element-wise exp D floor () const element-wise floor D ceil () const element-wise ceil D lerp (const D & b, T t) const element-wise linear interpolation operator std::span< T, S > () operator std::span< const T, S > () const Friends Name D operator+ (U a, const D & b) addition D operator- (U a, const D & b) subtraction D operator* (U a, const D & b) multiplication D operator/ (U a, const D & b) division std::ostream & operator<< (std::ostream & os, const VectorBase & vec) output the vector D max (const D & v1, const D & v2) element wise max D min (const D & v1, const D & v2) element wise min decltype(auto) distance (const D & a, const D & b) the distance D abs (const D & v) abs D sqrt (const D & v) element-wise sqrt D pow (const D & v, E e) element-wise power D exp (const D & v) element-wise exp D floor (const D & v) element-wise floor D ceil (const D & v) element-wise ceil D lerp (const D & a, const D & b, T t) element-wise linear interpolation Detailed Description template < ArithmeticType T , size_t S , typename D > class dakku :: VectorBase ; vector base Template Parameters : T type S size D derived Public Functions Documentation function VectorBase inline VectorBase () Construct a new Vector Base object all components initialized to zero. function VectorBase template < ArithmeticType Arg > inline VectorBase ( Arg value ) Construct a new Vector Base object all components initalized to value Parameters : value init value Template Parameters : Arg value type function VectorBase inline VectorBase ( const sol :: table & table ) Construct a new Vector Base object all components initalized to table. function VectorBase template < ArithmeticType Other , typename OtherDerived > inline explicit VectorBase ( const VectorBase < Other , S , OtherDerived > & other ) Construct a new Vector Base object with given values. Parameters : args init values expr the given expression Template Parameters : Args value types Other OtherDerived Expr Construct a new Vector Base object with a vector expression function VectorBase inline VectorBase ( const VectorBase & other ) function VectorBase inline VectorBase ( VectorBase && other ) function operator= inline VectorBase & operator = ( const VectorBase & other ) function operator= inline VectorBase & operator = ( VectorBase && other ) function derived inline const D & derived () const convert to derived type function derived inline D & derived () convert to derived type function set template < ArithmeticType Arg > inline void set ( Arg value ) set all components to value Parameters : value the given value Template Parameters : Arg value type function set_by_index template < ArithmeticType Arg > inline void set_by_index ( size_t index , Arg value ) set data[index] to value Parameters : index the index of the component value the given value Template Parameters : Arg value type function set template < ArithmeticType ... Args , size_t ... Is > inline void set ( std :: index_sequence < Is ... > , Args && ... args ) set data to args Parameters : args values Template Parameters : Args value types Is indices (generated by std::index_sequence_for) function set template < ArithmeticType ... Args > inline void set ( Args && ... args ) set data to args Parameters : args values Template Parameters : Args value types function set template < ArithmeticType Other , typename OtherDerived > inline void set ( const VectorBase < Other , S , OtherDerived > & rhs ) set data by rhs 's data Parameters : rhs the given vector Template Parameters : Other rhs type OtherDerived rhs derived type function get inline const T & get ( size_t i ) const get i'th component Parameters : i the index Return : the value function size inline size_t size () const size of the vector Return : size function to_string inline std :: string to_string () const convert vector to string Return : the converted string function has_nans inline bool has_nans () const check whether there are nan components Return : true vector contains nan false vector does not contain nans function clone inline D clone () const get a copy function operator[] inline const T & operator []( size_t i ) const get i'th value Parameters : i index Return : value function operator[] inline T & operator []( size_t i ) get i'th value Parameters : i index Return : value function operator+= inline D & operator += ( const D & rhs ) addition Parameters : rhs another vector Return : this function operator+= template < ArithmeticType V > inline D & operator += ( V rhs ) addition Parameters : rhs scalar Return : this function operator+ inline D operator + ( const D & rhs ) const addition Parameters : rhs another vector Return : result function operator+ template < ArithmeticType V > inline D operator + ( V rhs ) const addition Parameters : rhs another vector Return : result function operator-= inline D & operator -= ( const D & rhs ) subtraction Parameters : rhs another vector Return : this function operator-= template < ArithmeticType V > inline D & operator -= ( V rhs ) subtraction Parameters : rhs scalar Return : this function operator*= inline D & operator *= ( const D & rhs ) multiplication Parameters : rhs another vector Return : this function operator*= template < ArithmeticType V > inline D & operator *= ( V rhs ) multiplication Parameters : rhs scalar Return : this function operator* inline D operator * ( const D & rhs ) const multiplication Parameters : rhs another vector Return : result function operator* template < ArithmeticType V > inline D operator * ( V rhs ) const multiplication Parameters : rhs scalar Return : result function operator/= inline D & operator /= ( const D & rhs ) division Parameters : rhs another vector Return : this function operator/= template < ArithmeticType V > inline D & operator /= ( V rhs ) division Parameters : rhs scalar Return : this function operator/ inline D operator / ( const D & rhs ) const division Parameters : rhs another vector Return : result function operator/ template < ArithmeticType U > inline D operator / ( U rhs ) const division Parameters : rhs scalar Return : result function operator== inline bool operator == ( const VectorBase & rhs ) const function operator!= inline bool operator != ( const VectorBase & rhs ) const function x inline decltype ( auto ) x () const get the first element function x inline decltype ( auto ) x () get the first element function y inline decltype ( auto ) y () const get the second element function y inline decltype ( auto ) y () get the second element function z inline decltype ( auto ) z () const get the third element function z inline decltype ( auto ) z () get the fourth element function w inline decltype ( auto ) w () const get the fourth element function w inline decltype ( auto ) w () get the third element function max_element_index inline size_t max_element_index () const get the index of the max element Return : the index function max_element inline decltype ( auto ) max_element () const get the max element in the vector Return : the max value function max inline D max ( const D & rhs ) const element wise max function min inline D min ( const D & rhs ) const element wise min function dot template < typename OtherDerived > inline decltype ( auto ) dot ( const VectorBase < T , S , OtherDerived > & rhs ) const dot product between two vectors Return : \\(\\vec a \\cdot \\vec b\\) function squaredNorm inline decltype ( auto ) squaredNorm () const squared norm Return : \\(||v|| ^ 2\\) function norm inline decltype ( auto ) norm () const norm Return : \\(||v||\\) function length inline decltype ( auto ) length () const length Return : \\(||v||\\) function distance inline decltype ( auto ) distance ( const D & rhs ) const the distance function abs inline D abs () const abs function cross inline D cross ( const D & rhs ) const cross product function is_zero inline bool is_zero () const check whether all components are zero function sqrt inline D sqrt () const element-wise sqrt function pow template < ArithmeticType E > inline D pow ( E e ) const element-wise power function exp inline D exp () const element-wise exp function floor inline D floor () const element-wise floor function ceil inline D ceil () const element-wise ceil function lerp inline D lerp ( const D & b , T t ) const element-wise linear interpolation function operator std::span< T, S > inline operator std :: span < T , S > () function operator std::span< const T, S > inline operator std :: span < const T , S > () const Friends friend operator+ friend D operator + ( U a , const D & b ); addition Parameters : a \\(aa\\) b \\(\\vec b\\) Return : elementwise add a friend operator- friend D operator - ( U a , const D & b ); subtraction Parameters : a \\(aa\\) b \\(\\vec b\\) Return : elementwise sub friend operator* friend D operator * ( U a , const D & b ); multiplication Parameters : a \\(aa\\) b \\(\\vec b\\) Return : elementwise mul friend operator/ friend D operator / ( U a , const D & b ); division Parameters : a \\(aa\\) b \\(\\vec b\\) Return : elementwise div (broad cast \\(a\\) ) friend operator<< friend std :: ostream & operator << ( std :: ostream & os , const VectorBase & vec ); output the vector Parameters : os ostream vec the vector to output Return : ostream friend max friend D max ( const D & v1 , const D & v2 ); element wise max friend min friend D min ( const D & v1 , const D & v2 ); element wise min friend distance friend decltype ( auto ) distance ( const D & a , const D & b ); the distance friend abs friend D abs ( const D & v ); abs friend sqrt friend D sqrt ( const D & v ); element-wise sqrt friend pow friend D pow ( const D & v , E e ); element-wise power friend exp friend D exp ( const D & v ); element-wise exp friend floor friend D floor ( const D & v ); element-wise floor friend ceil friend D ceil ( const D & v ); element-wise ceil friend lerp friend D lerp ( const D & a , const D & b , T t ); element-wise linear interpolation Updated on 2022-04-25 at 08:42:24 +0000","title":"dakku::VectorBase"},{"location":"Classes/classdakku_1_1VectorBase/#dakkuvectorbase","text":"vector base More... #include <vector_base.h> Inherited by dakku::Normal< T, S, D > , dakku::Point< T, S, D > , dakku::Vector< T, S, D >","title":"dakku::VectorBase"},{"location":"Classes/classdakku_1_1VectorBase/#public-functions","text":"Name VectorBase () Construct a new Vector Base object all components initialized to zero. template <ArithmeticType Arg> VectorBase (Arg value) Construct a new Vector Base object all components initalized to value VectorBase (const sol::table & table) Construct a new Vector Base object all components initalized to table. template <ArithmeticType Other,typename OtherDerived > VectorBase (const VectorBase < Other, S, OtherDerived > & other) Construct a new Vector Base object with given values. VectorBase (const VectorBase & other) VectorBase ( VectorBase && other) VectorBase & operator= (const VectorBase & other) VectorBase & operator= ( VectorBase && other) const D & derived () const convert to derived type D & derived () convert to derived type template <ArithmeticType Arg> void set (Arg value) set all components to value template <ArithmeticType Arg> void set_by_index (size_t index, Arg value) set data[index] to value template <ArithmeticType... Args,size_t... Is> void set (std::index_sequence< Is... > , Args &&... args) set data to args template <ArithmeticType... Args> void set (Args &&... args) set data to args template <ArithmeticType Other,typename OtherDerived > void set (const VectorBase < Other, S, OtherDerived > & rhs) set data by rhs 's data const T & get (size_t i) const get i'th component size_t size () const size of the vector std::string to_string () const convert vector to string bool has_nans () const check whether there are nan components D clone () const get a copy const T & operator[] (size_t i) const get i'th value T & operator[] (size_t i) get i'th value D & operator+= (const D & rhs) addition template <ArithmeticType V> D & operator+= (V rhs) addition D operator+ (const D & rhs) const addition template <ArithmeticType V> D operator+ (V rhs) const addition D & operator-= (const D & rhs) subtraction template <ArithmeticType V> D & operator-= (V rhs) subtraction D & operator*= (const D & rhs) multiplication template <ArithmeticType V> D & operator*= (V rhs) multiplication D operator* (const D & rhs) const multiplication template <ArithmeticType V> D operator* (V rhs) const multiplication D & operator/= (const D & rhs) division template <ArithmeticType V> D & operator/= (V rhs) division D operator/ (const D & rhs) const division template <ArithmeticType U> D operator/ (U rhs) const division bool operator== (const VectorBase & rhs) const bool operator!= (const VectorBase & rhs) const decltype(auto) x () const get the first element decltype(auto) x () get the first element decltype(auto) y () const get the second element decltype(auto) y () get the second element decltype(auto) z () const get the third element decltype(auto) z () get the fourth element decltype(auto) w () const get the fourth element decltype(auto) w () get the third element size_t max_element_index () const get the index of the max element decltype(auto) max_element () const get the max element in the vector D max (const D & rhs) const element wise max D min (const D & rhs) const element wise min template <typename OtherDerived > decltype(auto) dot (const VectorBase < T, S, OtherDerived > & rhs) const dot product between two vectors decltype(auto) squaredNorm () const squared norm decltype(auto) norm () const norm decltype(auto) length () const length decltype(auto) distance (const D & rhs) const the distance D abs () const abs D cross (const D & rhs) const cross product bool is_zero () const check whether all components are zero D sqrt () const element-wise sqrt template <ArithmeticType E> D pow (E e) const element-wise power D exp () const element-wise exp D floor () const element-wise floor D ceil () const element-wise ceil D lerp (const D & b, T t) const element-wise linear interpolation operator std::span< T, S > () operator std::span< const T, S > () const","title":"Public Functions"},{"location":"Classes/classdakku_1_1VectorBase/#friends","text":"Name D operator+ (U a, const D & b) addition D operator- (U a, const D & b) subtraction D operator* (U a, const D & b) multiplication D operator/ (U a, const D & b) division std::ostream & operator<< (std::ostream & os, const VectorBase & vec) output the vector D max (const D & v1, const D & v2) element wise max D min (const D & v1, const D & v2) element wise min decltype(auto) distance (const D & a, const D & b) the distance D abs (const D & v) abs D sqrt (const D & v) element-wise sqrt D pow (const D & v, E e) element-wise power D exp (const D & v) element-wise exp D floor (const D & v) element-wise floor D ceil (const D & v) element-wise ceil D lerp (const D & a, const D & b, T t) element-wise linear interpolation","title":"Friends"},{"location":"Classes/classdakku_1_1VectorBase/#detailed-description","text":"template < ArithmeticType T , size_t S , typename D > class dakku :: VectorBase ; vector base Template Parameters : T type S size D derived","title":"Detailed Description"},{"location":"Classes/classdakku_1_1VectorBase/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Classes/classdakku_1_1VectorBase/#function-vectorbase","text":"inline VectorBase () Construct a new Vector Base object all components initialized to zero.","title":"function VectorBase"},{"location":"Classes/classdakku_1_1VectorBase/#function-vectorbase_1","text":"template < ArithmeticType Arg > inline VectorBase ( Arg value ) Construct a new Vector Base object all components initalized to value Parameters : value init value Template Parameters : Arg value type","title":"function VectorBase"},{"location":"Classes/classdakku_1_1VectorBase/#function-vectorbase_2","text":"inline VectorBase ( const sol :: table & table ) Construct a new Vector Base object all components initalized to table.","title":"function VectorBase"},{"location":"Classes/classdakku_1_1VectorBase/#function-vectorbase_3","text":"template < ArithmeticType Other , typename OtherDerived > inline explicit VectorBase ( const VectorBase < Other , S , OtherDerived > & other ) Construct a new Vector Base object with given values. Parameters : args init values expr the given expression Template Parameters : Args value types Other OtherDerived Expr Construct a new Vector Base object with a vector expression","title":"function VectorBase"},{"location":"Classes/classdakku_1_1VectorBase/#function-vectorbase_4","text":"inline VectorBase ( const VectorBase & other )","title":"function VectorBase"},{"location":"Classes/classdakku_1_1VectorBase/#function-vectorbase_5","text":"inline VectorBase ( VectorBase && other )","title":"function VectorBase"},{"location":"Classes/classdakku_1_1VectorBase/#function-operator","text":"inline VectorBase & operator = ( const VectorBase & other )","title":"function operator="},{"location":"Classes/classdakku_1_1VectorBase/#function-operator_1","text":"inline VectorBase & operator = ( VectorBase && other )","title":"function operator="},{"location":"Classes/classdakku_1_1VectorBase/#function-derived","text":"inline const D & derived () const convert to derived type","title":"function derived"},{"location":"Classes/classdakku_1_1VectorBase/#function-derived_1","text":"inline D & derived () convert to derived type","title":"function derived"},{"location":"Classes/classdakku_1_1VectorBase/#function-set","text":"template < ArithmeticType Arg > inline void set ( Arg value ) set all components to value Parameters : value the given value Template Parameters : Arg value type","title":"function set"},{"location":"Classes/classdakku_1_1VectorBase/#function-set_by_index","text":"template < ArithmeticType Arg > inline void set_by_index ( size_t index , Arg value ) set data[index] to value Parameters : index the index of the component value the given value Template Parameters : Arg value type","title":"function set_by_index"},{"location":"Classes/classdakku_1_1VectorBase/#function-set_1","text":"template < ArithmeticType ... Args , size_t ... Is > inline void set ( std :: index_sequence < Is ... > , Args && ... args ) set data to args Parameters : args values Template Parameters : Args value types Is indices (generated by std::index_sequence_for)","title":"function set"},{"location":"Classes/classdakku_1_1VectorBase/#function-set_2","text":"template < ArithmeticType ... Args > inline void set ( Args && ... args ) set data to args Parameters : args values Template Parameters : Args value types","title":"function set"},{"location":"Classes/classdakku_1_1VectorBase/#function-set_3","text":"template < ArithmeticType Other , typename OtherDerived > inline void set ( const VectorBase < Other , S , OtherDerived > & rhs ) set data by rhs 's data Parameters : rhs the given vector Template Parameters : Other rhs type OtherDerived rhs derived type","title":"function set"},{"location":"Classes/classdakku_1_1VectorBase/#function-get","text":"inline const T & get ( size_t i ) const get i'th component Parameters : i the index Return : the value","title":"function get"},{"location":"Classes/classdakku_1_1VectorBase/#function-size","text":"inline size_t size () const size of the vector Return : size","title":"function size"},{"location":"Classes/classdakku_1_1VectorBase/#function-to_string","text":"inline std :: string to_string () const convert vector to string Return : the converted string","title":"function to_string"},{"location":"Classes/classdakku_1_1VectorBase/#function-has_nans","text":"inline bool has_nans () const check whether there are nan components Return : true vector contains nan false vector does not contain nans","title":"function has_nans"},{"location":"Classes/classdakku_1_1VectorBase/#function-clone","text":"inline D clone () const get a copy","title":"function clone"},{"location":"Classes/classdakku_1_1VectorBase/#function-operator_2","text":"inline const T & operator []( size_t i ) const get i'th value Parameters : i index Return : value","title":"function operator[]"},{"location":"Classes/classdakku_1_1VectorBase/#function-operator_3","text":"inline T & operator []( size_t i ) get i'th value Parameters : i index Return : value","title":"function operator[]"},{"location":"Classes/classdakku_1_1VectorBase/#function-operator_4","text":"inline D & operator += ( const D & rhs ) addition Parameters : rhs another vector Return : this","title":"function operator+="},{"location":"Classes/classdakku_1_1VectorBase/#function-operator_5","text":"template < ArithmeticType V > inline D & operator += ( V rhs ) addition Parameters : rhs scalar Return : this","title":"function operator+="},{"location":"Classes/classdakku_1_1VectorBase/#function-operator_6","text":"inline D operator + ( const D & rhs ) const addition Parameters : rhs another vector Return : result","title":"function operator+"},{"location":"Classes/classdakku_1_1VectorBase/#function-operator_7","text":"template < ArithmeticType V > inline D operator + ( V rhs ) const addition Parameters : rhs another vector Return : result","title":"function operator+"},{"location":"Classes/classdakku_1_1VectorBase/#function-operator-","text":"inline D & operator -= ( const D & rhs ) subtraction Parameters : rhs another vector Return : this","title":"function operator-="},{"location":"Classes/classdakku_1_1VectorBase/#function-operator-_1","text":"template < ArithmeticType V > inline D & operator -= ( V rhs ) subtraction Parameters : rhs scalar Return : this","title":"function operator-="},{"location":"Classes/classdakku_1_1VectorBase/#function-operator_8","text":"inline D & operator *= ( const D & rhs ) multiplication Parameters : rhs another vector Return : this","title":"function operator*="},{"location":"Classes/classdakku_1_1VectorBase/#function-operator_9","text":"template < ArithmeticType V > inline D & operator *= ( V rhs ) multiplication Parameters : rhs scalar Return : this","title":"function operator*="},{"location":"Classes/classdakku_1_1VectorBase/#function-operator_10","text":"inline D operator * ( const D & rhs ) const multiplication Parameters : rhs another vector Return : result","title":"function operator*"},{"location":"Classes/classdakku_1_1VectorBase/#function-operator_11","text":"template < ArithmeticType V > inline D operator * ( V rhs ) const multiplication Parameters : rhs scalar Return : result","title":"function operator*"},{"location":"Classes/classdakku_1_1VectorBase/#function-operator_12","text":"inline D & operator /= ( const D & rhs ) division Parameters : rhs another vector Return : this","title":"function operator/="},{"location":"Classes/classdakku_1_1VectorBase/#function-operator_13","text":"template < ArithmeticType V > inline D & operator /= ( V rhs ) division Parameters : rhs scalar Return : this","title":"function operator/="},{"location":"Classes/classdakku_1_1VectorBase/#function-operator_14","text":"inline D operator / ( const D & rhs ) const division Parameters : rhs another vector Return : result","title":"function operator/"},{"location":"Classes/classdakku_1_1VectorBase/#function-operator_15","text":"template < ArithmeticType U > inline D operator / ( U rhs ) const division Parameters : rhs scalar Return : result","title":"function operator/"},{"location":"Classes/classdakku_1_1VectorBase/#function-operator_16","text":"inline bool operator == ( const VectorBase & rhs ) const","title":"function operator=="},{"location":"Classes/classdakku_1_1VectorBase/#function-operator_17","text":"inline bool operator != ( const VectorBase & rhs ) const","title":"function operator!="},{"location":"Classes/classdakku_1_1VectorBase/#function-x","text":"inline decltype ( auto ) x () const get the first element","title":"function x"},{"location":"Classes/classdakku_1_1VectorBase/#function-x_1","text":"inline decltype ( auto ) x () get the first element","title":"function x"},{"location":"Classes/classdakku_1_1VectorBase/#function-y","text":"inline decltype ( auto ) y () const get the second element","title":"function y"},{"location":"Classes/classdakku_1_1VectorBase/#function-y_1","text":"inline decltype ( auto ) y () get the second element","title":"function y"},{"location":"Classes/classdakku_1_1VectorBase/#function-z","text":"inline decltype ( auto ) z () const get the third element","title":"function z"},{"location":"Classes/classdakku_1_1VectorBase/#function-z_1","text":"inline decltype ( auto ) z () get the fourth element","title":"function z"},{"location":"Classes/classdakku_1_1VectorBase/#function-w","text":"inline decltype ( auto ) w () const get the fourth element","title":"function w"},{"location":"Classes/classdakku_1_1VectorBase/#function-w_1","text":"inline decltype ( auto ) w () get the third element","title":"function w"},{"location":"Classes/classdakku_1_1VectorBase/#function-max_element_index","text":"inline size_t max_element_index () const get the index of the max element Return : the index","title":"function max_element_index"},{"location":"Classes/classdakku_1_1VectorBase/#function-max_element","text":"inline decltype ( auto ) max_element () const get the max element in the vector Return : the max value","title":"function max_element"},{"location":"Classes/classdakku_1_1VectorBase/#function-max","text":"inline D max ( const D & rhs ) const element wise max","title":"function max"},{"location":"Classes/classdakku_1_1VectorBase/#function-min","text":"inline D min ( const D & rhs ) const element wise min","title":"function min"},{"location":"Classes/classdakku_1_1VectorBase/#function-dot","text":"template < typename OtherDerived > inline decltype ( auto ) dot ( const VectorBase < T , S , OtherDerived > & rhs ) const dot product between two vectors Return : \\(\\vec a \\cdot \\vec b\\)","title":"function dot"},{"location":"Classes/classdakku_1_1VectorBase/#function-squarednorm","text":"inline decltype ( auto ) squaredNorm () const squared norm Return : \\(||v|| ^ 2\\)","title":"function squaredNorm"},{"location":"Classes/classdakku_1_1VectorBase/#function-norm","text":"inline decltype ( auto ) norm () const norm Return : \\(||v||\\)","title":"function norm"},{"location":"Classes/classdakku_1_1VectorBase/#function-length","text":"inline decltype ( auto ) length () const length Return : \\(||v||\\)","title":"function length"},{"location":"Classes/classdakku_1_1VectorBase/#function-distance","text":"inline decltype ( auto ) distance ( const D & rhs ) const the distance","title":"function distance"},{"location":"Classes/classdakku_1_1VectorBase/#function-abs","text":"inline D abs () const abs","title":"function abs"},{"location":"Classes/classdakku_1_1VectorBase/#function-cross","text":"inline D cross ( const D & rhs ) const cross product","title":"function cross"},{"location":"Classes/classdakku_1_1VectorBase/#function-is_zero","text":"inline bool is_zero () const check whether all components are zero","title":"function is_zero"},{"location":"Classes/classdakku_1_1VectorBase/#function-sqrt","text":"inline D sqrt () const element-wise sqrt","title":"function sqrt"},{"location":"Classes/classdakku_1_1VectorBase/#function-pow","text":"template < ArithmeticType E > inline D pow ( E e ) const element-wise power","title":"function pow"},{"location":"Classes/classdakku_1_1VectorBase/#function-exp","text":"inline D exp () const element-wise exp","title":"function exp"},{"location":"Classes/classdakku_1_1VectorBase/#function-floor","text":"inline D floor () const element-wise floor","title":"function floor"},{"location":"Classes/classdakku_1_1VectorBase/#function-ceil","text":"inline D ceil () const element-wise ceil","title":"function ceil"},{"location":"Classes/classdakku_1_1VectorBase/#function-lerp","text":"inline D lerp ( const D & b , T t ) const element-wise linear interpolation","title":"function lerp"},{"location":"Classes/classdakku_1_1VectorBase/#function-operator-stdspan-t-s","text":"inline operator std :: span < T , S > ()","title":"function operator std::span&lt; T, S &gt;"},{"location":"Classes/classdakku_1_1VectorBase/#function-operator-stdspan-const-t-s","text":"inline operator std :: span < const T , S > () const","title":"function operator std::span&lt; const T, S &gt;"},{"location":"Classes/classdakku_1_1VectorBase/#friends_1","text":"","title":"Friends"},{"location":"Classes/classdakku_1_1VectorBase/#friend-operator","text":"friend D operator + ( U a , const D & b ); addition Parameters : a \\(aa\\) b \\(\\vec b\\) Return : elementwise add a","title":"friend operator+"},{"location":"Classes/classdakku_1_1VectorBase/#friend-operator-","text":"friend D operator - ( U a , const D & b ); subtraction Parameters : a \\(aa\\) b \\(\\vec b\\) Return : elementwise sub","title":"friend operator-"},{"location":"Classes/classdakku_1_1VectorBase/#friend-operator_1","text":"friend D operator * ( U a , const D & b ); multiplication Parameters : a \\(aa\\) b \\(\\vec b\\) Return : elementwise mul","title":"friend operator*"},{"location":"Classes/classdakku_1_1VectorBase/#friend-operator_2","text":"friend D operator / ( U a , const D & b ); division Parameters : a \\(aa\\) b \\(\\vec b\\) Return : elementwise div (broad cast \\(a\\) )","title":"friend operator/"},{"location":"Classes/classdakku_1_1VectorBase/#friend-operator_3","text":"friend std :: ostream & operator << ( std :: ostream & os , const VectorBase & vec ); output the vector Parameters : os ostream vec the vector to output Return : ostream","title":"friend operator&lt;&lt;"},{"location":"Classes/classdakku_1_1VectorBase/#friend-max","text":"friend D max ( const D & v1 , const D & v2 ); element wise max","title":"friend max"},{"location":"Classes/classdakku_1_1VectorBase/#friend-min","text":"friend D min ( const D & v1 , const D & v2 ); element wise min","title":"friend min"},{"location":"Classes/classdakku_1_1VectorBase/#friend-distance","text":"friend decltype ( auto ) distance ( const D & a , const D & b ); the distance","title":"friend distance"},{"location":"Classes/classdakku_1_1VectorBase/#friend-abs","text":"friend D abs ( const D & v ); abs","title":"friend abs"},{"location":"Classes/classdakku_1_1VectorBase/#friend-sqrt","text":"friend D sqrt ( const D & v ); element-wise sqrt","title":"friend sqrt"},{"location":"Classes/classdakku_1_1VectorBase/#friend-pow","text":"friend D pow ( const D & v , E e ); element-wise power","title":"friend pow"},{"location":"Classes/classdakku_1_1VectorBase/#friend-exp","text":"friend D exp ( const D & v ); element-wise exp","title":"friend exp"},{"location":"Classes/classdakku_1_1VectorBase/#friend-floor","text":"friend D floor ( const D & v ); element-wise floor","title":"friend floor"},{"location":"Classes/classdakku_1_1VectorBase/#friend-ceil","text":"friend D ceil ( const D & v ); element-wise ceil","title":"friend ceil"},{"location":"Classes/classdakku_1_1VectorBase/#friend-lerp","text":"friend D lerp ( const D & a , const D & b , T t ); element-wise linear interpolation Updated on 2022-04-25 at 08:42:24 +0000","title":"friend lerp"},{"location":"Examples/","text":"Examples Updated on 2022-04-25 at 08:42:24 +0000","title":"Examples"},{"location":"Examples/#examples","text":"Updated on 2022-04-25 at 08:42:24 +0000","title":"Examples"},{"location":"Files/","text":"Files dir src file src/platform.h dir src/core file src/core/constants.h file src/core/fwd.h file src/core/logger.h file src/core/lua.h file src/core/math_func.h file src/core/vector.h file src/core/vector_base.h Updated on 2022-04-25 at 08:42:24 +0000","title":"Files"},{"location":"Files/#files","text":"dir src file src/platform.h dir src/core file src/core/constants.h file src/core/fwd.h file src/core/logger.h file src/core/lua.h file src/core/math_func.h file src/core/vector.h file src/core/vector_base.h Updated on 2022-04-25 at 08:42:24 +0000","title":"Files"},{"location":"Files/constants_8h/","text":"src/core/constants.h Namespaces Name dakku dakku namespace Source code #ifndef DAKKU_CORE_CONSTANTS_H_ #define DAKKU_CORE_CONSTANTS_H_ #include <core/fwd.h> namespace dakku {} #endif Updated on 2022-04-25 at 08:42:24 +0000","title":"src/core/constants.h"},{"location":"Files/constants_8h/#srccoreconstantsh","text":"","title":"src/core/constants.h"},{"location":"Files/constants_8h/#namespaces","text":"Name dakku dakku namespace","title":"Namespaces"},{"location":"Files/constants_8h/#source-code","text":"#ifndef DAKKU_CORE_CONSTANTS_H_ #define DAKKU_CORE_CONSTANTS_H_ #include <core/fwd.h> namespace dakku {} #endif Updated on 2022-04-25 at 08:42:24 +0000","title":"Source code"},{"location":"Files/dir_68267d1309a1af8e8297ef4c3efbcdba/","text":"src Directories Name src/core Files Name src/platform.h Updated on 2022-04-25 at 08:42:24 +0000","title":"src"},{"location":"Files/dir_68267d1309a1af8e8297ef4c3efbcdba/#src","text":"","title":"src"},{"location":"Files/dir_68267d1309a1af8e8297ef4c3efbcdba/#directories","text":"Name src/core","title":"Directories"},{"location":"Files/dir_68267d1309a1af8e8297ef4c3efbcdba/#files","text":"Name src/platform.h Updated on 2022-04-25 at 08:42:24 +0000","title":"Files"},{"location":"Files/dir_aebb8dcc11953d78e620bbef0b9e2183/","text":"src/core Files Name src/core/constants.h src/core/fwd.h src/core/logger.h src/core/lua.h src/core/math_func.h src/core/vector.h src/core/vector_base.h Updated on 2022-04-25 at 08:42:24 +0000","title":"src/core"},{"location":"Files/dir_aebb8dcc11953d78e620bbef0b9e2183/#srccore","text":"","title":"src/core"},{"location":"Files/dir_aebb8dcc11953d78e620bbef0b9e2183/#files","text":"Name src/core/constants.h src/core/fwd.h src/core/logger.h src/core/lua.h src/core/math_func.h src/core/vector.h src/core/vector_base.h Updated on 2022-04-25 at 08:42:24 +0000","title":"Files"},{"location":"Files/fwd_8h/","text":"src/core/fwd.h Namespaces Name dakku dakku namespace Defines Name DAKKU_EXPORT_CORE Macros Documentation define DAKKU_EXPORT_CORE #define DAKKU_EXPORT_CORE DAKKU_EXPORT Source code #ifndef DAKKU_CORE_FWD_H_ #define DAKKU_CORE_FWD_H_ #include <platform.h> #include <type_traits> namespace dakku { #if DAKKU_BUILD_MODULE != DAKKU_CORE_MODULE #define DAKKU_EXPORT_CORE DAKKU_IMPORT #else #define DAKKU_EXPORT_CORE DAKKU_EXPORT #endif template < typename T > concept ArithmeticType = std :: is_arithmetic_v < std :: decay_t < T >> ; } // namespace dakku #endif Updated on 2022-04-25 at 08:42:24 +0000","title":"src/core/fwd.h"},{"location":"Files/fwd_8h/#srccorefwdh","text":"","title":"src/core/fwd.h"},{"location":"Files/fwd_8h/#namespaces","text":"Name dakku dakku namespace","title":"Namespaces"},{"location":"Files/fwd_8h/#defines","text":"Name DAKKU_EXPORT_CORE","title":"Defines"},{"location":"Files/fwd_8h/#macros-documentation","text":"","title":"Macros Documentation"},{"location":"Files/fwd_8h/#define-dakku_export_core","text":"#define DAKKU_EXPORT_CORE DAKKU_EXPORT","title":"define DAKKU_EXPORT_CORE"},{"location":"Files/fwd_8h/#source-code","text":"#ifndef DAKKU_CORE_FWD_H_ #define DAKKU_CORE_FWD_H_ #include <platform.h> #include <type_traits> namespace dakku { #if DAKKU_BUILD_MODULE != DAKKU_CORE_MODULE #define DAKKU_EXPORT_CORE DAKKU_IMPORT #else #define DAKKU_EXPORT_CORE DAKKU_EXPORT #endif template < typename T > concept ArithmeticType = std :: is_arithmetic_v < std :: decay_t < T >> ; } // namespace dakku #endif Updated on 2022-04-25 at 08:42:24 +0000","title":"Source code"},{"location":"Files/logger_8h/","text":"src/core/logger.h Namespaces Name dakku dakku namespace Classes Name class dakku::Logger logger class Defines Name DAKKU_ERR (...) log error message DAKKU_INFO (...) log info message DAKKU_WARN (...) log warning message DAKKU_DEBUG (...) log debug message DAKKU_CHECK (...) check whether the condition val is true, if not log error messages Macros Documentation define DAKKU_ERR #define DAKKU_ERR( ... ) SPDLOG_LOGGER_CALL ( Logger :: get (). handle (), spdlog :: level :: err , __VA_ARGS__ ) log error message define DAKKU_INFO #define DAKKU_INFO( ... ) SPDLOG_LOGGER_CALL ( Logger :: get (). handle (), spdlog :: level :: info , __VA_ARGS__ ) log info message define DAKKU_WARN #define DAKKU_WARN( ... ) SPDLOG_LOGGER_CALL ( Logger :: get (). handle (), spdlog :: level :: warn , __VA_ARGS__ ) log warning message define DAKKU_DEBUG #define DAKKU_DEBUG( ... ) static_cast < void > ( 0 ) log debug message define DAKKU_CHECK #define DAKKU_CHECK( ... ) static_cast < void > ( 0 ) check whether the condition val is true, if not log error messages Source code #ifndef DAKKU_CORE_LOGGER_H_ #define DAKKU_CORE_LOGGER_H_ #include <core/fwd.h> #include <memory> #include <spdlog/spdlog.h> #include <spdlog/fmt/ostr.h> namespace dakku { class DAKKU_EXPORT_CORE Logger { public : static const Logger & get (); [[ nodiscard ]] spdlog :: logger * handle () const { return _logger . get (); } private : explicit Logger ( std :: shared_ptr < spdlog :: logger > _logger ); std :: shared_ptr < spdlog :: logger > _logger ; }; #define DAKKU_ERR(...) \\ SPDLOG_LOGGER_CALL(Logger::get().handle(), spdlog::level::err, __VA_ARGS__) #define DAKKU_INFO(...) \\ SPDLOG_LOGGER_CALL(Logger::get().handle(), spdlog::level::info, __VA_ARGS__) #define DAKKU_WARN(...) \\ SPDLOG_LOGGER_CALL(Logger::get().handle(), spdlog::level::warn, __VA_ARGS__) #ifdef DAKKU_BUILD_DEBUG #define DAKKU_DEBUG(...) \\ SPDLOG_LOGGER_CALL(Logger::get().handle(), spdlog::level::debug, __VA_ARGS__) #else #define DAKKU_DEBUG(...) static_cast<void>(0) #endif #ifdef DAKKU_BUILD_CHECK #define DAKKU_CHECK(val, ...) \\ do { \\ if (!(val)) { \\ DAKKU_ERR(__VA_ARGS__); \\ std::exit(-1); \\ } \\ } while (0) #else #define DAKKU_CHECK(...) static_cast<void>(0) #endif } // namespace dakku #endif Updated on 2022-04-25 at 08:42:24 +0000","title":"src/core/logger.h"},{"location":"Files/logger_8h/#srccoreloggerh","text":"","title":"src/core/logger.h"},{"location":"Files/logger_8h/#namespaces","text":"Name dakku dakku namespace","title":"Namespaces"},{"location":"Files/logger_8h/#classes","text":"Name class dakku::Logger logger class","title":"Classes"},{"location":"Files/logger_8h/#defines","text":"Name DAKKU_ERR (...) log error message DAKKU_INFO (...) log info message DAKKU_WARN (...) log warning message DAKKU_DEBUG (...) log debug message DAKKU_CHECK (...) check whether the condition val is true, if not log error messages","title":"Defines"},{"location":"Files/logger_8h/#macros-documentation","text":"","title":"Macros Documentation"},{"location":"Files/logger_8h/#define-dakku_err","text":"#define DAKKU_ERR( ... ) SPDLOG_LOGGER_CALL ( Logger :: get (). handle (), spdlog :: level :: err , __VA_ARGS__ ) log error message","title":"define DAKKU_ERR"},{"location":"Files/logger_8h/#define-dakku_info","text":"#define DAKKU_INFO( ... ) SPDLOG_LOGGER_CALL ( Logger :: get (). handle (), spdlog :: level :: info , __VA_ARGS__ ) log info message","title":"define DAKKU_INFO"},{"location":"Files/logger_8h/#define-dakku_warn","text":"#define DAKKU_WARN( ... ) SPDLOG_LOGGER_CALL ( Logger :: get (). handle (), spdlog :: level :: warn , __VA_ARGS__ ) log warning message","title":"define DAKKU_WARN"},{"location":"Files/logger_8h/#define-dakku_debug","text":"#define DAKKU_DEBUG( ... ) static_cast < void > ( 0 ) log debug message","title":"define DAKKU_DEBUG"},{"location":"Files/logger_8h/#define-dakku_check","text":"#define DAKKU_CHECK( ... ) static_cast < void > ( 0 ) check whether the condition val is true, if not log error messages","title":"define DAKKU_CHECK"},{"location":"Files/logger_8h/#source-code","text":"#ifndef DAKKU_CORE_LOGGER_H_ #define DAKKU_CORE_LOGGER_H_ #include <core/fwd.h> #include <memory> #include <spdlog/spdlog.h> #include <spdlog/fmt/ostr.h> namespace dakku { class DAKKU_EXPORT_CORE Logger { public : static const Logger & get (); [[ nodiscard ]] spdlog :: logger * handle () const { return _logger . get (); } private : explicit Logger ( std :: shared_ptr < spdlog :: logger > _logger ); std :: shared_ptr < spdlog :: logger > _logger ; }; #define DAKKU_ERR(...) \\ SPDLOG_LOGGER_CALL(Logger::get().handle(), spdlog::level::err, __VA_ARGS__) #define DAKKU_INFO(...) \\ SPDLOG_LOGGER_CALL(Logger::get().handle(), spdlog::level::info, __VA_ARGS__) #define DAKKU_WARN(...) \\ SPDLOG_LOGGER_CALL(Logger::get().handle(), spdlog::level::warn, __VA_ARGS__) #ifdef DAKKU_BUILD_DEBUG #define DAKKU_DEBUG(...) \\ SPDLOG_LOGGER_CALL(Logger::get().handle(), spdlog::level::debug, __VA_ARGS__) #else #define DAKKU_DEBUG(...) static_cast<void>(0) #endif #ifdef DAKKU_BUILD_CHECK #define DAKKU_CHECK(val, ...) \\ do { \\ if (!(val)) { \\ DAKKU_ERR(__VA_ARGS__); \\ std::exit(-1); \\ } \\ } while (0) #else #define DAKKU_CHECK(...) static_cast<void>(0) #endif } // namespace dakku #endif Updated on 2022-04-25 at 08:42:24 +0000","title":"Source code"},{"location":"Files/lua_8h/","text":"src/core/lua.h Namespaces Name dakku dakku namespace Classes Name class dakku::Lua dakku lua state Defines Name SOL_ALL_SAFETIES_ON DAKKU_DECLARE_LUA_OBJECT (name) DAKKU_IMPLEMENT_LUA_OBJECT (name, func) Macros Documentation define SOL_ALL_SAFETIES_ON #define SOL_ALL_SAFETIES_ON 1 define DAKKU_DECLARE_LUA_OBJECT #define DAKKU_DECLARE_LUA_OBJECT( name ) static int _ ## name ## _bind_lua define DAKKU_IMPLEMENT_LUA_OBJECT #define DAKKU_IMPLEMENT_LUA_OBJECT( name , func ) int name :: _ ## name ## _bind_lua = ( func )() Source code #ifndef DAKKU_CORE_LUA_H_ #define DAKKU_CORE_LUA_H_ #include <core/fwd.h> #if !defined(SOL_ALL_SAFETIES_ON) #define SOL_ALL_SAFETIES_ON 1 #endif #include <sol/sol.hpp> namespace dakku { class DAKKU_EXPORT_CORE Lua { public : static Lua & instance (); sol :: state & get_state (); private : sol :: state state ; }; #define DAKKU_DECLARE_LUA_OBJECT(name) static int _##name##_bind_lua #define DAKKU_IMPLEMENT_LUA_OBJECT(name, func) \\ int name::_##name##_bind_lua = (func)() } // namespace dakku #endif Updated on 2022-04-25 at 08:42:24 +0000","title":"src/core/lua.h"},{"location":"Files/lua_8h/#srccoreluah","text":"","title":"src/core/lua.h"},{"location":"Files/lua_8h/#namespaces","text":"Name dakku dakku namespace","title":"Namespaces"},{"location":"Files/lua_8h/#classes","text":"Name class dakku::Lua dakku lua state","title":"Classes"},{"location":"Files/lua_8h/#defines","text":"Name SOL_ALL_SAFETIES_ON DAKKU_DECLARE_LUA_OBJECT (name) DAKKU_IMPLEMENT_LUA_OBJECT (name, func)","title":"Defines"},{"location":"Files/lua_8h/#macros-documentation","text":"","title":"Macros Documentation"},{"location":"Files/lua_8h/#define-sol_all_safeties_on","text":"#define SOL_ALL_SAFETIES_ON 1","title":"define SOL_ALL_SAFETIES_ON"},{"location":"Files/lua_8h/#define-dakku_declare_lua_object","text":"#define DAKKU_DECLARE_LUA_OBJECT( name ) static int _ ## name ## _bind_lua","title":"define DAKKU_DECLARE_LUA_OBJECT"},{"location":"Files/lua_8h/#define-dakku_implement_lua_object","text":"#define DAKKU_IMPLEMENT_LUA_OBJECT( name , func ) int name :: _ ## name ## _bind_lua = ( func )()","title":"define DAKKU_IMPLEMENT_LUA_OBJECT"},{"location":"Files/lua_8h/#source-code","text":"#ifndef DAKKU_CORE_LUA_H_ #define DAKKU_CORE_LUA_H_ #include <core/fwd.h> #if !defined(SOL_ALL_SAFETIES_ON) #define SOL_ALL_SAFETIES_ON 1 #endif #include <sol/sol.hpp> namespace dakku { class DAKKU_EXPORT_CORE Lua { public : static Lua & instance (); sol :: state & get_state (); private : sol :: state state ; }; #define DAKKU_DECLARE_LUA_OBJECT(name) static int _##name##_bind_lua #define DAKKU_IMPLEMENT_LUA_OBJECT(name, func) \\ int name::_##name##_bind_lua = (func)() } // namespace dakku #endif Updated on 2022-04-25 at 08:42:24 +0000","title":"Source code"},{"location":"Files/math__func_8h/","text":"src/core/math_func.h Namespaces Name dakku dakku namespace Source code #ifndef DAKKU_CORE_MATH_FUNC_H_ #define DAKKU_CORE_MATH_FUNC_H_ #include <core/fwd.h> #include <cmath> namespace dakku { template < typename T > requires std :: is_floating_point_v < T > DAKKU_INLINE bool isnan ( T x ) { return std :: isnan ( x ); } template < typename T > requires std :: is_integral_v < T > DAKKU_INLINE bool isnan ( T ) { return false ; } } // namespace dakku #endif Updated on 2022-04-25 at 08:42:24 +0000","title":"src/core/math_func.h"},{"location":"Files/math__func_8h/#srccoremath_funch","text":"","title":"src/core/math_func.h"},{"location":"Files/math__func_8h/#namespaces","text":"Name dakku dakku namespace","title":"Namespaces"},{"location":"Files/math__func_8h/#source-code","text":"#ifndef DAKKU_CORE_MATH_FUNC_H_ #define DAKKU_CORE_MATH_FUNC_H_ #include <core/fwd.h> #include <cmath> namespace dakku { template < typename T > requires std :: is_floating_point_v < T > DAKKU_INLINE bool isnan ( T x ) { return std :: isnan ( x ); } template < typename T > requires std :: is_integral_v < T > DAKKU_INLINE bool isnan ( T ) { return false ; } } // namespace dakku #endif Updated on 2022-04-25 at 08:42:24 +0000","title":"Source code"},{"location":"Files/platform_8h/","text":"src/platform.h Namespaces Name dakku dakku namespace Defines Name DAKKU_INLINE DAKKU_EXPORT DAKKU_IMPORT DAKKU_CORE_MODULE dakku core module DAKKU_MAIN_MODULE dakku main module Macros Documentation define DAKKU_INLINE #define DAKKU_INLINE __attribute__((always_inline)) inline define DAKKU_EXPORT #define DAKKU_EXPORT __attribute__((visibility(\"default\"))) define DAKKU_IMPORT #define DAKKU_IMPORT define DAKKU_CORE_MODULE #define DAKKU_CORE_MODULE 1 dakku core module define DAKKU_MAIN_MODULE #define DAKKU_MAIN_MODULE 10 dakku main module Source code #ifndef DAKKU_PLATFORM_H_ #define DAKKU_PLATFORM_H_ #if defined(_MSC_VER) #if !defined(_USE_MATH_DEFINES) && !defined(M_PI) #define _USE_MATH_DEFINES #endif #endif namespace dakku { #if defined(_MSC_VER) #define DAKKU_INLINE __forceinline #define DAKKU_EXPORT __declspec(dllexport) #define DAKKU_IMPORT __declspec(dllimport) #else #define DAKKU_INLINE __attribute__((always_inline)) inline #define DAKKU_EXPORT __attribute__((visibility(\"default\"))) #define DAKKU_IMPORT #endif #define DAKKU_CORE_MODULE 1 #define DAKKU_MAIN_MODULE 10 #if defined(_MSC_VER) #pragma warning(disable : 4251) #endif } // namespace dakku #endif Updated on 2022-04-25 at 08:42:24 +0000","title":"src/platform.h"},{"location":"Files/platform_8h/#srcplatformh","text":"","title":"src/platform.h"},{"location":"Files/platform_8h/#namespaces","text":"Name dakku dakku namespace","title":"Namespaces"},{"location":"Files/platform_8h/#defines","text":"Name DAKKU_INLINE DAKKU_EXPORT DAKKU_IMPORT DAKKU_CORE_MODULE dakku core module DAKKU_MAIN_MODULE dakku main module","title":"Defines"},{"location":"Files/platform_8h/#macros-documentation","text":"","title":"Macros Documentation"},{"location":"Files/platform_8h/#define-dakku_inline","text":"#define DAKKU_INLINE __attribute__((always_inline)) inline","title":"define DAKKU_INLINE"},{"location":"Files/platform_8h/#define-dakku_export","text":"#define DAKKU_EXPORT __attribute__((visibility(\"default\")))","title":"define DAKKU_EXPORT"},{"location":"Files/platform_8h/#define-dakku_import","text":"#define DAKKU_IMPORT","title":"define DAKKU_IMPORT"},{"location":"Files/platform_8h/#define-dakku_core_module","text":"#define DAKKU_CORE_MODULE 1 dakku core module","title":"define DAKKU_CORE_MODULE"},{"location":"Files/platform_8h/#define-dakku_main_module","text":"#define DAKKU_MAIN_MODULE 10 dakku main module","title":"define DAKKU_MAIN_MODULE"},{"location":"Files/platform_8h/#source-code","text":"#ifndef DAKKU_PLATFORM_H_ #define DAKKU_PLATFORM_H_ #if defined(_MSC_VER) #if !defined(_USE_MATH_DEFINES) && !defined(M_PI) #define _USE_MATH_DEFINES #endif #endif namespace dakku { #if defined(_MSC_VER) #define DAKKU_INLINE __forceinline #define DAKKU_EXPORT __declspec(dllexport) #define DAKKU_IMPORT __declspec(dllimport) #else #define DAKKU_INLINE __attribute__((always_inline)) inline #define DAKKU_EXPORT __attribute__((visibility(\"default\"))) #define DAKKU_IMPORT #endif #define DAKKU_CORE_MODULE 1 #define DAKKU_MAIN_MODULE 10 #if defined(_MSC_VER) #pragma warning(disable : 4251) #endif } // namespace dakku #endif Updated on 2022-04-25 at 08:42:24 +0000","title":"Source code"},{"location":"Files/vector_8h/","text":"src/core/vector.h Namespaces Name dakku dakku namespace Classes Name class dakku::Vector vector class dakku::Point point class dakku::Normal normal Defines Name DAKKU_DECLARE_VECTOR_TYPE (name, base, T, S) DAKKU_DECLARE_POINT_TYPE (name, base, T, S, vector_type) Macros Documentation define DAKKU_DECLARE_VECTOR_TYPE #define DAKKU_DECLARE_VECTOR_TYPE( name , base , T , S ) class DAKKU_EXPORT_CORE name : public base < T , S , name > { \\ public : \\ using base < T , S , name >:: base ; \\ \\ private : \\ DAKKU_DECLARE_LUA_OBJECT ( name ); \\ } define DAKKU_DECLARE_POINT_TYPE #define DAKKU_DECLARE_POINT_TYPE( name , base , T , S , vector_type ) class DAKKU_EXPORT_CORE name : public base < T , S , name > { \\ public : \\ using base < T , S , name >:: base ; \\ name operator - () const { \\ name ret = * this ; \\ for ( size_t i = 0 ; i < size (); ++ i ) ret [ i ] = - ret [ i ]; \\ return ret ; \\ } \\ template < ArithmeticType V > \\ name operator - ( V rhs ) const { \\ name ret = * this ; \\ ret -= rhs ; \\ return ret ; \\ } \\ vector_type operator - ( const name & rhs ) const { \\ name ret = * this ; \\ ret -= rhs ; \\ return vector_type { ret }; \\ } \\ name operator - ( const vector_type & rhs ) const { \\ name ret = * this ; \\ ret -= name ( rhs ); \\ return ret ; \\ } \\ \\ private : \\ DAKKU_DECLARE_LUA_OBJECT ( name ); \\ } Source code #ifndef DAKKU_CORE_VECTOR_H_ #define DAKKU_CORE_VECTOR_H_ #include <core/vector_base.h> #include <core/lua.h> namespace dakku { template < typename T , size_t S , typename D > class DAKKU_EXPORT_CORE Vector : public VectorBase < T , S , D > { public : using VectorBase < T , S , D >:: VectorBase ; D operator - () const { D ret = this -> derived (); for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = - ret [ i ]; return ret ; } D operator - ( const D & rhs ) const { D ret = this -> derived (); ret -= rhs ; return ret ; } template < ArithmeticType V > D operator - ( V rhs ) const { D ret = this -> derived (); ret -= rhs ; return ret ; } }; #define DAKKU_DECLARE_VECTOR_TYPE(name, base, T, S) \\ class DAKKU_EXPORT_CORE name : public base<T, S, name> { \\ public: \\ using base<T, S, name>::base; \\ \\ private: \\ DAKKU_DECLARE_LUA_OBJECT(name); \\ } DAKKU_DECLARE_VECTOR_TYPE ( Vector2i , Vector , int , 2 ); DAKKU_DECLARE_VECTOR_TYPE ( Vector2f , Vector , float , 2 ); DAKKU_DECLARE_VECTOR_TYPE ( Vector3i , Vector , int , 3 ); DAKKU_DECLARE_VECTOR_TYPE ( Vector3f , Vector , float , 3 ); template < typename T , size_t S , typename D > class DAKKU_EXPORT_CORE Point : public VectorBase < T , S , D > { public : using VectorBase < T , S , D >:: VectorBase ; }; #define DAKKU_DECLARE_POINT_TYPE(name, base, T, S, vector_type) \\ class DAKKU_EXPORT_CORE name : public base<T, S, name> { \\ public: \\ using base<T, S, name>::base; \\ name operator-() const { \\ name ret = *this; \\ for (size_t i = 0; i < size(); ++i) ret[i] = -ret[i]; \\ return ret; \\ } \\ template <ArithmeticType V> \\ name operator-(V rhs) const { \\ name ret = *this; \\ ret -= rhs; \\ return ret; \\ } \\ vector_type operator-(const name &rhs) const { \\ name ret = *this; \\ ret -= rhs; \\ return vector_type{ret}; \\ } \\ name operator-(const vector_type &rhs) const { \\ name ret = *this; \\ ret -= name(rhs); \\ return ret; \\ } \\ \\ private: \\ DAKKU_DECLARE_LUA_OBJECT(name); \\ } DAKKU_DECLARE_POINT_TYPE ( Point3f , Point , float , 3 , Vector3f ); DAKKU_DECLARE_POINT_TYPE ( Point3i , Point , int , 3 , Vector3i ); DAKKU_DECLARE_POINT_TYPE ( Point2f , Point , float , 2 , Vector2f ); DAKKU_DECLARE_POINT_TYPE ( Point2i , Point , int , 2 , Vector2i ); template < typename T , size_t S , typename D > class DAKKU_EXPORT_CORE Normal : public VectorBase < T , S , D > { public : using VectorBase < T , S , D >:: VectorBase ; D operator - () const { D ret = this -> derived (); for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = - ret [ i ]; return ret ; } D operator - ( const D & rhs ) const { D ret = this -> derived (); ret -= rhs ; return ret ; } template < ArithmeticType V > D operator - ( V rhs ) const { D ret = this -> derived (); ret -= rhs ; return ret ; } }; DAKKU_DECLARE_VECTOR_TYPE ( Normal3f , Normal , float , 3 ); } // namespace dakku #endif Updated on 2022-04-25 at 08:42:24 +0000","title":"src/core/vector.h"},{"location":"Files/vector_8h/#srccorevectorh","text":"","title":"src/core/vector.h"},{"location":"Files/vector_8h/#namespaces","text":"Name dakku dakku namespace","title":"Namespaces"},{"location":"Files/vector_8h/#classes","text":"Name class dakku::Vector vector class dakku::Point point class dakku::Normal normal","title":"Classes"},{"location":"Files/vector_8h/#defines","text":"Name DAKKU_DECLARE_VECTOR_TYPE (name, base, T, S) DAKKU_DECLARE_POINT_TYPE (name, base, T, S, vector_type)","title":"Defines"},{"location":"Files/vector_8h/#macros-documentation","text":"","title":"Macros Documentation"},{"location":"Files/vector_8h/#define-dakku_declare_vector_type","text":"#define DAKKU_DECLARE_VECTOR_TYPE( name , base , T , S ) class DAKKU_EXPORT_CORE name : public base < T , S , name > { \\ public : \\ using base < T , S , name >:: base ; \\ \\ private : \\ DAKKU_DECLARE_LUA_OBJECT ( name ); \\ }","title":"define DAKKU_DECLARE_VECTOR_TYPE"},{"location":"Files/vector_8h/#define-dakku_declare_point_type","text":"#define DAKKU_DECLARE_POINT_TYPE( name , base , T , S , vector_type ) class DAKKU_EXPORT_CORE name : public base < T , S , name > { \\ public : \\ using base < T , S , name >:: base ; \\ name operator - () const { \\ name ret = * this ; \\ for ( size_t i = 0 ; i < size (); ++ i ) ret [ i ] = - ret [ i ]; \\ return ret ; \\ } \\ template < ArithmeticType V > \\ name operator - ( V rhs ) const { \\ name ret = * this ; \\ ret -= rhs ; \\ return ret ; \\ } \\ vector_type operator - ( const name & rhs ) const { \\ name ret = * this ; \\ ret -= rhs ; \\ return vector_type { ret }; \\ } \\ name operator - ( const vector_type & rhs ) const { \\ name ret = * this ; \\ ret -= name ( rhs ); \\ return ret ; \\ } \\ \\ private : \\ DAKKU_DECLARE_LUA_OBJECT ( name ); \\ }","title":"define DAKKU_DECLARE_POINT_TYPE"},{"location":"Files/vector_8h/#source-code","text":"#ifndef DAKKU_CORE_VECTOR_H_ #define DAKKU_CORE_VECTOR_H_ #include <core/vector_base.h> #include <core/lua.h> namespace dakku { template < typename T , size_t S , typename D > class DAKKU_EXPORT_CORE Vector : public VectorBase < T , S , D > { public : using VectorBase < T , S , D >:: VectorBase ; D operator - () const { D ret = this -> derived (); for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = - ret [ i ]; return ret ; } D operator - ( const D & rhs ) const { D ret = this -> derived (); ret -= rhs ; return ret ; } template < ArithmeticType V > D operator - ( V rhs ) const { D ret = this -> derived (); ret -= rhs ; return ret ; } }; #define DAKKU_DECLARE_VECTOR_TYPE(name, base, T, S) \\ class DAKKU_EXPORT_CORE name : public base<T, S, name> { \\ public: \\ using base<T, S, name>::base; \\ \\ private: \\ DAKKU_DECLARE_LUA_OBJECT(name); \\ } DAKKU_DECLARE_VECTOR_TYPE ( Vector2i , Vector , int , 2 ); DAKKU_DECLARE_VECTOR_TYPE ( Vector2f , Vector , float , 2 ); DAKKU_DECLARE_VECTOR_TYPE ( Vector3i , Vector , int , 3 ); DAKKU_DECLARE_VECTOR_TYPE ( Vector3f , Vector , float , 3 ); template < typename T , size_t S , typename D > class DAKKU_EXPORT_CORE Point : public VectorBase < T , S , D > { public : using VectorBase < T , S , D >:: VectorBase ; }; #define DAKKU_DECLARE_POINT_TYPE(name, base, T, S, vector_type) \\ class DAKKU_EXPORT_CORE name : public base<T, S, name> { \\ public: \\ using base<T, S, name>::base; \\ name operator-() const { \\ name ret = *this; \\ for (size_t i = 0; i < size(); ++i) ret[i] = -ret[i]; \\ return ret; \\ } \\ template <ArithmeticType V> \\ name operator-(V rhs) const { \\ name ret = *this; \\ ret -= rhs; \\ return ret; \\ } \\ vector_type operator-(const name &rhs) const { \\ name ret = *this; \\ ret -= rhs; \\ return vector_type{ret}; \\ } \\ name operator-(const vector_type &rhs) const { \\ name ret = *this; \\ ret -= name(rhs); \\ return ret; \\ } \\ \\ private: \\ DAKKU_DECLARE_LUA_OBJECT(name); \\ } DAKKU_DECLARE_POINT_TYPE ( Point3f , Point , float , 3 , Vector3f ); DAKKU_DECLARE_POINT_TYPE ( Point3i , Point , int , 3 , Vector3i ); DAKKU_DECLARE_POINT_TYPE ( Point2f , Point , float , 2 , Vector2f ); DAKKU_DECLARE_POINT_TYPE ( Point2i , Point , int , 2 , Vector2i ); template < typename T , size_t S , typename D > class DAKKU_EXPORT_CORE Normal : public VectorBase < T , S , D > { public : using VectorBase < T , S , D >:: VectorBase ; D operator - () const { D ret = this -> derived (); for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = - ret [ i ]; return ret ; } D operator - ( const D & rhs ) const { D ret = this -> derived (); ret -= rhs ; return ret ; } template < ArithmeticType V > D operator - ( V rhs ) const { D ret = this -> derived (); ret -= rhs ; return ret ; } }; DAKKU_DECLARE_VECTOR_TYPE ( Normal3f , Normal , float , 3 ); } // namespace dakku #endif Updated on 2022-04-25 at 08:42:24 +0000","title":"Source code"},{"location":"Files/vector__base_8h/","text":"src/core/vector_base.h Namespaces Name dakku dakku namespace Classes Name class dakku::VectorBase vector base Source code #ifndef DAKKU_CORE_VECTOR_BASE_H_ #define DAKKU_CORE_VECTOR_BASE_H_ #include <core/logger.h> #include <core/lua.h> #include <array> #include <numeric> #include <span> namespace dakku { template < ArithmeticType T , size_t S , typename D > class DAKKU_EXPORT_CORE VectorBase { public : VectorBase () : _data () {} template < ArithmeticType Arg > VectorBase ( Arg value ) { set ( value ); DAKKU_CHECK ( ! has_nans (), \"has nan\" ); } VectorBase ( const sol :: table & table ) { for ( size_t i = 0 ; i < S ; ++ i ) _data [ i ] = table . get_or ( i + 1 , T { 0 }); DAKKU_CHECK ( ! has_nans (), \"has nan\" ); } template < ArithmeticType ... Args > requires ( sizeof ...( Args ) == S ) VectorBase ( Args && ... args ) { set ( std :: forward < Args > ( args )...); } template < ArithmeticType Other , typename OtherDerived > explicit VectorBase ( const VectorBase < Other , S , OtherDerived > & other ) { set ( other ); DAKKU_CHECK ( ! has_nans (), \"has nan\" ); } VectorBase ( const VectorBase & other ) : _data ( other . _data ) { DAKKU_CHECK ( ! has_nans (), \"has nan\" ); } VectorBase ( VectorBase && other ) noexcept : _data ( std :: move ( other . _data )) { DAKKU_CHECK ( ! has_nans (), \"has nan\" ); } VectorBase & operator = ( const VectorBase & other ) { if ( this == & other ) return * this ; _data = other . _data ; DAKKU_CHECK ( ! has_nans (), \"has nan\" ); return * this ; } VectorBase & operator = ( VectorBase && other ) noexcept { if ( this == & other ) return * this ; _data = std :: move ( other . _data ); DAKKU_CHECK ( ! has_nans (), \"has nan\" ); return * this ; } const D & derived () const { return static_cast < const D &> ( * this ); } D & derived () { return const_cast < D &> ( static_cast < const VectorBase &> ( * this ). derived ()); } template < ArithmeticType Arg > void set ( Arg value ) { _data . fill ( static_cast < T > ( value )); } template < ArithmeticType Arg > void set_by_index ( size_t index , Arg value ) { DAKKU_CHECK ( 0 <= index && index < S , \"index out of range: {} >= {}\" , index , S ); _data [ index ] = static_cast < T > ( value ); } template < ArithmeticType ... Args , size_t ... Is > requires ( sizeof ...( Args ) == S ) void set ( std :: index_sequence < Is ... > , Args && ... args ) { ( set_by_index ( Is , std :: forward < Args > ( args )), ...); } template < ArithmeticType ... Args > requires ( sizeof ...( Args ) == S ) void set ( Args && ... args ) { set ( std :: index_sequence_for < Args ... > {}, std :: forward < Args > ( args )...); } template < ArithmeticType Other , typename OtherDerived > void set ( const VectorBase < Other , S , OtherDerived > & rhs ) { for ( size_t i = 0 ; i < S ; ++ i ) _data [ i ] = static_cast < T > ( rhs [ i ]); } const T & get ( size_t i ) const { DAKKU_CHECK ( 0 <= i && i < S , \"index out of range {} >= {}\" , i , S ); return _data [ i ]; } [[ nodiscard ]] size_t size () const { return S ; } [[ nodiscard ]] std :: string to_string () const { std :: string ret { \"[\" }; for ( size_t i = 0 ; i < _data . size (); ++ i ) { ret += std :: to_string ( _data [ i ]); if ( i + 1 != _data . size ()) ret += \", \" ; } return ret + \"]\" ; } [[ nodiscard ]] bool has_nans () const { return std :: any_of ( std :: begin ( _data ), std :: end ( _data ), []( T x ) { return isnan ( x ); }); } D clone () const { return D { derived ()}; } const T & operator []( size_t i ) const { return _data [ i ]; } T & operator []( size_t i ) { return const_cast < T &> ( static_cast < const VectorBase &> ( * this )[ i ]); } D & operator += ( const D & rhs ) { for ( size_t i = 0 ; i < S ; ++ i ) _data [ i ] += rhs [ i ]; return derived (); } template < ArithmeticType V > D & operator += ( V rhs ) { for ( size_t i = 0 ; i < S ; ++ i ) _data [ i ] += rhs ; return derived (); } D operator + ( const D & rhs ) const { D ret = derived (); ret += rhs ; return ret ; } template < ArithmeticType V > D operator + ( V rhs ) const { D ret = derived (); ret += rhs ; return ret ; } template < ArithmeticType U > friend D operator + ( U a , const D & b ) { return b + a ; } D & operator -= ( const D & rhs ) { for ( size_t i = 0 ; i < S ; ++ i ) _data [ i ] -= rhs [ i ]; return derived (); } template < ArithmeticType V > D & operator -= ( V rhs ) { for ( size_t i = 0 ; i < S ; ++ i ) _data [ i ] -= rhs ; return derived (); } template < ArithmeticType U > friend D operator - ( U a , const D & b ) { D ret = - b ; ret += a ; return ret ; } D & operator *= ( const D & rhs ) { for ( size_t i = 0 ; i < S ; ++ i ) _data [ i ] *= rhs [ i ]; return derived (); } template < ArithmeticType V > D & operator *= ( V rhs ) { for ( size_t i = 0 ; i < S ; ++ i ) _data [ i ] *= rhs ; return derived (); } D operator * ( const D & rhs ) const { D ret = derived (); ret *= rhs ; return ret ; } template < ArithmeticType V > D operator * ( V rhs ) const { D ret = derived (); ret *= rhs ; return ret ; } template < ArithmeticType U > friend D operator * ( U a , const D & b ) { return b * a ; } D & operator /= ( const D & rhs ) { for ( size_t i = 0 ; i < S ; ++ i ) _data [ i ] /= rhs [ i ]; return derived (); } template < ArithmeticType V > D & operator /= ( V rhs ) { return derived () *= static_cast < T > ( T { 1 } / rhs ); } D operator / ( const D & rhs ) const { D ret = derived (); ret /= rhs ; return ret ; } template < ArithmeticType U > D operator / ( U rhs ) const { D ret = derived (); ret /= rhs ; return ret ; } template < ArithmeticType U > friend D operator / ( U a , const D & b ) { return D ( a ) / b ; } friend std :: ostream & operator << ( std :: ostream & os , const VectorBase & vec ) { return os << vec . to_string (); } bool operator == ( const VectorBase & rhs ) const { return _data == rhs . _data ; } bool operator != ( const VectorBase & rhs ) const { return _data != rhs . _data ; } decltype ( auto ) x () const { static_assert ( S >= 1 , \"not enough size to get x\" ); return _data [ 0 ]; } decltype ( auto ) x () { static_assert ( S >= 1 , \"not enough size to get x\" ); return _data [ 0 ]; } decltype ( auto ) y () const { static_assert ( S >= 2 , \"not enough size to get y\" ); return _data [ 1 ]; } decltype ( auto ) y () { static_assert ( S >= 2 , \"not enough size to get y\" ); return _data [ 1 ]; } decltype ( auto ) z () const { static_assert ( S >= 3 , \"not enough size to get z\" ); return _data [ 2 ]; } decltype ( auto ) z () { static_assert ( S >= 3 , \"not enough size to get w\" ); return _data [ 2 ]; } decltype ( auto ) w () const { static_assert ( S >= 4 , \"not enough size to get w\" ); return _data [ 3 ]; } decltype ( auto ) w () { static_assert ( S >= 4 , \"not enough size to get z\" ); return _data [ 3 ]; } [[ nodiscard ]] size_t max_element_index () const { return std :: distance ( _data . begin (), std :: max_element ( _data . begin (), _data . end ())); } decltype ( auto ) max_element () const { return _data [ max_element_index ()]; } friend D max ( const D & v1 , const D & v2 ) { D ret = v1 ; for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = std :: max ( ret [ i ], v2 [ i ]); return ret ; } D max ( const D & rhs ) const { return max ( derived (), rhs ); } friend D min ( const D & v1 , const D & v2 ) { D ret = v1 ; for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = std :: min ( ret [ i ], v2 [ i ]); return ret ; } D min ( const D & rhs ) const { return min ( derived (), rhs ); } template < typename OtherDerived > decltype ( auto ) dot ( const VectorBase < T , S , OtherDerived > & rhs ) const { return std :: inner_product ( _data . begin (), _data . end (), rhs . _data . begin (), T {}); } decltype ( auto ) squaredNorm () const { return this -> dot ( * this ); } decltype ( auto ) norm () const { return std :: sqrt ( squaredNorm ()); } decltype ( auto ) length () const { return norm (); } friend decltype ( auto ) distance ( const D & a , const D & b ) { return ( a - b ). length (); } decltype ( auto ) distance ( const D & rhs ) const { return distance ( derived (), rhs ); } friend D abs ( const D & v ) { D ret = v ; for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = std :: abs ( ret [ i ]); return ret ; } D abs () const { return abs ( derived ()); } D cross ( const D & rhs ) const { static_assert ( S == 3 , \"only 3d vector support cross product\" ); return D {( y () * rhs . z ()) - ( z () * rhs . y ()), ( z () * rhs . x ()) - ( x () * rhs . z ()), ( x () * rhs . y ()) - ( y () * rhs . x ())}; } [[ nodiscard ]] bool is_zero () const { return std :: all_of ( _data . begin (), _data . end (), []( const T & v ) { return v == 0 ; }); } friend D sqrt ( const D & v ) { D ret = v ; for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = static_cast < T > ( std :: sqrt ( ret [ i ])); return ret ; } D sqrt () const { return sqrt ( derived ()); } template < ArithmeticType E > friend D pow ( const D & v , E e ) { D ret = v ; for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = static_cast < T > ( std :: pow ( ret [ i ], e )); return ret ; } template < ArithmeticType E > D pow ( E e ) const { return pow ( derived (), e ); } friend D exp ( const D & v ) { D ret = v ; for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = static_cast < T > ( std :: exp ( ret [ i ])); return ret ; } D exp () const { return exp ( derived ()); } friend D floor ( const D & v ) { D ret = v ; for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = std :: floor ( ret [ i ]); return ret ; } D floor () const { return floor ( derived ()); } friend D ceil ( const D & v ) { D ret = v ; for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = std :: ceil ( ret [ i ]); return ret ; } D ceil () const { return ceil ( derived ()); } friend D lerp ( const D & a , const D & b , T t ) { D ret ; for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = std :: lerp ( a [ i ], b [ i ], t ); return ret ; } D lerp ( const D & b , T t ) const { return lerp ( derived (), b , t ); } operator std :: span < T , S > () { return std :: span { _data }; } operator std :: span < const T , S > () const { return std :: span { _data }; } private : std :: array < T , S > _data ; }; } // namespace dakku #endif Updated on 2022-04-25 at 08:42:24 +0000","title":"src/core/vector_base.h"},{"location":"Files/vector__base_8h/#srccorevector_baseh","text":"","title":"src/core/vector_base.h"},{"location":"Files/vector__base_8h/#namespaces","text":"Name dakku dakku namespace","title":"Namespaces"},{"location":"Files/vector__base_8h/#classes","text":"Name class dakku::VectorBase vector base","title":"Classes"},{"location":"Files/vector__base_8h/#source-code","text":"#ifndef DAKKU_CORE_VECTOR_BASE_H_ #define DAKKU_CORE_VECTOR_BASE_H_ #include <core/logger.h> #include <core/lua.h> #include <array> #include <numeric> #include <span> namespace dakku { template < ArithmeticType T , size_t S , typename D > class DAKKU_EXPORT_CORE VectorBase { public : VectorBase () : _data () {} template < ArithmeticType Arg > VectorBase ( Arg value ) { set ( value ); DAKKU_CHECK ( ! has_nans (), \"has nan\" ); } VectorBase ( const sol :: table & table ) { for ( size_t i = 0 ; i < S ; ++ i ) _data [ i ] = table . get_or ( i + 1 , T { 0 }); DAKKU_CHECK ( ! has_nans (), \"has nan\" ); } template < ArithmeticType ... Args > requires ( sizeof ...( Args ) == S ) VectorBase ( Args && ... args ) { set ( std :: forward < Args > ( args )...); } template < ArithmeticType Other , typename OtherDerived > explicit VectorBase ( const VectorBase < Other , S , OtherDerived > & other ) { set ( other ); DAKKU_CHECK ( ! has_nans (), \"has nan\" ); } VectorBase ( const VectorBase & other ) : _data ( other . _data ) { DAKKU_CHECK ( ! has_nans (), \"has nan\" ); } VectorBase ( VectorBase && other ) noexcept : _data ( std :: move ( other . _data )) { DAKKU_CHECK ( ! has_nans (), \"has nan\" ); } VectorBase & operator = ( const VectorBase & other ) { if ( this == & other ) return * this ; _data = other . _data ; DAKKU_CHECK ( ! has_nans (), \"has nan\" ); return * this ; } VectorBase & operator = ( VectorBase && other ) noexcept { if ( this == & other ) return * this ; _data = std :: move ( other . _data ); DAKKU_CHECK ( ! has_nans (), \"has nan\" ); return * this ; } const D & derived () const { return static_cast < const D &> ( * this ); } D & derived () { return const_cast < D &> ( static_cast < const VectorBase &> ( * this ). derived ()); } template < ArithmeticType Arg > void set ( Arg value ) { _data . fill ( static_cast < T > ( value )); } template < ArithmeticType Arg > void set_by_index ( size_t index , Arg value ) { DAKKU_CHECK ( 0 <= index && index < S , \"index out of range: {} >= {}\" , index , S ); _data [ index ] = static_cast < T > ( value ); } template < ArithmeticType ... Args , size_t ... Is > requires ( sizeof ...( Args ) == S ) void set ( std :: index_sequence < Is ... > , Args && ... args ) { ( set_by_index ( Is , std :: forward < Args > ( args )), ...); } template < ArithmeticType ... Args > requires ( sizeof ...( Args ) == S ) void set ( Args && ... args ) { set ( std :: index_sequence_for < Args ... > {}, std :: forward < Args > ( args )...); } template < ArithmeticType Other , typename OtherDerived > void set ( const VectorBase < Other , S , OtherDerived > & rhs ) { for ( size_t i = 0 ; i < S ; ++ i ) _data [ i ] = static_cast < T > ( rhs [ i ]); } const T & get ( size_t i ) const { DAKKU_CHECK ( 0 <= i && i < S , \"index out of range {} >= {}\" , i , S ); return _data [ i ]; } [[ nodiscard ]] size_t size () const { return S ; } [[ nodiscard ]] std :: string to_string () const { std :: string ret { \"[\" }; for ( size_t i = 0 ; i < _data . size (); ++ i ) { ret += std :: to_string ( _data [ i ]); if ( i + 1 != _data . size ()) ret += \", \" ; } return ret + \"]\" ; } [[ nodiscard ]] bool has_nans () const { return std :: any_of ( std :: begin ( _data ), std :: end ( _data ), []( T x ) { return isnan ( x ); }); } D clone () const { return D { derived ()}; } const T & operator []( size_t i ) const { return _data [ i ]; } T & operator []( size_t i ) { return const_cast < T &> ( static_cast < const VectorBase &> ( * this )[ i ]); } D & operator += ( const D & rhs ) { for ( size_t i = 0 ; i < S ; ++ i ) _data [ i ] += rhs [ i ]; return derived (); } template < ArithmeticType V > D & operator += ( V rhs ) { for ( size_t i = 0 ; i < S ; ++ i ) _data [ i ] += rhs ; return derived (); } D operator + ( const D & rhs ) const { D ret = derived (); ret += rhs ; return ret ; } template < ArithmeticType V > D operator + ( V rhs ) const { D ret = derived (); ret += rhs ; return ret ; } template < ArithmeticType U > friend D operator + ( U a , const D & b ) { return b + a ; } D & operator -= ( const D & rhs ) { for ( size_t i = 0 ; i < S ; ++ i ) _data [ i ] -= rhs [ i ]; return derived (); } template < ArithmeticType V > D & operator -= ( V rhs ) { for ( size_t i = 0 ; i < S ; ++ i ) _data [ i ] -= rhs ; return derived (); } template < ArithmeticType U > friend D operator - ( U a , const D & b ) { D ret = - b ; ret += a ; return ret ; } D & operator *= ( const D & rhs ) { for ( size_t i = 0 ; i < S ; ++ i ) _data [ i ] *= rhs [ i ]; return derived (); } template < ArithmeticType V > D & operator *= ( V rhs ) { for ( size_t i = 0 ; i < S ; ++ i ) _data [ i ] *= rhs ; return derived (); } D operator * ( const D & rhs ) const { D ret = derived (); ret *= rhs ; return ret ; } template < ArithmeticType V > D operator * ( V rhs ) const { D ret = derived (); ret *= rhs ; return ret ; } template < ArithmeticType U > friend D operator * ( U a , const D & b ) { return b * a ; } D & operator /= ( const D & rhs ) { for ( size_t i = 0 ; i < S ; ++ i ) _data [ i ] /= rhs [ i ]; return derived (); } template < ArithmeticType V > D & operator /= ( V rhs ) { return derived () *= static_cast < T > ( T { 1 } / rhs ); } D operator / ( const D & rhs ) const { D ret = derived (); ret /= rhs ; return ret ; } template < ArithmeticType U > D operator / ( U rhs ) const { D ret = derived (); ret /= rhs ; return ret ; } template < ArithmeticType U > friend D operator / ( U a , const D & b ) { return D ( a ) / b ; } friend std :: ostream & operator << ( std :: ostream & os , const VectorBase & vec ) { return os << vec . to_string (); } bool operator == ( const VectorBase & rhs ) const { return _data == rhs . _data ; } bool operator != ( const VectorBase & rhs ) const { return _data != rhs . _data ; } decltype ( auto ) x () const { static_assert ( S >= 1 , \"not enough size to get x\" ); return _data [ 0 ]; } decltype ( auto ) x () { static_assert ( S >= 1 , \"not enough size to get x\" ); return _data [ 0 ]; } decltype ( auto ) y () const { static_assert ( S >= 2 , \"not enough size to get y\" ); return _data [ 1 ]; } decltype ( auto ) y () { static_assert ( S >= 2 , \"not enough size to get y\" ); return _data [ 1 ]; } decltype ( auto ) z () const { static_assert ( S >= 3 , \"not enough size to get z\" ); return _data [ 2 ]; } decltype ( auto ) z () { static_assert ( S >= 3 , \"not enough size to get w\" ); return _data [ 2 ]; } decltype ( auto ) w () const { static_assert ( S >= 4 , \"not enough size to get w\" ); return _data [ 3 ]; } decltype ( auto ) w () { static_assert ( S >= 4 , \"not enough size to get z\" ); return _data [ 3 ]; } [[ nodiscard ]] size_t max_element_index () const { return std :: distance ( _data . begin (), std :: max_element ( _data . begin (), _data . end ())); } decltype ( auto ) max_element () const { return _data [ max_element_index ()]; } friend D max ( const D & v1 , const D & v2 ) { D ret = v1 ; for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = std :: max ( ret [ i ], v2 [ i ]); return ret ; } D max ( const D & rhs ) const { return max ( derived (), rhs ); } friend D min ( const D & v1 , const D & v2 ) { D ret = v1 ; for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = std :: min ( ret [ i ], v2 [ i ]); return ret ; } D min ( const D & rhs ) const { return min ( derived (), rhs ); } template < typename OtherDerived > decltype ( auto ) dot ( const VectorBase < T , S , OtherDerived > & rhs ) const { return std :: inner_product ( _data . begin (), _data . end (), rhs . _data . begin (), T {}); } decltype ( auto ) squaredNorm () const { return this -> dot ( * this ); } decltype ( auto ) norm () const { return std :: sqrt ( squaredNorm ()); } decltype ( auto ) length () const { return norm (); } friend decltype ( auto ) distance ( const D & a , const D & b ) { return ( a - b ). length (); } decltype ( auto ) distance ( const D & rhs ) const { return distance ( derived (), rhs ); } friend D abs ( const D & v ) { D ret = v ; for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = std :: abs ( ret [ i ]); return ret ; } D abs () const { return abs ( derived ()); } D cross ( const D & rhs ) const { static_assert ( S == 3 , \"only 3d vector support cross product\" ); return D {( y () * rhs . z ()) - ( z () * rhs . y ()), ( z () * rhs . x ()) - ( x () * rhs . z ()), ( x () * rhs . y ()) - ( y () * rhs . x ())}; } [[ nodiscard ]] bool is_zero () const { return std :: all_of ( _data . begin (), _data . end (), []( const T & v ) { return v == 0 ; }); } friend D sqrt ( const D & v ) { D ret = v ; for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = static_cast < T > ( std :: sqrt ( ret [ i ])); return ret ; } D sqrt () const { return sqrt ( derived ()); } template < ArithmeticType E > friend D pow ( const D & v , E e ) { D ret = v ; for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = static_cast < T > ( std :: pow ( ret [ i ], e )); return ret ; } template < ArithmeticType E > D pow ( E e ) const { return pow ( derived (), e ); } friend D exp ( const D & v ) { D ret = v ; for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = static_cast < T > ( std :: exp ( ret [ i ])); return ret ; } D exp () const { return exp ( derived ()); } friend D floor ( const D & v ) { D ret = v ; for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = std :: floor ( ret [ i ]); return ret ; } D floor () const { return floor ( derived ()); } friend D ceil ( const D & v ) { D ret = v ; for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = std :: ceil ( ret [ i ]); return ret ; } D ceil () const { return ceil ( derived ()); } friend D lerp ( const D & a , const D & b , T t ) { D ret ; for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = std :: lerp ( a [ i ], b [ i ], t ); return ret ; } D lerp ( const D & b , T t ) const { return lerp ( derived (), b , t ); } operator std :: span < T , S > () { return std :: span { _data }; } operator std :: span < const T , S > () const { return std :: span { _data }; } private : std :: array < T , S > _data ; }; } // namespace dakku #endif Updated on 2022-04-25 at 08:42:24 +0000","title":"Source code"},{"location":"Modules/","text":"Modules Updated on 2022-04-25 at 08:42:24 +0000","title":"Modules"},{"location":"Modules/#modules","text":"Updated on 2022-04-25 at 08:42:24 +0000","title":"Modules"},{"location":"Namespaces/","text":"Namespaces namespace dakku dakku namespace Updated on 2022-04-25 at 08:42:24 +0000","title":"Namespaces"},{"location":"Namespaces/#namespaces","text":"namespace dakku dakku namespace Updated on 2022-04-25 at 08:42:24 +0000","title":"Namespaces"},{"location":"Namespaces/namespacedakku/","text":"dakku dakku namespace Classes Name class dakku::Logger logger class class dakku::Lua dakku lua state class dakku::Normal normal class dakku::Point point class dakku::Vector vector class dakku::VectorBase vector base Functions Name template <typename T > DAKKU_INLINE bool isnan (T x) check whether x is not a number template <typename T > DAKKU_INLINE bool isnan (T ) check whether x is not a number DAKKU_DECLARE_VECTOR_TYPE (Vector2i , Vector , int , 2 ) DAKKU_DECLARE_VECTOR_TYPE (Vector2f , Vector , float , 2 ) DAKKU_DECLARE_VECTOR_TYPE (Vector3i , Vector , int , 3 ) DAKKU_DECLARE_VECTOR_TYPE (Vector3f , Vector , float , 3 ) DAKKU_DECLARE_POINT_TYPE (Point3f , Point , float , 3 , Vector3f ) DAKKU_DECLARE_POINT_TYPE (Point3i , Point , int , 3 , Vector3i ) DAKKU_DECLARE_POINT_TYPE (Point2f , Point , float , 2 , Vector2f ) DAKKU_DECLARE_POINT_TYPE (Point2i , Point , int , 2 , Vector2i ) DAKKU_DECLARE_VECTOR_TYPE (Normal3f , Normal , float , 3 ) Functions Documentation function isnan template < typename T > DAKKU_INLINE bool isnan ( T x ) check whether x is not a number Parameters : x given value Template Parameters : T type (floating point) Return : whether x is nan function isnan template < typename T > DAKKU_INLINE bool isnan ( T ) check whether x is not a number Template Parameters : T type (integer) Return : false (all integers are not nans) function DAKKU_DECLARE_VECTOR_TYPE DAKKU_DECLARE_VECTOR_TYPE ( Vector2i , Vector , int , 2 ) function DAKKU_DECLARE_VECTOR_TYPE DAKKU_DECLARE_VECTOR_TYPE ( Vector2f , Vector , float , 2 ) function DAKKU_DECLARE_VECTOR_TYPE DAKKU_DECLARE_VECTOR_TYPE ( Vector3i , Vector , int , 3 ) function DAKKU_DECLARE_VECTOR_TYPE DAKKU_DECLARE_VECTOR_TYPE ( Vector3f , Vector , float , 3 ) function DAKKU_DECLARE_POINT_TYPE DAKKU_DECLARE_POINT_TYPE ( Point3f , Point , float , 3 , Vector3f ) function DAKKU_DECLARE_POINT_TYPE DAKKU_DECLARE_POINT_TYPE ( Point3i , Point , int , 3 , Vector3i ) function DAKKU_DECLARE_POINT_TYPE DAKKU_DECLARE_POINT_TYPE ( Point2f , Point , float , 2 , Vector2f ) function DAKKU_DECLARE_POINT_TYPE DAKKU_DECLARE_POINT_TYPE ( Point2i , Point , int , 2 , Vector2i ) function DAKKU_DECLARE_VECTOR_TYPE DAKKU_DECLARE_VECTOR_TYPE ( Normal3f , Normal , float , 3 ) Updated on 2022-04-25 at 08:42:24 +0000","title":"dakku"},{"location":"Namespaces/namespacedakku/#dakku","text":"dakku namespace","title":"dakku"},{"location":"Namespaces/namespacedakku/#classes","text":"Name class dakku::Logger logger class class dakku::Lua dakku lua state class dakku::Normal normal class dakku::Point point class dakku::Vector vector class dakku::VectorBase vector base","title":"Classes"},{"location":"Namespaces/namespacedakku/#functions","text":"Name template <typename T > DAKKU_INLINE bool isnan (T x) check whether x is not a number template <typename T > DAKKU_INLINE bool isnan (T ) check whether x is not a number DAKKU_DECLARE_VECTOR_TYPE (Vector2i , Vector , int , 2 ) DAKKU_DECLARE_VECTOR_TYPE (Vector2f , Vector , float , 2 ) DAKKU_DECLARE_VECTOR_TYPE (Vector3i , Vector , int , 3 ) DAKKU_DECLARE_VECTOR_TYPE (Vector3f , Vector , float , 3 ) DAKKU_DECLARE_POINT_TYPE (Point3f , Point , float , 3 , Vector3f ) DAKKU_DECLARE_POINT_TYPE (Point3i , Point , int , 3 , Vector3i ) DAKKU_DECLARE_POINT_TYPE (Point2f , Point , float , 2 , Vector2f ) DAKKU_DECLARE_POINT_TYPE (Point2i , Point , int , 2 , Vector2i ) DAKKU_DECLARE_VECTOR_TYPE (Normal3f , Normal , float , 3 )","title":"Functions"},{"location":"Namespaces/namespacedakku/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Namespaces/namespacedakku/#function-isnan","text":"template < typename T > DAKKU_INLINE bool isnan ( T x ) check whether x is not a number Parameters : x given value Template Parameters : T type (floating point) Return : whether x is nan","title":"function isnan"},{"location":"Namespaces/namespacedakku/#function-isnan_1","text":"template < typename T > DAKKU_INLINE bool isnan ( T ) check whether x is not a number Template Parameters : T type (integer) Return : false (all integers are not nans)","title":"function isnan"},{"location":"Namespaces/namespacedakku/#function-dakku_declare_vector_type","text":"DAKKU_DECLARE_VECTOR_TYPE ( Vector2i , Vector , int , 2 )","title":"function DAKKU_DECLARE_VECTOR_TYPE"},{"location":"Namespaces/namespacedakku/#function-dakku_declare_vector_type_1","text":"DAKKU_DECLARE_VECTOR_TYPE ( Vector2f , Vector , float , 2 )","title":"function DAKKU_DECLARE_VECTOR_TYPE"},{"location":"Namespaces/namespacedakku/#function-dakku_declare_vector_type_2","text":"DAKKU_DECLARE_VECTOR_TYPE ( Vector3i , Vector , int , 3 )","title":"function DAKKU_DECLARE_VECTOR_TYPE"},{"location":"Namespaces/namespacedakku/#function-dakku_declare_vector_type_3","text":"DAKKU_DECLARE_VECTOR_TYPE ( Vector3f , Vector , float , 3 )","title":"function DAKKU_DECLARE_VECTOR_TYPE"},{"location":"Namespaces/namespacedakku/#function-dakku_declare_point_type","text":"DAKKU_DECLARE_POINT_TYPE ( Point3f , Point , float , 3 , Vector3f )","title":"function DAKKU_DECLARE_POINT_TYPE"},{"location":"Namespaces/namespacedakku/#function-dakku_declare_point_type_1","text":"DAKKU_DECLARE_POINT_TYPE ( Point3i , Point , int , 3 , Vector3i )","title":"function DAKKU_DECLARE_POINT_TYPE"},{"location":"Namespaces/namespacedakku/#function-dakku_declare_point_type_2","text":"DAKKU_DECLARE_POINT_TYPE ( Point2f , Point , float , 2 , Vector2f )","title":"function DAKKU_DECLARE_POINT_TYPE"},{"location":"Namespaces/namespacedakku/#function-dakku_declare_point_type_3","text":"DAKKU_DECLARE_POINT_TYPE ( Point2i , Point , int , 2 , Vector2i )","title":"function DAKKU_DECLARE_POINT_TYPE"},{"location":"Namespaces/namespacedakku/#function-dakku_declare_vector_type_4","text":"DAKKU_DECLARE_VECTOR_TYPE ( Normal3f , Normal , float , 3 ) Updated on 2022-04-25 at 08:42:24 +0000","title":"function DAKKU_DECLARE_VECTOR_TYPE"},{"location":"Pages/","text":"Pages page dakku documentation Updated on 2022-04-25 at 08:42:24 +0000","title":"Pages"},{"location":"Pages/#pages","text":"page dakku documentation Updated on 2022-04-25 at 08:42:24 +0000","title":"Pages"}]}