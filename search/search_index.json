{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"dakku documentation This is the documentation of dakku renderer. Updated on 2022-04-30 at 15:46:11 +0000","title":"dakku documentation"},{"location":"#dakku-documentation","text":"This is the documentation of dakku renderer. Updated on 2022-04-30 at 15:46:11 +0000","title":"dakku documentation"},{"location":"Classes/","text":"Classes namespace dakku dakku namespace class Bounds2 2d bounding box class Bounds2iIterator 2d integer bounds iterator, iterate all pixels inside class Bounds3 3d bounding box class BoundsBase bounding box base class BoxFilter box filter the box filter is simple, just return \\(1\\) for all values class Filter class GlobalMemoryArena global memory arena class Logger logger class class Lua dakku lua state class MemoryArena memory arena (unsynchronized) class Normal normal class Point point class Ray ray class RayDifferential differential ray class TriangleFilter triangle filter the weight falls off linearly from the filter center over the square extent of the filter class Vector vector class VectorBase vector base namespace std Updated on 2022-04-30 at 15:46:11 +0000","title":"Classes"},{"location":"Classes/#classes","text":"namespace dakku dakku namespace class Bounds2 2d bounding box class Bounds2iIterator 2d integer bounds iterator, iterate all pixels inside class Bounds3 3d bounding box class BoundsBase bounding box base class BoxFilter box filter the box filter is simple, just return \\(1\\) for all values class Filter class GlobalMemoryArena global memory arena class Logger logger class class Lua dakku lua state class MemoryArena memory arena (unsynchronized) class Normal normal class Point point class Ray ray class RayDifferential differential ray class TriangleFilter triangle filter the weight falls off linearly from the filter center over the square extent of the filter class Vector vector class VectorBase vector base namespace std Updated on 2022-04-30 at 15:46:11 +0000","title":"Classes"},{"location":"Classes/classdakku_1_1Bounds2/","text":"dakku::Bounds2 2d bounding box More... #include <bounds.h> Inherits from dakku::BoundsBase< T, 2 > Public Functions Name Bounds2 (const BoundsBase < T, 2 > & base) decltype(auto) area () const get the area of bounds Additional inherited members Public Functions inherited from dakku::BoundsBase< T, 2 > Name BoundsBase () =default default constructor BoundsBase (const Point < T, S > & p) Construct a new Bounds2 with a point. template <ArithmeticType U> BoundsBase (const BoundsBase < U, S > & b) type conversion BoundsBase (const Point < T, S > & p1, const Point < T, S > & p2) Construct a new Bounds Base object with two points (take min/max of them to pMin and pMax) BoundsBase (const sol::table & table) Vector < T, S > diagonal () const get the diagonal of the bounding box size_t max_extent () const get the dimension who has the maximum extent bool operator== (const BoundsBase & rhs) const bool operator!= (const BoundsBase & rhs) const Point < T, S > lerp (const Point < float, S > & t) const linera interpolation between pMin and pMax Vector < T, S > offset (const Point < T, S > & p) const get the offset \\(v\\) of a point, p = o + v * d bool overlaps (const BoundsBase & rhs) const check whether two bounds overlaps bool inside (const Point < T, S > & p) const check whether point is inside the bounds (inclusive) bool inside_exclusive (const Point < T, S > & p) const check whether point is inside the bounds (exclusive) void bounding_sphere ( Point < T, S > & center, float & rad) get the bounding sphere of the bounds BoundsBase union_bounds (const BoundsBase & rhs) const take the union of the two bounds BoundsBase union_bounds (const Point < T, S > & p) const take the union between bounds and a point BoundsBase intersect (const BoundsBase & rhs) const take the intersect between two bounds std::string to_string () const Public Attributes inherited from dakku::BoundsBase< T, 2 > Name Point < T, S > p_min left bottom corner of the bounds Point < T, S > p_max right top corner of the bounds Friends inherited from dakku::BoundsBase< T, 2 > Name bool overlaps (const BoundsBase & a, const BoundsBase & b) check whether two bounds overlaps bool inside (const Point < T, S > & p, const BoundsBase & b) check whether point is inside the bounds (inclusive) bool inside_exclusive (const Point < T, S > & p, const BoundsBase & b) check whether point is inside the bounds (exclusive) BoundsBase **[operator BoundsBase **[operator BoundsBase operator& (const BoundsBase & a, const BoundsBase & b) take the intersect between two bounds decltype(auto) distance_squared (const Point < T, S > & p, const BoundsBase < T, S > & b) minimum squared distance between point and bounds, if inside return 0 decltype(auto) distance (const Point < T, S > & p, const BoundsBase < T, S > & b) minimum distance between point and bounds, if inside return 0 std::ostream & operator<< (std::ostream & os, const BoundsBase & b) Detailed Description template < ArithmeticType T > class dakku :: Bounds2 ; 2d bounding box Public Functions Documentation function Bounds2 inline Bounds2 ( const BoundsBase < T , 2 > & base ) function area inline decltype ( auto ) area () const get the area of bounds Return : the area Updated on 2022-04-30 at 15:46:11 +0000","title":"dakku::Bounds2"},{"location":"Classes/classdakku_1_1Bounds2/#dakkubounds2","text":"2d bounding box More... #include <bounds.h> Inherits from dakku::BoundsBase< T, 2 >","title":"dakku::Bounds2"},{"location":"Classes/classdakku_1_1Bounds2/#public-functions","text":"Name Bounds2 (const BoundsBase < T, 2 > & base) decltype(auto) area () const get the area of bounds","title":"Public Functions"},{"location":"Classes/classdakku_1_1Bounds2/#additional-inherited-members","text":"Public Functions inherited from dakku::BoundsBase< T, 2 > Name BoundsBase () =default default constructor BoundsBase (const Point < T, S > & p) Construct a new Bounds2 with a point. template <ArithmeticType U> BoundsBase (const BoundsBase < U, S > & b) type conversion BoundsBase (const Point < T, S > & p1, const Point < T, S > & p2) Construct a new Bounds Base object with two points (take min/max of them to pMin and pMax) BoundsBase (const sol::table & table) Vector < T, S > diagonal () const get the diagonal of the bounding box size_t max_extent () const get the dimension who has the maximum extent bool operator== (const BoundsBase & rhs) const bool operator!= (const BoundsBase & rhs) const Point < T, S > lerp (const Point < float, S > & t) const linera interpolation between pMin and pMax Vector < T, S > offset (const Point < T, S > & p) const get the offset \\(v\\) of a point, p = o + v * d bool overlaps (const BoundsBase & rhs) const check whether two bounds overlaps bool inside (const Point < T, S > & p) const check whether point is inside the bounds (inclusive) bool inside_exclusive (const Point < T, S > & p) const check whether point is inside the bounds (exclusive) void bounding_sphere ( Point < T, S > & center, float & rad) get the bounding sphere of the bounds BoundsBase union_bounds (const BoundsBase & rhs) const take the union of the two bounds BoundsBase union_bounds (const Point < T, S > & p) const take the union between bounds and a point BoundsBase intersect (const BoundsBase & rhs) const take the intersect between two bounds std::string to_string () const Public Attributes inherited from dakku::BoundsBase< T, 2 > Name Point < T, S > p_min left bottom corner of the bounds Point < T, S > p_max right top corner of the bounds Friends inherited from dakku::BoundsBase< T, 2 > Name bool overlaps (const BoundsBase & a, const BoundsBase & b) check whether two bounds overlaps bool inside (const Point < T, S > & p, const BoundsBase & b) check whether point is inside the bounds (inclusive) bool inside_exclusive (const Point < T, S > & p, const BoundsBase & b) check whether point is inside the bounds (exclusive) BoundsBase **[operator BoundsBase **[operator BoundsBase operator& (const BoundsBase & a, const BoundsBase & b) take the intersect between two bounds decltype(auto) distance_squared (const Point < T, S > & p, const BoundsBase < T, S > & b) minimum squared distance between point and bounds, if inside return 0 decltype(auto) distance (const Point < T, S > & p, const BoundsBase < T, S > & b) minimum distance between point and bounds, if inside return 0 std::ostream & operator<< (std::ostream & os, const BoundsBase & b)","title":"Additional inherited members"},{"location":"Classes/classdakku_1_1Bounds2/#detailed-description","text":"template < ArithmeticType T > class dakku :: Bounds2 ; 2d bounding box","title":"Detailed Description"},{"location":"Classes/classdakku_1_1Bounds2/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Classes/classdakku_1_1Bounds2/#function-bounds2","text":"inline Bounds2 ( const BoundsBase < T , 2 > & base )","title":"function Bounds2"},{"location":"Classes/classdakku_1_1Bounds2/#function-area","text":"inline decltype ( auto ) area () const get the area of bounds Return : the area Updated on 2022-04-30 at 15:46:11 +0000","title":"function area"},{"location":"Classes/classdakku_1_1Bounds2iIterator/","text":"dakku::Bounds2iIterator 2d integer bounds iterator, iterate all pixels inside #include <bounds.h> Inherits from std::forward_iterator_tag Public Functions Name Bounds2iIterator (const Bounds2i & b, Point2i p) Bounds2iIterator operator++ () Bounds2iIterator operator++ (int ) bool operator== (const Bounds2iIterator & rhs) const bool operator!= (const Bounds2iIterator & rhs) const Point2i operator* () const Public Functions Documentation function Bounds2iIterator inline explicit Bounds2iIterator ( const Bounds2i & b , Point2i p ) function operator++ inline Bounds2iIterator operator ++ () function operator++ inline Bounds2iIterator operator ++ ( int ) function operator== inline bool operator == ( const Bounds2iIterator & rhs ) const function operator!= inline bool operator != ( const Bounds2iIterator & rhs ) const function operator* inline Point2i operator * () const Updated on 2022-04-30 at 15:46:11 +0000","title":"dakku::Bounds2iIterator"},{"location":"Classes/classdakku_1_1Bounds2iIterator/#dakkubounds2iiterator","text":"2d integer bounds iterator, iterate all pixels inside #include <bounds.h> Inherits from std::forward_iterator_tag","title":"dakku::Bounds2iIterator"},{"location":"Classes/classdakku_1_1Bounds2iIterator/#public-functions","text":"Name Bounds2iIterator (const Bounds2i & b, Point2i p) Bounds2iIterator operator++ () Bounds2iIterator operator++ (int ) bool operator== (const Bounds2iIterator & rhs) const bool operator!= (const Bounds2iIterator & rhs) const Point2i operator* () const","title":"Public Functions"},{"location":"Classes/classdakku_1_1Bounds2iIterator/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Classes/classdakku_1_1Bounds2iIterator/#function-bounds2iiterator","text":"inline explicit Bounds2iIterator ( const Bounds2i & b , Point2i p )","title":"function Bounds2iIterator"},{"location":"Classes/classdakku_1_1Bounds2iIterator/#function-operator","text":"inline Bounds2iIterator operator ++ ()","title":"function operator++"},{"location":"Classes/classdakku_1_1Bounds2iIterator/#function-operator_1","text":"inline Bounds2iIterator operator ++ ( int )","title":"function operator++"},{"location":"Classes/classdakku_1_1Bounds2iIterator/#function-operator_2","text":"inline bool operator == ( const Bounds2iIterator & rhs ) const","title":"function operator=="},{"location":"Classes/classdakku_1_1Bounds2iIterator/#function-operator_3","text":"inline bool operator != ( const Bounds2iIterator & rhs ) const","title":"function operator!="},{"location":"Classes/classdakku_1_1Bounds2iIterator/#function-operator_4","text":"inline Point2i operator * () const Updated on 2022-04-30 at 15:46:11 +0000","title":"function operator*"},{"location":"Classes/classdakku_1_1Bounds3/","text":"dakku::Bounds3 3d bounding box More... #include <bounds.h> Inherits from dakku::BoundsBase< T, 3 > Public Functions Name Bounds3 (const BoundsBase < T, 3 > & base) Additional inherited members Public Functions inherited from dakku::BoundsBase< T, 3 > Name BoundsBase () =default default constructor BoundsBase (const Point < T, S > & p) Construct a new Bounds2 with a point. template <ArithmeticType U> BoundsBase (const BoundsBase < U, S > & b) type conversion BoundsBase (const Point < T, S > & p1, const Point < T, S > & p2) Construct a new Bounds Base object with two points (take min/max of them to pMin and pMax) BoundsBase (const sol::table & table) Vector < T, S > diagonal () const get the diagonal of the bounding box size_t max_extent () const get the dimension who has the maximum extent bool operator== (const BoundsBase & rhs) const bool operator!= (const BoundsBase & rhs) const Point < T, S > lerp (const Point < float, S > & t) const linera interpolation between pMin and pMax Vector < T, S > offset (const Point < T, S > & p) const get the offset \\(v\\) of a point, p = o + v * d bool overlaps (const BoundsBase & rhs) const check whether two bounds overlaps bool inside (const Point < T, S > & p) const check whether point is inside the bounds (inclusive) bool inside_exclusive (const Point < T, S > & p) const check whether point is inside the bounds (exclusive) void bounding_sphere ( Point < T, S > & center, float & rad) get the bounding sphere of the bounds BoundsBase union_bounds (const BoundsBase & rhs) const take the union of the two bounds BoundsBase union_bounds (const Point < T, S > & p) const take the union between bounds and a point BoundsBase intersect (const BoundsBase & rhs) const take the intersect between two bounds std::string to_string () const Public Attributes inherited from dakku::BoundsBase< T, 3 > Name Point < T, S > p_min left bottom corner of the bounds Point < T, S > p_max right top corner of the bounds Friends inherited from dakku::BoundsBase< T, 3 > Name bool overlaps (const BoundsBase & a, const BoundsBase & b) check whether two bounds overlaps bool inside (const Point < T, S > & p, const BoundsBase & b) check whether point is inside the bounds (inclusive) bool inside_exclusive (const Point < T, S > & p, const BoundsBase & b) check whether point is inside the bounds (exclusive) BoundsBase **[operator BoundsBase **[operator BoundsBase operator& (const BoundsBase & a, const BoundsBase & b) take the intersect between two bounds decltype(auto) distance_squared (const Point < T, S > & p, const BoundsBase < T, S > & b) minimum squared distance between point and bounds, if inside return 0 decltype(auto) distance (const Point < T, S > & p, const BoundsBase < T, S > & b) minimum distance between point and bounds, if inside return 0 std::ostream & operator<< (std::ostream & os, const BoundsBase & b) Detailed Description template < ArithmeticType T > class dakku :: Bounds3 ; 3d bounding box Public Functions Documentation function Bounds3 inline Bounds3 ( const BoundsBase < T , 3 > & base ) Updated on 2022-04-30 at 15:46:11 +0000","title":"dakku::Bounds3"},{"location":"Classes/classdakku_1_1Bounds3/#dakkubounds3","text":"3d bounding box More... #include <bounds.h> Inherits from dakku::BoundsBase< T, 3 >","title":"dakku::Bounds3"},{"location":"Classes/classdakku_1_1Bounds3/#public-functions","text":"Name Bounds3 (const BoundsBase < T, 3 > & base)","title":"Public Functions"},{"location":"Classes/classdakku_1_1Bounds3/#additional-inherited-members","text":"Public Functions inherited from dakku::BoundsBase< T, 3 > Name BoundsBase () =default default constructor BoundsBase (const Point < T, S > & p) Construct a new Bounds2 with a point. template <ArithmeticType U> BoundsBase (const BoundsBase < U, S > & b) type conversion BoundsBase (const Point < T, S > & p1, const Point < T, S > & p2) Construct a new Bounds Base object with two points (take min/max of them to pMin and pMax) BoundsBase (const sol::table & table) Vector < T, S > diagonal () const get the diagonal of the bounding box size_t max_extent () const get the dimension who has the maximum extent bool operator== (const BoundsBase & rhs) const bool operator!= (const BoundsBase & rhs) const Point < T, S > lerp (const Point < float, S > & t) const linera interpolation between pMin and pMax Vector < T, S > offset (const Point < T, S > & p) const get the offset \\(v\\) of a point, p = o + v * d bool overlaps (const BoundsBase & rhs) const check whether two bounds overlaps bool inside (const Point < T, S > & p) const check whether point is inside the bounds (inclusive) bool inside_exclusive (const Point < T, S > & p) const check whether point is inside the bounds (exclusive) void bounding_sphere ( Point < T, S > & center, float & rad) get the bounding sphere of the bounds BoundsBase union_bounds (const BoundsBase & rhs) const take the union of the two bounds BoundsBase union_bounds (const Point < T, S > & p) const take the union between bounds and a point BoundsBase intersect (const BoundsBase & rhs) const take the intersect between two bounds std::string to_string () const Public Attributes inherited from dakku::BoundsBase< T, 3 > Name Point < T, S > p_min left bottom corner of the bounds Point < T, S > p_max right top corner of the bounds Friends inherited from dakku::BoundsBase< T, 3 > Name bool overlaps (const BoundsBase & a, const BoundsBase & b) check whether two bounds overlaps bool inside (const Point < T, S > & p, const BoundsBase & b) check whether point is inside the bounds (inclusive) bool inside_exclusive (const Point < T, S > & p, const BoundsBase & b) check whether point is inside the bounds (exclusive) BoundsBase **[operator BoundsBase **[operator BoundsBase operator& (const BoundsBase & a, const BoundsBase & b) take the intersect between two bounds decltype(auto) distance_squared (const Point < T, S > & p, const BoundsBase < T, S > & b) minimum squared distance between point and bounds, if inside return 0 decltype(auto) distance (const Point < T, S > & p, const BoundsBase < T, S > & b) minimum distance between point and bounds, if inside return 0 std::ostream & operator<< (std::ostream & os, const BoundsBase & b)","title":"Additional inherited members"},{"location":"Classes/classdakku_1_1Bounds3/#detailed-description","text":"template < ArithmeticType T > class dakku :: Bounds3 ; 3d bounding box","title":"Detailed Description"},{"location":"Classes/classdakku_1_1Bounds3/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Classes/classdakku_1_1Bounds3/#function-bounds3","text":"inline Bounds3 ( const BoundsBase < T , 3 > & base ) Updated on 2022-04-30 at 15:46:11 +0000","title":"function Bounds3"},{"location":"Classes/classdakku_1_1BoundsBase/","text":"dakku::BoundsBase bounding box base More... #include <bounds.h> Public Functions Name BoundsBase () =default default constructor BoundsBase (const Point < T, S > & p) Construct a new Bounds2 with a point. template <ArithmeticType U> BoundsBase (const BoundsBase < U, S > & b) type conversion BoundsBase (const Point < T, S > & p1, const Point < T, S > & p2) Construct a new Bounds Base object with two points (take min/max of them to pMin and pMax) BoundsBase (const sol::table & table) Vector < T, S > diagonal () const get the diagonal of the bounding box size_t max_extent () const get the dimension who has the maximum extent bool operator== (const BoundsBase & rhs) const bool operator!= (const BoundsBase & rhs) const Point < T, S > lerp (const Point < float, S > & t) const linera interpolation between pMin and pMax Vector < T, S > offset (const Point < T, S > & p) const get the offset \\(v\\) of a point, p = o + v * d bool overlaps (const BoundsBase & rhs) const check whether two bounds overlaps bool inside (const Point < T, S > & p) const check whether point is inside the bounds (inclusive) bool inside_exclusive (const Point < T, S > & p) const check whether point is inside the bounds (exclusive) void bounding_sphere ( Point < T, S > & center, float & rad) get the bounding sphere of the bounds BoundsBase union_bounds (const BoundsBase & rhs) const take the union of the two bounds BoundsBase union_bounds (const Point < T, S > & p) const take the union between bounds and a point BoundsBase intersect (const BoundsBase & rhs) const take the intersect between two bounds std::string to_string () const Public Attributes Name Point < T, S > p_min left bottom corner of the bounds Point < T, S > p_max right top corner of the bounds Friends Name bool overlaps (const BoundsBase & a, const BoundsBase & b) check whether two bounds overlaps bool inside (const Point < T, S > & p, const BoundsBase & b) check whether point is inside the bounds (inclusive) bool inside_exclusive (const Point < T, S > & p, const BoundsBase & b) check whether point is inside the bounds (exclusive) BoundsBase **[operator BoundsBase **[operator BoundsBase operator& (const BoundsBase & a, const BoundsBase & b) take the intersect between two bounds decltype(auto) distance_squared (const Point < T, S > & p, const BoundsBase < T, S > & b) minimum squared distance between point and bounds, if inside return 0 decltype(auto) distance (const Point < T, S > & p, const BoundsBase < T, S > & b) minimum distance between point and bounds, if inside return 0 std::ostream & operator<< (std::ostream & os, const BoundsBase & b) Detailed Description template < ArithmeticType T , size_t S > class dakku :: BoundsBase ; bounding box base Template Parameters : T data type S dimension Public Functions Documentation function BoundsBase BoundsBase () = default default constructor function BoundsBase inline explicit BoundsBase ( const Point < T , S > & p ) Construct a new Bounds2 with a point. Parameters : p the given point function BoundsBase template < ArithmeticType U > inline explicit BoundsBase ( const BoundsBase < U , S > & b ) type conversion function BoundsBase inline BoundsBase ( const Point < T , S > & p1 , const Point < T , S > & p2 ) Construct a new Bounds Base object with two points (take min/max of them to pMin and pMax) function BoundsBase inline BoundsBase ( const sol :: table & table ) function diagonal inline Vector < T , S > diagonal () const get the diagonal of the bounding box function max_extent inline size_t max_extent () const get the dimension who has the maximum extent Return : the dimension function operator== inline bool operator == ( const BoundsBase & rhs ) const function operator!= inline bool operator != ( const BoundsBase & rhs ) const function lerp inline Point < T , S > lerp ( const Point < float , S > & t ) const linera interpolation between pMin and pMax Parameters : t interpolate \\(t\\) (element wise) function offset inline Vector < T , S > offset ( const Point < T , S > & p ) const get the offset \\(v\\) of a point, p = o + v * d Parameters : p the point Return : the offset function overlaps inline bool overlaps ( const BoundsBase & rhs ) const check whether two bounds overlaps function inside inline bool inside ( const Point < T , S > & p ) const check whether point is inside the bounds (inclusive) Parameters : p the point function inside_exclusive inline bool inside_exclusive ( const Point < T , S > & p ) const check whether point is inside the bounds (exclusive) Parameters : p the point function bounding_sphere inline void bounding_sphere ( Point < T , S > & center , float & rad ) get the bounding sphere of the bounds Parameters : center the center of the sphere rad the radius of the sphere function union_bounds inline BoundsBase union_bounds ( const BoundsBase & rhs ) const take the union of the two bounds function union_bounds inline BoundsBase union_bounds ( const Point < T , S > & p ) const take the union between bounds and a point function intersect inline BoundsBase intersect ( const BoundsBase & rhs ) const take the intersect between two bounds function to_string inline std :: string to_string () const Public Attributes Documentation variable p_min Point < T , S > p_min { std :: numeric_limits < T >:: max ()}; left bottom corner of the bounds variable p_max Point < T , S > p_max { std :: numeric_limits < T >:: lowest ()}; right top corner of the bounds Friends friend overlaps friend bool overlaps ( const BoundsBase & a , const BoundsBase & b ); check whether two bounds overlaps friend inside friend bool inside ( const Point < T , S > & p , const BoundsBase & b ); check whether point is inside the bounds (inclusive) Parameters : p the point b the bounds friend inside_exclusive friend bool inside_exclusive ( const Point < T , S > & p , const BoundsBase & b ); check whether point is inside the bounds (exclusive) Parameters : p the point b the bounds friend operator| friend BoundsBase operator | ( const BoundsBase & a , const BoundsBase & b ); take the union of the two bounds friend operator| friend BoundsBase operator | ( const BoundsBase & b , const Point < T , S > & p ); take the union between bounds and a point friend operator& friend BoundsBase operator & ( const BoundsBase & a , const BoundsBase & b ); take the intersect between two bounds friend distance_squared friend decltype ( auto ) distance_squared ( const Point < T , S > & p , const BoundsBase < T , S > & b ); minimum squared distance between point and bounds, if inside return 0 Parameters : p the point b the bounds Return : the squared distance friend distance friend decltype ( auto ) distance ( const Point < T , S > & p , const BoundsBase < T , S > & b ); minimum distance between point and bounds, if inside return 0 Parameters : p the point b the bounds Return : the distance friend operator<< friend std :: ostream & operator << ( std :: ostream & os , const BoundsBase & b ); Updated on 2022-04-30 at 15:46:11 +0000","title":"dakku::BoundsBase"},{"location":"Classes/classdakku_1_1BoundsBase/#dakkuboundsbase","text":"bounding box base More... #include <bounds.h>","title":"dakku::BoundsBase"},{"location":"Classes/classdakku_1_1BoundsBase/#public-functions","text":"Name BoundsBase () =default default constructor BoundsBase (const Point < T, S > & p) Construct a new Bounds2 with a point. template <ArithmeticType U> BoundsBase (const BoundsBase < U, S > & b) type conversion BoundsBase (const Point < T, S > & p1, const Point < T, S > & p2) Construct a new Bounds Base object with two points (take min/max of them to pMin and pMax) BoundsBase (const sol::table & table) Vector < T, S > diagonal () const get the diagonal of the bounding box size_t max_extent () const get the dimension who has the maximum extent bool operator== (const BoundsBase & rhs) const bool operator!= (const BoundsBase & rhs) const Point < T, S > lerp (const Point < float, S > & t) const linera interpolation between pMin and pMax Vector < T, S > offset (const Point < T, S > & p) const get the offset \\(v\\) of a point, p = o + v * d bool overlaps (const BoundsBase & rhs) const check whether two bounds overlaps bool inside (const Point < T, S > & p) const check whether point is inside the bounds (inclusive) bool inside_exclusive (const Point < T, S > & p) const check whether point is inside the bounds (exclusive) void bounding_sphere ( Point < T, S > & center, float & rad) get the bounding sphere of the bounds BoundsBase union_bounds (const BoundsBase & rhs) const take the union of the two bounds BoundsBase union_bounds (const Point < T, S > & p) const take the union between bounds and a point BoundsBase intersect (const BoundsBase & rhs) const take the intersect between two bounds std::string to_string () const","title":"Public Functions"},{"location":"Classes/classdakku_1_1BoundsBase/#public-attributes","text":"Name Point < T, S > p_min left bottom corner of the bounds Point < T, S > p_max right top corner of the bounds","title":"Public Attributes"},{"location":"Classes/classdakku_1_1BoundsBase/#friends","text":"Name bool overlaps (const BoundsBase & a, const BoundsBase & b) check whether two bounds overlaps bool inside (const Point < T, S > & p, const BoundsBase & b) check whether point is inside the bounds (inclusive) bool inside_exclusive (const Point < T, S > & p, const BoundsBase & b) check whether point is inside the bounds (exclusive) BoundsBase **[operator BoundsBase **[operator BoundsBase operator& (const BoundsBase & a, const BoundsBase & b) take the intersect between two bounds decltype(auto) distance_squared (const Point < T, S > & p, const BoundsBase < T, S > & b) minimum squared distance between point and bounds, if inside return 0 decltype(auto) distance (const Point < T, S > & p, const BoundsBase < T, S > & b) minimum distance between point and bounds, if inside return 0 std::ostream & operator<< (std::ostream & os, const BoundsBase & b)","title":"Friends"},{"location":"Classes/classdakku_1_1BoundsBase/#detailed-description","text":"template < ArithmeticType T , size_t S > class dakku :: BoundsBase ; bounding box base Template Parameters : T data type S dimension","title":"Detailed Description"},{"location":"Classes/classdakku_1_1BoundsBase/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Classes/classdakku_1_1BoundsBase/#function-boundsbase","text":"BoundsBase () = default default constructor","title":"function BoundsBase"},{"location":"Classes/classdakku_1_1BoundsBase/#function-boundsbase_1","text":"inline explicit BoundsBase ( const Point < T , S > & p ) Construct a new Bounds2 with a point. Parameters : p the given point","title":"function BoundsBase"},{"location":"Classes/classdakku_1_1BoundsBase/#function-boundsbase_2","text":"template < ArithmeticType U > inline explicit BoundsBase ( const BoundsBase < U , S > & b ) type conversion","title":"function BoundsBase"},{"location":"Classes/classdakku_1_1BoundsBase/#function-boundsbase_3","text":"inline BoundsBase ( const Point < T , S > & p1 , const Point < T , S > & p2 ) Construct a new Bounds Base object with two points (take min/max of them to pMin and pMax)","title":"function BoundsBase"},{"location":"Classes/classdakku_1_1BoundsBase/#function-boundsbase_4","text":"inline BoundsBase ( const sol :: table & table )","title":"function BoundsBase"},{"location":"Classes/classdakku_1_1BoundsBase/#function-diagonal","text":"inline Vector < T , S > diagonal () const get the diagonal of the bounding box","title":"function diagonal"},{"location":"Classes/classdakku_1_1BoundsBase/#function-max_extent","text":"inline size_t max_extent () const get the dimension who has the maximum extent Return : the dimension","title":"function max_extent"},{"location":"Classes/classdakku_1_1BoundsBase/#function-operator","text":"inline bool operator == ( const BoundsBase & rhs ) const","title":"function operator=="},{"location":"Classes/classdakku_1_1BoundsBase/#function-operator_1","text":"inline bool operator != ( const BoundsBase & rhs ) const","title":"function operator!="},{"location":"Classes/classdakku_1_1BoundsBase/#function-lerp","text":"inline Point < T , S > lerp ( const Point < float , S > & t ) const linera interpolation between pMin and pMax Parameters : t interpolate \\(t\\) (element wise)","title":"function lerp"},{"location":"Classes/classdakku_1_1BoundsBase/#function-offset","text":"inline Vector < T , S > offset ( const Point < T , S > & p ) const get the offset \\(v\\) of a point, p = o + v * d Parameters : p the point Return : the offset","title":"function offset"},{"location":"Classes/classdakku_1_1BoundsBase/#function-overlaps","text":"inline bool overlaps ( const BoundsBase & rhs ) const check whether two bounds overlaps","title":"function overlaps"},{"location":"Classes/classdakku_1_1BoundsBase/#function-inside","text":"inline bool inside ( const Point < T , S > & p ) const check whether point is inside the bounds (inclusive) Parameters : p the point","title":"function inside"},{"location":"Classes/classdakku_1_1BoundsBase/#function-inside_exclusive","text":"inline bool inside_exclusive ( const Point < T , S > & p ) const check whether point is inside the bounds (exclusive) Parameters : p the point","title":"function inside_exclusive"},{"location":"Classes/classdakku_1_1BoundsBase/#function-bounding_sphere","text":"inline void bounding_sphere ( Point < T , S > & center , float & rad ) get the bounding sphere of the bounds Parameters : center the center of the sphere rad the radius of the sphere","title":"function bounding_sphere"},{"location":"Classes/classdakku_1_1BoundsBase/#function-union_bounds","text":"inline BoundsBase union_bounds ( const BoundsBase & rhs ) const take the union of the two bounds","title":"function union_bounds"},{"location":"Classes/classdakku_1_1BoundsBase/#function-union_bounds_1","text":"inline BoundsBase union_bounds ( const Point < T , S > & p ) const take the union between bounds and a point","title":"function union_bounds"},{"location":"Classes/classdakku_1_1BoundsBase/#function-intersect","text":"inline BoundsBase intersect ( const BoundsBase & rhs ) const take the intersect between two bounds","title":"function intersect"},{"location":"Classes/classdakku_1_1BoundsBase/#function-to_string","text":"inline std :: string to_string () const","title":"function to_string"},{"location":"Classes/classdakku_1_1BoundsBase/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"Classes/classdakku_1_1BoundsBase/#variable-p_min","text":"Point < T , S > p_min { std :: numeric_limits < T >:: max ()}; left bottom corner of the bounds","title":"variable p_min"},{"location":"Classes/classdakku_1_1BoundsBase/#variable-p_max","text":"Point < T , S > p_max { std :: numeric_limits < T >:: lowest ()}; right top corner of the bounds","title":"variable p_max"},{"location":"Classes/classdakku_1_1BoundsBase/#friends_1","text":"","title":"Friends"},{"location":"Classes/classdakku_1_1BoundsBase/#friend-overlaps","text":"friend bool overlaps ( const BoundsBase & a , const BoundsBase & b ); check whether two bounds overlaps","title":"friend overlaps"},{"location":"Classes/classdakku_1_1BoundsBase/#friend-inside","text":"friend bool inside ( const Point < T , S > & p , const BoundsBase & b ); check whether point is inside the bounds (inclusive) Parameters : p the point b the bounds","title":"friend inside"},{"location":"Classes/classdakku_1_1BoundsBase/#friend-inside_exclusive","text":"friend bool inside_exclusive ( const Point < T , S > & p , const BoundsBase & b ); check whether point is inside the bounds (exclusive) Parameters : p the point b the bounds","title":"friend inside_exclusive"},{"location":"Classes/classdakku_1_1BoundsBase/#friend-operator","text":"friend BoundsBase operator | ( const BoundsBase & a , const BoundsBase & b ); take the union of the two bounds","title":"friend operator|"},{"location":"Classes/classdakku_1_1BoundsBase/#friend-operator_1","text":"friend BoundsBase operator | ( const BoundsBase & b , const Point < T , S > & p ); take the union between bounds and a point","title":"friend operator|"},{"location":"Classes/classdakku_1_1BoundsBase/#friend-operator_2","text":"friend BoundsBase operator & ( const BoundsBase & a , const BoundsBase & b ); take the intersect between two bounds","title":"friend operator&amp;"},{"location":"Classes/classdakku_1_1BoundsBase/#friend-distance_squared","text":"friend decltype ( auto ) distance_squared ( const Point < T , S > & p , const BoundsBase < T , S > & b ); minimum squared distance between point and bounds, if inside return 0 Parameters : p the point b the bounds Return : the squared distance","title":"friend distance_squared"},{"location":"Classes/classdakku_1_1BoundsBase/#friend-distance","text":"friend decltype ( auto ) distance ( const Point < T , S > & p , const BoundsBase < T , S > & b ); minimum distance between point and bounds, if inside return 0 Parameters : p the point b the bounds Return : the distance","title":"friend distance"},{"location":"Classes/classdakku_1_1BoundsBase/#friend-operator_3","text":"friend std :: ostream & operator << ( std :: ostream & os , const BoundsBase & b ); Updated on 2022-04-30 at 15:46:11 +0000","title":"friend operator&lt;&lt;"},{"location":"Classes/classdakku_1_1BoxFilter/","text":"dakku::BoxFilter box filter the box filter is simple, just return \\(1\\) for all values #include <box.h> Inherits from dakku::Filter Public Functions Name virtual float evaluate (const Point2f & p) const override Given a 2D point which is relative to the center of the filter, the filter's value at that point is returned. Filter (const Vector2f & radius) Construct a new Filter object The filter's overall extent in each direction is twice the value given in radius Additional inherited members Public Attributes inherited from dakku::Filter Name const Vector2f radius filter radius const Vector2f inv_radius filter radius inversion Public Functions Documentation function evaluate virtual float evaluate ( const Point2f & p ) const override Given a 2D point which is relative to the center of the filter, the filter's value at that point is returned. Parameters : p the given 2D point Return : float filter's value Reimplements : dakku::Filter::evaluate function Filter explicit Filter ( const Vector2f & radius ) Construct a new Filter object The filter's overall extent in each direction is twice the value given in radius Parameters : radius radius of the filter Updated on 2022-04-30 at 15:46:11 +0000","title":"dakku::BoxFilter"},{"location":"Classes/classdakku_1_1BoxFilter/#dakkuboxfilter","text":"box filter the box filter is simple, just return \\(1\\) for all values #include <box.h> Inherits from dakku::Filter","title":"dakku::BoxFilter"},{"location":"Classes/classdakku_1_1BoxFilter/#public-functions","text":"Name virtual float evaluate (const Point2f & p) const override Given a 2D point which is relative to the center of the filter, the filter's value at that point is returned. Filter (const Vector2f & radius) Construct a new Filter object The filter's overall extent in each direction is twice the value given in radius","title":"Public Functions"},{"location":"Classes/classdakku_1_1BoxFilter/#additional-inherited-members","text":"Public Attributes inherited from dakku::Filter Name const Vector2f radius filter radius const Vector2f inv_radius filter radius inversion","title":"Additional inherited members"},{"location":"Classes/classdakku_1_1BoxFilter/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Classes/classdakku_1_1BoxFilter/#function-evaluate","text":"virtual float evaluate ( const Point2f & p ) const override Given a 2D point which is relative to the center of the filter, the filter's value at that point is returned. Parameters : p the given 2D point Return : float filter's value Reimplements : dakku::Filter::evaluate","title":"function evaluate"},{"location":"Classes/classdakku_1_1BoxFilter/#function-filter","text":"explicit Filter ( const Vector2f & radius ) Construct a new Filter object The filter's overall extent in each direction is twice the value given in radius Parameters : radius radius of the filter Updated on 2022-04-30 at 15:46:11 +0000","title":"function Filter"},{"location":"Classes/classdakku_1_1Filter/","text":"dakku::Filter #include <filter.h> Inherited by dakku::BoxFilter , dakku::TriangleFilter Public Functions Name Filter (const Vector2f & radius) Construct a new Filter object The filter's overall extent in each direction is twice the value given in radius virtual float evaluate (const Point2f & p) const =0 Given a 2D point which is relative to the center of the filter, the filter's value at that point is returned. Public Attributes Name const Vector2f radius filter radius const Vector2f inv_radius filter radius inversion Public Functions Documentation function Filter explicit Filter ( const Vector2f & radius ) Construct a new Filter object The filter's overall extent in each direction is twice the value given in radius Parameters : radius radius of the filter function evaluate virtual float evaluate ( const Point2f & p ) const = 0 Given a 2D point which is relative to the center of the filter, the filter's value at that point is returned. Parameters : p the given 2D point Return : float filter's value Reimplemented by : dakku::BoxFilter::evaluate , dakku::TriangleFilter::evaluate Public Attributes Documentation variable radius const Vector2f radius ; filter radius variable inv_radius const Vector2f inv_radius ; filter radius inversion Updated on 2022-04-30 at 15:46:11 +0000","title":"dakku::Filter"},{"location":"Classes/classdakku_1_1Filter/#dakkufilter","text":"#include <filter.h> Inherited by dakku::BoxFilter , dakku::TriangleFilter","title":"dakku::Filter"},{"location":"Classes/classdakku_1_1Filter/#public-functions","text":"Name Filter (const Vector2f & radius) Construct a new Filter object The filter's overall extent in each direction is twice the value given in radius virtual float evaluate (const Point2f & p) const =0 Given a 2D point which is relative to the center of the filter, the filter's value at that point is returned.","title":"Public Functions"},{"location":"Classes/classdakku_1_1Filter/#public-attributes","text":"Name const Vector2f radius filter radius const Vector2f inv_radius filter radius inversion","title":"Public Attributes"},{"location":"Classes/classdakku_1_1Filter/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Classes/classdakku_1_1Filter/#function-filter","text":"explicit Filter ( const Vector2f & radius ) Construct a new Filter object The filter's overall extent in each direction is twice the value given in radius Parameters : radius radius of the filter","title":"function Filter"},{"location":"Classes/classdakku_1_1Filter/#function-evaluate","text":"virtual float evaluate ( const Point2f & p ) const = 0 Given a 2D point which is relative to the center of the filter, the filter's value at that point is returned. Parameters : p the given 2D point Return : float filter's value Reimplemented by : dakku::BoxFilter::evaluate , dakku::TriangleFilter::evaluate","title":"function evaluate"},{"location":"Classes/classdakku_1_1Filter/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"Classes/classdakku_1_1Filter/#variable-radius","text":"const Vector2f radius ; filter radius","title":"variable radius"},{"location":"Classes/classdakku_1_1Filter/#variable-inv_radius","text":"const Vector2f inv_radius ; filter radius inversion Updated on 2022-04-30 at 15:46:11 +0000","title":"variable inv_radius"},{"location":"Classes/classdakku_1_1GlobalMemoryArena/","text":"dakku::GlobalMemoryArena global memory arena #include <memory.h> Public Functions Name MemoryArena & instance () get memory arena instance Public Functions Documentation function instance static MemoryArena & instance () get memory arena instance Updated on 2022-04-30 at 15:46:11 +0000","title":"dakku::GlobalMemoryArena"},{"location":"Classes/classdakku_1_1GlobalMemoryArena/#dakkuglobalmemoryarena","text":"global memory arena #include <memory.h>","title":"dakku::GlobalMemoryArena"},{"location":"Classes/classdakku_1_1GlobalMemoryArena/#public-functions","text":"Name MemoryArena & instance () get memory arena instance","title":"Public Functions"},{"location":"Classes/classdakku_1_1GlobalMemoryArena/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Classes/classdakku_1_1GlobalMemoryArena/#function-instance","text":"static MemoryArena & instance () get memory arena instance Updated on 2022-04-30 at 15:46:11 +0000","title":"function instance"},{"location":"Classes/classdakku_1_1Logger/","text":"dakku::Logger logger class #include <logger.h> Public Functions Name const Logger & get () get logger instance spdlog::logger * handle () const get raw spdlog::logger handle Public Functions Documentation function get static const Logger & get () get logger instance Return : the logger instance function handle inline spdlog :: logger * handle () const get raw spdlog::logger handle Return : the corresponding spdlog::logger Updated on 2022-04-30 at 15:46:11 +0000","title":"dakku::Logger"},{"location":"Classes/classdakku_1_1Logger/#dakkulogger","text":"logger class #include <logger.h>","title":"dakku::Logger"},{"location":"Classes/classdakku_1_1Logger/#public-functions","text":"Name const Logger & get () get logger instance spdlog::logger * handle () const get raw spdlog::logger handle","title":"Public Functions"},{"location":"Classes/classdakku_1_1Logger/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Classes/classdakku_1_1Logger/#function-get","text":"static const Logger & get () get logger instance Return : the logger instance","title":"function get"},{"location":"Classes/classdakku_1_1Logger/#function-handle","text":"inline spdlog :: logger * handle () const get raw spdlog::logger handle Return : the corresponding spdlog::logger Updated on 2022-04-30 at 15:46:11 +0000","title":"function handle"},{"location":"Classes/classdakku_1_1Lua/","text":"dakku::Lua dakku lua state #include <lua.h> Public Functions Name Lua & instance () get lua instance sol::state & get_state () get lua state Public Functions Documentation function instance static Lua & instance () get lua instance function get_state sol :: state & get_state () get lua state Updated on 2022-04-30 at 15:46:11 +0000","title":"dakku::Lua"},{"location":"Classes/classdakku_1_1Lua/#dakkulua","text":"dakku lua state #include <lua.h>","title":"dakku::Lua"},{"location":"Classes/classdakku_1_1Lua/#public-functions","text":"Name Lua & instance () get lua instance sol::state & get_state () get lua state","title":"Public Functions"},{"location":"Classes/classdakku_1_1Lua/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Classes/classdakku_1_1Lua/#function-instance","text":"static Lua & instance () get lua instance","title":"function instance"},{"location":"Classes/classdakku_1_1Lua/#function-get_state","text":"sol :: state & get_state () get lua state Updated on 2022-04-30 at 15:46:11 +0000","title":"function get_state"},{"location":"Classes/classdakku_1_1MemoryArena/","text":"dakku::MemoryArena memory arena (unsynchronized) #include <memory.h> Public Functions Name MemoryArena () =default MemoryArena (std::pmr::memory_resource * buffer) template <typename T ,typename... Args> T * allocObject (Args &&... args) allocate and construct a object from the arena void release () release the memory arena Public Functions Documentation function MemoryArena explicit MemoryArena () = default function MemoryArena inline explicit MemoryArena ( std :: pmr :: memory_resource * buffer ) function allocObject template < typename T , typename ... Args > inline T * allocObject ( Args && ... args ) allocate and construct a object from the arena Parameters : args arguments Template Parameters : T object type Args argument types Return : T* object instance function release inline void release () release the memory arena Updated on 2022-04-30 at 15:46:11 +0000","title":"dakku::MemoryArena"},{"location":"Classes/classdakku_1_1MemoryArena/#dakkumemoryarena","text":"memory arena (unsynchronized) #include <memory.h>","title":"dakku::MemoryArena"},{"location":"Classes/classdakku_1_1MemoryArena/#public-functions","text":"Name MemoryArena () =default MemoryArena (std::pmr::memory_resource * buffer) template <typename T ,typename... Args> T * allocObject (Args &&... args) allocate and construct a object from the arena void release () release the memory arena","title":"Public Functions"},{"location":"Classes/classdakku_1_1MemoryArena/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Classes/classdakku_1_1MemoryArena/#function-memoryarena","text":"explicit MemoryArena () = default","title":"function MemoryArena"},{"location":"Classes/classdakku_1_1MemoryArena/#function-memoryarena_1","text":"inline explicit MemoryArena ( std :: pmr :: memory_resource * buffer )","title":"function MemoryArena"},{"location":"Classes/classdakku_1_1MemoryArena/#function-allocobject","text":"template < typename T , typename ... Args > inline T * allocObject ( Args && ... args ) allocate and construct a object from the arena Parameters : args arguments Template Parameters : T object type Args argument types Return : T* object instance","title":"function allocObject"},{"location":"Classes/classdakku_1_1MemoryArena/#function-release","text":"inline void release () release the memory arena Updated on 2022-04-30 at 15:46:11 +0000","title":"function release"},{"location":"Classes/classdakku_1_1Normal/","text":"dakku::Normal normal More... #include <vector.h> Inherits from dakku::VectorBase< T, S, Normal< T, S > > Public Functions Name Normal operator- () const negation of the vector Normal operator- (const Normal & rhs) const subtraction template <ArithmeticType V> Normal operator- (V rhs) const subtraction Additional inherited members Public Functions inherited from dakku::VectorBase< T, S, Normal< T, S > > Name VectorBase () Construct a new Vector Base object all components initialized to zero. template <ArithmeticType Arg> VectorBase (Arg value) Construct a new Vector Base object all components initalized to value VectorBase (const sol::table & table) Construct a new Vector Base object all components initalized to table. template <ArithmeticType Other,typename OtherDerived > VectorBase (const VectorBase < Other, S, OtherDerived > & other) Construct a new Vector Base object with given values. VectorBase (const VectorBase & other) VectorBase ( VectorBase && other) VectorBase & operator= (const VectorBase & other) VectorBase & operator= ( VectorBase && other) const D & derived () const convert to derived type D & derived () convert to derived type template <ArithmeticType Arg> void set (Arg value) set all components to value template <ArithmeticType Arg> void set_by_index (size_t index, Arg value) set data[index] to value template <ArithmeticType... Args,size_t... Is> void set (std::index_sequence< Is... > , Args &&... args) set data to args template <ArithmeticType... Args> void set (Args &&... args) set data to args template <ArithmeticType Other,typename OtherDerived > void set (const VectorBase < Other, S, OtherDerived > & rhs) set data by rhs 's data const T & get (size_t i) const get i'th component size_t size () const size of the vector std::string to_string () const convert vector to string bool has_nans () const check whether there are nan components D clone () const get a copy const T & operator[] (size_t i) const get i'th value T & operator[] (size_t i) get i'th value D & operator+= (const D & rhs) addition template <ArithmeticType V> D & operator+= (V rhs) addition D operator+ (const D & rhs) const addition template <ArithmeticType V> D operator+ (V rhs) const addition D & operator-= (const D & rhs) subtraction template <ArithmeticType V> D & operator-= (V rhs) subtraction D & operator*= (const D & rhs) multiplication template <ArithmeticType V> D & operator*= (V rhs) multiplication D operator* (const D & rhs) const multiplication template <ArithmeticType V> D operator* (V rhs) const multiplication D & operator/= (const D & rhs) division template <ArithmeticType V> D & operator/= (V rhs) division D operator/ (const D & rhs) const division template <ArithmeticType U> D operator/ (U rhs) const division bool operator== (const VectorBase & rhs) const bool operator!= (const VectorBase & rhs) const decltype(auto) x () const get the first element decltype(auto) x () get the first element decltype(auto) y () const get the second element decltype(auto) y () get the second element decltype(auto) z () const get the third element decltype(auto) z () get the fourth element decltype(auto) w () const get the fourth element decltype(auto) w () get the third element size_t max_element_index () const get the index of the max element decltype(auto) max_element () const get the max element in the vector D max (const D & rhs) const element wise max D min (const D & rhs) const element wise min template <typename OtherDerived > decltype(auto) dot (const VectorBase < T, S, OtherDerived > & rhs) const dot product between two vectors decltype(auto) squared_norm () const squared norm decltype(auto) norm () const norm decltype(auto) length () const length decltype(auto) distance (const D & rhs) const the distance D abs () const abs D cross (const D & rhs) const cross product bool is_zero () const check whether all components are zero D sqrt () const element-wise sqrt template <ArithmeticType E> D pow (E e) const element-wise power D exp () const element-wise exp D floor () const element-wise floor D ceil () const element-wise ceil D lerp (const D & b, T t) const element-wise linear interpolation operator std::span< T, S > () operator std::span< const T, S > () const Friends inherited from dakku::VectorBase< T, S, Normal< T, S > > Name D operator+ (U a, const D & b) addition D operator* (U a, const D & b) multiplication D operator/ (U a, const D & b) division std::ostream & operator<< (std::ostream & os, const VectorBase & vec) output the vector D max (const D & v1, const D & v2) element wise max D min (const D & v1, const D & v2) element wise min decltype(auto) distance (const D & a, const D & b) the distance D abs (const D & v) abs D sqrt (const D & v) element-wise sqrt D pow (const D & v, E e) element-wise power D exp (const D & v) element-wise exp D floor (const D & v) element-wise floor D ceil (const D & v) element-wise ceil D lerp (const D & a, const D & b, T t) element-wise linear interpolation Detailed Description template < typename T , size_t S > class dakku :: Normal ; normal Template Parameters : T type S size Public Functions Documentation function operator- inline Normal operator - () const negation of the vector Return : \\(-\\vec v\\) function operator- inline Normal operator - ( const Normal & rhs ) const subtraction function operator- template < ArithmeticType V > inline Normal operator - ( V rhs ) const subtraction Updated on 2022-04-30 at 15:46:11 +0000","title":"dakku::Normal"},{"location":"Classes/classdakku_1_1Normal/#dakkunormal","text":"normal More... #include <vector.h> Inherits from dakku::VectorBase< T, S, Normal< T, S > >","title":"dakku::Normal"},{"location":"Classes/classdakku_1_1Normal/#public-functions","text":"Name Normal operator- () const negation of the vector Normal operator- (const Normal & rhs) const subtraction template <ArithmeticType V> Normal operator- (V rhs) const subtraction","title":"Public Functions"},{"location":"Classes/classdakku_1_1Normal/#additional-inherited-members","text":"Public Functions inherited from dakku::VectorBase< T, S, Normal< T, S > > Name VectorBase () Construct a new Vector Base object all components initialized to zero. template <ArithmeticType Arg> VectorBase (Arg value) Construct a new Vector Base object all components initalized to value VectorBase (const sol::table & table) Construct a new Vector Base object all components initalized to table. template <ArithmeticType Other,typename OtherDerived > VectorBase (const VectorBase < Other, S, OtherDerived > & other) Construct a new Vector Base object with given values. VectorBase (const VectorBase & other) VectorBase ( VectorBase && other) VectorBase & operator= (const VectorBase & other) VectorBase & operator= ( VectorBase && other) const D & derived () const convert to derived type D & derived () convert to derived type template <ArithmeticType Arg> void set (Arg value) set all components to value template <ArithmeticType Arg> void set_by_index (size_t index, Arg value) set data[index] to value template <ArithmeticType... Args,size_t... Is> void set (std::index_sequence< Is... > , Args &&... args) set data to args template <ArithmeticType... Args> void set (Args &&... args) set data to args template <ArithmeticType Other,typename OtherDerived > void set (const VectorBase < Other, S, OtherDerived > & rhs) set data by rhs 's data const T & get (size_t i) const get i'th component size_t size () const size of the vector std::string to_string () const convert vector to string bool has_nans () const check whether there are nan components D clone () const get a copy const T & operator[] (size_t i) const get i'th value T & operator[] (size_t i) get i'th value D & operator+= (const D & rhs) addition template <ArithmeticType V> D & operator+= (V rhs) addition D operator+ (const D & rhs) const addition template <ArithmeticType V> D operator+ (V rhs) const addition D & operator-= (const D & rhs) subtraction template <ArithmeticType V> D & operator-= (V rhs) subtraction D & operator*= (const D & rhs) multiplication template <ArithmeticType V> D & operator*= (V rhs) multiplication D operator* (const D & rhs) const multiplication template <ArithmeticType V> D operator* (V rhs) const multiplication D & operator/= (const D & rhs) division template <ArithmeticType V> D & operator/= (V rhs) division D operator/ (const D & rhs) const division template <ArithmeticType U> D operator/ (U rhs) const division bool operator== (const VectorBase & rhs) const bool operator!= (const VectorBase & rhs) const decltype(auto) x () const get the first element decltype(auto) x () get the first element decltype(auto) y () const get the second element decltype(auto) y () get the second element decltype(auto) z () const get the third element decltype(auto) z () get the fourth element decltype(auto) w () const get the fourth element decltype(auto) w () get the third element size_t max_element_index () const get the index of the max element decltype(auto) max_element () const get the max element in the vector D max (const D & rhs) const element wise max D min (const D & rhs) const element wise min template <typename OtherDerived > decltype(auto) dot (const VectorBase < T, S, OtherDerived > & rhs) const dot product between two vectors decltype(auto) squared_norm () const squared norm decltype(auto) norm () const norm decltype(auto) length () const length decltype(auto) distance (const D & rhs) const the distance D abs () const abs D cross (const D & rhs) const cross product bool is_zero () const check whether all components are zero D sqrt () const element-wise sqrt template <ArithmeticType E> D pow (E e) const element-wise power D exp () const element-wise exp D floor () const element-wise floor D ceil () const element-wise ceil D lerp (const D & b, T t) const element-wise linear interpolation operator std::span< T, S > () operator std::span< const T, S > () const Friends inherited from dakku::VectorBase< T, S, Normal< T, S > > Name D operator+ (U a, const D & b) addition D operator* (U a, const D & b) multiplication D operator/ (U a, const D & b) division std::ostream & operator<< (std::ostream & os, const VectorBase & vec) output the vector D max (const D & v1, const D & v2) element wise max D min (const D & v1, const D & v2) element wise min decltype(auto) distance (const D & a, const D & b) the distance D abs (const D & v) abs D sqrt (const D & v) element-wise sqrt D pow (const D & v, E e) element-wise power D exp (const D & v) element-wise exp D floor (const D & v) element-wise floor D ceil (const D & v) element-wise ceil D lerp (const D & a, const D & b, T t) element-wise linear interpolation","title":"Additional inherited members"},{"location":"Classes/classdakku_1_1Normal/#detailed-description","text":"template < typename T , size_t S > class dakku :: Normal ; normal Template Parameters : T type S size","title":"Detailed Description"},{"location":"Classes/classdakku_1_1Normal/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Classes/classdakku_1_1Normal/#function-operator-","text":"inline Normal operator - () const negation of the vector Return : \\(-\\vec v\\)","title":"function operator-"},{"location":"Classes/classdakku_1_1Normal/#function-operator-_1","text":"inline Normal operator - ( const Normal & rhs ) const subtraction","title":"function operator-"},{"location":"Classes/classdakku_1_1Normal/#function-operator-_2","text":"template < ArithmeticType V > inline Normal operator - ( V rhs ) const subtraction Updated on 2022-04-30 at 15:46:11 +0000","title":"function operator-"},{"location":"Classes/classdakku_1_1Point/","text":"dakku::Point point More... #include <vector.h> Inherits from dakku::VectorBase< T, S, Point< T, S > > Public Functions Name Point operator- () const negation of the point template <ArithmeticType V> Point operator- (V rhs) const subtraction Vector < T, S > operator- (const Point & rhs) const subtraction Point operator- (const Vector < T, S > & rhs) const subtraction Friends Name Point operator+ (const Point & a, const Vector < T, S > & b) point + vector => point Additional inherited members Public Functions inherited from dakku::VectorBase< T, S, Point< T, S > > Name VectorBase () Construct a new Vector Base object all components initialized to zero. template <ArithmeticType Arg> VectorBase (Arg value) Construct a new Vector Base object all components initalized to value VectorBase (const sol::table & table) Construct a new Vector Base object all components initalized to table. template <ArithmeticType Other,typename OtherDerived > VectorBase (const VectorBase < Other, S, OtherDerived > & other) Construct a new Vector Base object with given values. VectorBase (const VectorBase & other) VectorBase ( VectorBase && other) VectorBase & operator= (const VectorBase & other) VectorBase & operator= ( VectorBase && other) const D & derived () const convert to derived type D & derived () convert to derived type template <ArithmeticType Arg> void set (Arg value) set all components to value template <ArithmeticType Arg> void set_by_index (size_t index, Arg value) set data[index] to value template <ArithmeticType... Args,size_t... Is> void set (std::index_sequence< Is... > , Args &&... args) set data to args template <ArithmeticType... Args> void set (Args &&... args) set data to args template <ArithmeticType Other,typename OtherDerived > void set (const VectorBase < Other, S, OtherDerived > & rhs) set data by rhs 's data const T & get (size_t i) const get i'th component size_t size () const size of the vector std::string to_string () const convert vector to string bool has_nans () const check whether there are nan components D clone () const get a copy const T & operator[] (size_t i) const get i'th value T & operator[] (size_t i) get i'th value D & operator+= (const D & rhs) addition template <ArithmeticType V> D & operator+= (V rhs) addition D & operator-= (const D & rhs) subtraction template <ArithmeticType V> D & operator-= (V rhs) subtraction D & operator*= (const D & rhs) multiplication template <ArithmeticType V> D & operator*= (V rhs) multiplication D operator* (const D & rhs) const multiplication template <ArithmeticType V> D operator* (V rhs) const multiplication D & operator/= (const D & rhs) division template <ArithmeticType V> D & operator/= (V rhs) division D operator/ (const D & rhs) const division template <ArithmeticType U> D operator/ (U rhs) const division bool operator== (const VectorBase & rhs) const bool operator!= (const VectorBase & rhs) const decltype(auto) x () const get the first element decltype(auto) x () get the first element decltype(auto) y () const get the second element decltype(auto) y () get the second element decltype(auto) z () const get the third element decltype(auto) z () get the fourth element decltype(auto) w () const get the fourth element decltype(auto) w () get the third element size_t max_element_index () const get the index of the max element decltype(auto) max_element () const get the max element in the vector D max (const D & rhs) const element wise max D min (const D & rhs) const element wise min template <typename OtherDerived > decltype(auto) dot (const VectorBase < T, S, OtherDerived > & rhs) const dot product between two vectors decltype(auto) squared_norm () const squared norm decltype(auto) norm () const norm decltype(auto) length () const length decltype(auto) distance (const D & rhs) const the distance D abs () const abs D cross (const D & rhs) const cross product bool is_zero () const check whether all components are zero D sqrt () const element-wise sqrt template <ArithmeticType E> D pow (E e) const element-wise power D exp () const element-wise exp D floor () const element-wise floor D ceil () const element-wise ceil D lerp (const D & b, T t) const element-wise linear interpolation operator std::span< T, S > () operator std::span< const T, S > () const Friends inherited from dakku::VectorBase< T, S, Point< T, S > > Name D operator* (U a, const D & b) multiplication D operator/ (U a, const D & b) division std::ostream & operator<< (std::ostream & os, const VectorBase & vec) output the vector D max (const D & v1, const D & v2) element wise max D min (const D & v1, const D & v2) element wise min decltype(auto) distance (const D & a, const D & b) the distance D abs (const D & v) abs D sqrt (const D & v) element-wise sqrt D pow (const D & v, E e) element-wise power D exp (const D & v) element-wise exp D floor (const D & v) element-wise floor D ceil (const D & v) element-wise ceil D lerp (const D & a, const D & b, T t) element-wise linear interpolation Detailed Description template < typename T , size_t S > class dakku :: Point ; point Template Parameters : T type S size Public Functions Documentation function operator- inline Point operator - () const negation of the point Return : \\(-v\\) function operator- template < ArithmeticType V > inline Point operator - ( V rhs ) const subtraction function operator- inline Vector < T , S > operator - ( const Point & rhs ) const subtraction function operator- inline Point operator - ( const Vector < T , S > & rhs ) const subtraction Friends friend operator+ friend Point operator + ( const Point & a , const Vector < T , S > & b ); point + vector => point Updated on 2022-04-30 at 15:46:11 +0000","title":"dakku::Point"},{"location":"Classes/classdakku_1_1Point/#dakkupoint","text":"point More... #include <vector.h> Inherits from dakku::VectorBase< T, S, Point< T, S > >","title":"dakku::Point"},{"location":"Classes/classdakku_1_1Point/#public-functions","text":"Name Point operator- () const negation of the point template <ArithmeticType V> Point operator- (V rhs) const subtraction Vector < T, S > operator- (const Point & rhs) const subtraction Point operator- (const Vector < T, S > & rhs) const subtraction","title":"Public Functions"},{"location":"Classes/classdakku_1_1Point/#friends","text":"Name Point operator+ (const Point & a, const Vector < T, S > & b) point + vector => point","title":"Friends"},{"location":"Classes/classdakku_1_1Point/#additional-inherited-members","text":"Public Functions inherited from dakku::VectorBase< T, S, Point< T, S > > Name VectorBase () Construct a new Vector Base object all components initialized to zero. template <ArithmeticType Arg> VectorBase (Arg value) Construct a new Vector Base object all components initalized to value VectorBase (const sol::table & table) Construct a new Vector Base object all components initalized to table. template <ArithmeticType Other,typename OtherDerived > VectorBase (const VectorBase < Other, S, OtherDerived > & other) Construct a new Vector Base object with given values. VectorBase (const VectorBase & other) VectorBase ( VectorBase && other) VectorBase & operator= (const VectorBase & other) VectorBase & operator= ( VectorBase && other) const D & derived () const convert to derived type D & derived () convert to derived type template <ArithmeticType Arg> void set (Arg value) set all components to value template <ArithmeticType Arg> void set_by_index (size_t index, Arg value) set data[index] to value template <ArithmeticType... Args,size_t... Is> void set (std::index_sequence< Is... > , Args &&... args) set data to args template <ArithmeticType... Args> void set (Args &&... args) set data to args template <ArithmeticType Other,typename OtherDerived > void set (const VectorBase < Other, S, OtherDerived > & rhs) set data by rhs 's data const T & get (size_t i) const get i'th component size_t size () const size of the vector std::string to_string () const convert vector to string bool has_nans () const check whether there are nan components D clone () const get a copy const T & operator[] (size_t i) const get i'th value T & operator[] (size_t i) get i'th value D & operator+= (const D & rhs) addition template <ArithmeticType V> D & operator+= (V rhs) addition D & operator-= (const D & rhs) subtraction template <ArithmeticType V> D & operator-= (V rhs) subtraction D & operator*= (const D & rhs) multiplication template <ArithmeticType V> D & operator*= (V rhs) multiplication D operator* (const D & rhs) const multiplication template <ArithmeticType V> D operator* (V rhs) const multiplication D & operator/= (const D & rhs) division template <ArithmeticType V> D & operator/= (V rhs) division D operator/ (const D & rhs) const division template <ArithmeticType U> D operator/ (U rhs) const division bool operator== (const VectorBase & rhs) const bool operator!= (const VectorBase & rhs) const decltype(auto) x () const get the first element decltype(auto) x () get the first element decltype(auto) y () const get the second element decltype(auto) y () get the second element decltype(auto) z () const get the third element decltype(auto) z () get the fourth element decltype(auto) w () const get the fourth element decltype(auto) w () get the third element size_t max_element_index () const get the index of the max element decltype(auto) max_element () const get the max element in the vector D max (const D & rhs) const element wise max D min (const D & rhs) const element wise min template <typename OtherDerived > decltype(auto) dot (const VectorBase < T, S, OtherDerived > & rhs) const dot product between two vectors decltype(auto) squared_norm () const squared norm decltype(auto) norm () const norm decltype(auto) length () const length decltype(auto) distance (const D & rhs) const the distance D abs () const abs D cross (const D & rhs) const cross product bool is_zero () const check whether all components are zero D sqrt () const element-wise sqrt template <ArithmeticType E> D pow (E e) const element-wise power D exp () const element-wise exp D floor () const element-wise floor D ceil () const element-wise ceil D lerp (const D & b, T t) const element-wise linear interpolation operator std::span< T, S > () operator std::span< const T, S > () const Friends inherited from dakku::VectorBase< T, S, Point< T, S > > Name D operator* (U a, const D & b) multiplication D operator/ (U a, const D & b) division std::ostream & operator<< (std::ostream & os, const VectorBase & vec) output the vector D max (const D & v1, const D & v2) element wise max D min (const D & v1, const D & v2) element wise min decltype(auto) distance (const D & a, const D & b) the distance D abs (const D & v) abs D sqrt (const D & v) element-wise sqrt D pow (const D & v, E e) element-wise power D exp (const D & v) element-wise exp D floor (const D & v) element-wise floor D ceil (const D & v) element-wise ceil D lerp (const D & a, const D & b, T t) element-wise linear interpolation","title":"Additional inherited members"},{"location":"Classes/classdakku_1_1Point/#detailed-description","text":"template < typename T , size_t S > class dakku :: Point ; point Template Parameters : T type S size","title":"Detailed Description"},{"location":"Classes/classdakku_1_1Point/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Classes/classdakku_1_1Point/#function-operator-","text":"inline Point operator - () const negation of the point Return : \\(-v\\)","title":"function operator-"},{"location":"Classes/classdakku_1_1Point/#function-operator-_1","text":"template < ArithmeticType V > inline Point operator - ( V rhs ) const subtraction","title":"function operator-"},{"location":"Classes/classdakku_1_1Point/#function-operator-_2","text":"inline Vector < T , S > operator - ( const Point & rhs ) const subtraction","title":"function operator-"},{"location":"Classes/classdakku_1_1Point/#function-operator-_3","text":"inline Point operator - ( const Vector < T , S > & rhs ) const subtraction","title":"function operator-"},{"location":"Classes/classdakku_1_1Point/#friends_1","text":"","title":"Friends"},{"location":"Classes/classdakku_1_1Point/#friend-operator","text":"friend Point operator + ( const Point & a , const Vector < T , S > & b ); point + vector => point Updated on 2022-04-30 at 15:46:11 +0000","title":"friend operator+"},{"location":"Classes/classdakku_1_1Ray/","text":"dakku::Ray ray #include <ray.h> Inherited by dakku::RayDifferential Public Functions Name Ray () =default Ray ( Point3f o, Vector3f d, float t_max =INF) Point3f operator() (float t) const get the point on the ray at \\(t\\) bool has_nans () const check whether the ray has nans Public Attributes Name Point3f o ray origin Vector3f d ray direction (note: it may not be normalized) float tMax ray max time Public Functions Documentation function Ray Ray () = default function Ray inline explicit Ray ( Point3f o , Vector3f d , float t_max = INF ) function operator() inline Point3f operator ()( float t ) const get the point on the ray at \\(t\\) function has_nans inline bool has_nans () const check whether the ray has nans Public Attributes Documentation variable o Point3f o ; ray origin variable d Vector3f d ; ray direction (note: it may not be normalized) variable tMax float tMax { INF }; ray max time Updated on 2022-04-30 at 15:46:11 +0000","title":"dakku::Ray"},{"location":"Classes/classdakku_1_1Ray/#dakkuray","text":"ray #include <ray.h> Inherited by dakku::RayDifferential","title":"dakku::Ray"},{"location":"Classes/classdakku_1_1Ray/#public-functions","text":"Name Ray () =default Ray ( Point3f o, Vector3f d, float t_max =INF) Point3f operator() (float t) const get the point on the ray at \\(t\\) bool has_nans () const check whether the ray has nans","title":"Public Functions"},{"location":"Classes/classdakku_1_1Ray/#public-attributes","text":"Name Point3f o ray origin Vector3f d ray direction (note: it may not be normalized) float tMax ray max time","title":"Public Attributes"},{"location":"Classes/classdakku_1_1Ray/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Classes/classdakku_1_1Ray/#function-ray","text":"Ray () = default","title":"function Ray"},{"location":"Classes/classdakku_1_1Ray/#function-ray_1","text":"inline explicit Ray ( Point3f o , Vector3f d , float t_max = INF )","title":"function Ray"},{"location":"Classes/classdakku_1_1Ray/#function-operator","text":"inline Point3f operator ()( float t ) const get the point on the ray at \\(t\\)","title":"function operator()"},{"location":"Classes/classdakku_1_1Ray/#function-has_nans","text":"inline bool has_nans () const check whether the ray has nans","title":"function has_nans"},{"location":"Classes/classdakku_1_1Ray/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"Classes/classdakku_1_1Ray/#variable-o","text":"Point3f o ; ray origin","title":"variable o"},{"location":"Classes/classdakku_1_1Ray/#variable-d","text":"Vector3f d ; ray direction (note: it may not be normalized)","title":"variable d"},{"location":"Classes/classdakku_1_1Ray/#variable-tmax","text":"float tMax { INF }; ray max time Updated on 2022-04-30 at 15:46:11 +0000","title":"variable tMax"},{"location":"Classes/classdakku_1_1RayDifferential/","text":"dakku::RayDifferential differential ray #include <ray.h> Inherits from dakku::Ray Public Functions Name RayDifferential () =default RayDifferential (const Point3f & o, const Vector3f & d, float t_max =INF) bool has_nans () const check whether the ray differentials has nans void scale_differentials (float s) scale the differential of the ray Public Attributes Name bool has_differentials has differentials Point3f rx_origin x sub ray origin (x + 1, y) Point3f ry_origin y sub ray origin (x, y + 1) Vector3f rx_direction x sub ray direction Vector3f ry_direction y sub ray direction Additional inherited members Public Functions inherited from dakku::Ray Name Ray () =default Ray ( Point3f o, Vector3f d, float t_max =INF) Point3f operator() (float t) const get the point on the ray at \\(t\\) Public Attributes inherited from dakku::Ray Name Point3f o ray origin Vector3f d ray direction (note: it may not be normalized) float tMax ray max time Public Functions Documentation function RayDifferential RayDifferential () = default function RayDifferential inline explicit RayDifferential ( const Point3f & o , const Vector3f & d , float t_max = INF ) function has_nans inline bool has_nans () const check whether the ray differentials has nans function scale_differentials inline void scale_differentials ( float s ) scale the differential of the ray Parameters : s scale let \\(c\\) be the camera position \\(o'' = o + s (o \\rightarrow o')\\) \\(d' = c \\rightarrow o'\\) \\(d'' = c \\rightarrow o'' = (c \\rightarrow o) + (o \\rightarrow o'') = d + s (d' - d)\\) Public Attributes Documentation variable has_differentials bool has_differentials { false }; has differentials variable rx_origin Point3f rx_origin ; x sub ray origin (x + 1, y) variable ry_origin Point3f ry_origin ; y sub ray origin (x, y + 1) variable rx_direction Vector3f rx_direction ; x sub ray direction variable ry_direction Vector3f ry_direction ; y sub ray direction Updated on 2022-04-30 at 15:46:11 +0000","title":"dakku::RayDifferential"},{"location":"Classes/classdakku_1_1RayDifferential/#dakkuraydifferential","text":"differential ray #include <ray.h> Inherits from dakku::Ray","title":"dakku::RayDifferential"},{"location":"Classes/classdakku_1_1RayDifferential/#public-functions","text":"Name RayDifferential () =default RayDifferential (const Point3f & o, const Vector3f & d, float t_max =INF) bool has_nans () const check whether the ray differentials has nans void scale_differentials (float s) scale the differential of the ray","title":"Public Functions"},{"location":"Classes/classdakku_1_1RayDifferential/#public-attributes","text":"Name bool has_differentials has differentials Point3f rx_origin x sub ray origin (x + 1, y) Point3f ry_origin y sub ray origin (x, y + 1) Vector3f rx_direction x sub ray direction Vector3f ry_direction y sub ray direction","title":"Public Attributes"},{"location":"Classes/classdakku_1_1RayDifferential/#additional-inherited-members","text":"Public Functions inherited from dakku::Ray Name Ray () =default Ray ( Point3f o, Vector3f d, float t_max =INF) Point3f operator() (float t) const get the point on the ray at \\(t\\) Public Attributes inherited from dakku::Ray Name Point3f o ray origin Vector3f d ray direction (note: it may not be normalized) float tMax ray max time","title":"Additional inherited members"},{"location":"Classes/classdakku_1_1RayDifferential/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Classes/classdakku_1_1RayDifferential/#function-raydifferential","text":"RayDifferential () = default","title":"function RayDifferential"},{"location":"Classes/classdakku_1_1RayDifferential/#function-raydifferential_1","text":"inline explicit RayDifferential ( const Point3f & o , const Vector3f & d , float t_max = INF )","title":"function RayDifferential"},{"location":"Classes/classdakku_1_1RayDifferential/#function-has_nans","text":"inline bool has_nans () const check whether the ray differentials has nans","title":"function has_nans"},{"location":"Classes/classdakku_1_1RayDifferential/#function-scale_differentials","text":"inline void scale_differentials ( float s ) scale the differential of the ray Parameters : s scale let \\(c\\) be the camera position \\(o'' = o + s (o \\rightarrow o')\\) \\(d' = c \\rightarrow o'\\) \\(d'' = c \\rightarrow o'' = (c \\rightarrow o) + (o \\rightarrow o'') = d + s (d' - d)\\)","title":"function scale_differentials"},{"location":"Classes/classdakku_1_1RayDifferential/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"Classes/classdakku_1_1RayDifferential/#variable-has_differentials","text":"bool has_differentials { false }; has differentials","title":"variable has_differentials"},{"location":"Classes/classdakku_1_1RayDifferential/#variable-rx_origin","text":"Point3f rx_origin ; x sub ray origin (x + 1, y)","title":"variable rx_origin"},{"location":"Classes/classdakku_1_1RayDifferential/#variable-ry_origin","text":"Point3f ry_origin ; y sub ray origin (x, y + 1)","title":"variable ry_origin"},{"location":"Classes/classdakku_1_1RayDifferential/#variable-rx_direction","text":"Vector3f rx_direction ; x sub ray direction","title":"variable rx_direction"},{"location":"Classes/classdakku_1_1RayDifferential/#variable-ry_direction","text":"Vector3f ry_direction ; y sub ray direction Updated on 2022-04-30 at 15:46:11 +0000","title":"variable ry_direction"},{"location":"Classes/classdakku_1_1TriangleFilter/","text":"dakku::TriangleFilter triangle filter the weight falls off linearly from the filter center over the square extent of the filter #include <triangle.h> Inherits from dakku::Filter Public Functions Name virtual float evaluate (const Point2f & p) const override Given a 2D point which is relative to the center of the filter, the filter's value at that point is returned. Filter (const Vector2f & radius) Construct a new Filter object The filter's overall extent in each direction is twice the value given in radius Additional inherited members Public Attributes inherited from dakku::Filter Name const Vector2f radius filter radius const Vector2f inv_radius filter radius inversion Public Functions Documentation function evaluate virtual float evaluate ( const Point2f & p ) const override Given a 2D point which is relative to the center of the filter, the filter's value at that point is returned. Parameters : p the given 2D point Return : float filter's value Reimplements : dakku::Filter::evaluate function Filter explicit Filter ( const Vector2f & radius ) Construct a new Filter object The filter's overall extent in each direction is twice the value given in radius Parameters : radius radius of the filter Updated on 2022-04-30 at 15:46:11 +0000","title":"dakku::TriangleFilter"},{"location":"Classes/classdakku_1_1TriangleFilter/#dakkutrianglefilter","text":"triangle filter the weight falls off linearly from the filter center over the square extent of the filter #include <triangle.h> Inherits from dakku::Filter","title":"dakku::TriangleFilter"},{"location":"Classes/classdakku_1_1TriangleFilter/#public-functions","text":"Name virtual float evaluate (const Point2f & p) const override Given a 2D point which is relative to the center of the filter, the filter's value at that point is returned. Filter (const Vector2f & radius) Construct a new Filter object The filter's overall extent in each direction is twice the value given in radius","title":"Public Functions"},{"location":"Classes/classdakku_1_1TriangleFilter/#additional-inherited-members","text":"Public Attributes inherited from dakku::Filter Name const Vector2f radius filter radius const Vector2f inv_radius filter radius inversion","title":"Additional inherited members"},{"location":"Classes/classdakku_1_1TriangleFilter/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Classes/classdakku_1_1TriangleFilter/#function-evaluate","text":"virtual float evaluate ( const Point2f & p ) const override Given a 2D point which is relative to the center of the filter, the filter's value at that point is returned. Parameters : p the given 2D point Return : float filter's value Reimplements : dakku::Filter::evaluate","title":"function evaluate"},{"location":"Classes/classdakku_1_1TriangleFilter/#function-filter","text":"explicit Filter ( const Vector2f & radius ) Construct a new Filter object The filter's overall extent in each direction is twice the value given in radius Parameters : radius radius of the filter Updated on 2022-04-30 at 15:46:11 +0000","title":"function Filter"},{"location":"Classes/classdakku_1_1Vector/","text":"dakku::Vector vector More... #include <vector.h> Inherits from dakku::VectorBase< T, S, Vector< T, S > > Public Functions Name Vector operator- () const negation of the vector Vector operator- (const Vector & rhs) const subtraction template <ArithmeticType V> Vector operator- (V rhs) const subtraction Additional inherited members Public Functions inherited from dakku::VectorBase< T, S, Vector< T, S > > Name VectorBase () Construct a new Vector Base object all components initialized to zero. template <ArithmeticType Arg> VectorBase (Arg value) Construct a new Vector Base object all components initalized to value VectorBase (const sol::table & table) Construct a new Vector Base object all components initalized to table. template <ArithmeticType Other,typename OtherDerived > VectorBase (const VectorBase < Other, S, OtherDerived > & other) Construct a new Vector Base object with given values. VectorBase (const VectorBase & other) VectorBase ( VectorBase && other) VectorBase & operator= (const VectorBase & other) VectorBase & operator= ( VectorBase && other) const D & derived () const convert to derived type D & derived () convert to derived type template <ArithmeticType Arg> void set (Arg value) set all components to value template <ArithmeticType Arg> void set_by_index (size_t index, Arg value) set data[index] to value template <ArithmeticType... Args,size_t... Is> void set (std::index_sequence< Is... > , Args &&... args) set data to args template <ArithmeticType... Args> void set (Args &&... args) set data to args template <ArithmeticType Other,typename OtherDerived > void set (const VectorBase < Other, S, OtherDerived > & rhs) set data by rhs 's data const T & get (size_t i) const get i'th component size_t size () const size of the vector std::string to_string () const convert vector to string bool has_nans () const check whether there are nan components D clone () const get a copy const T & operator[] (size_t i) const get i'th value T & operator[] (size_t i) get i'th value D & operator+= (const D & rhs) addition template <ArithmeticType V> D & operator+= (V rhs) addition D operator+ (const D & rhs) const addition template <ArithmeticType V> D operator+ (V rhs) const addition D & operator-= (const D & rhs) subtraction template <ArithmeticType V> D & operator-= (V rhs) subtraction D & operator*= (const D & rhs) multiplication template <ArithmeticType V> D & operator*= (V rhs) multiplication D operator* (const D & rhs) const multiplication template <ArithmeticType V> D operator* (V rhs) const multiplication D & operator/= (const D & rhs) division template <ArithmeticType V> D & operator/= (V rhs) division D operator/ (const D & rhs) const division template <ArithmeticType U> D operator/ (U rhs) const division bool operator== (const VectorBase & rhs) const bool operator!= (const VectorBase & rhs) const decltype(auto) x () const get the first element decltype(auto) x () get the first element decltype(auto) y () const get the second element decltype(auto) y () get the second element decltype(auto) z () const get the third element decltype(auto) z () get the fourth element decltype(auto) w () const get the fourth element decltype(auto) w () get the third element size_t max_element_index () const get the index of the max element decltype(auto) max_element () const get the max element in the vector D max (const D & rhs) const element wise max D min (const D & rhs) const element wise min template <typename OtherDerived > decltype(auto) dot (const VectorBase < T, S, OtherDerived > & rhs) const dot product between two vectors decltype(auto) squared_norm () const squared norm decltype(auto) norm () const norm decltype(auto) length () const length decltype(auto) distance (const D & rhs) const the distance D abs () const abs D cross (const D & rhs) const cross product bool is_zero () const check whether all components are zero D sqrt () const element-wise sqrt template <ArithmeticType E> D pow (E e) const element-wise power D exp () const element-wise exp D floor () const element-wise floor D ceil () const element-wise ceil D lerp (const D & b, T t) const element-wise linear interpolation operator std::span< T, S > () operator std::span< const T, S > () const Friends inherited from dakku::VectorBase< T, S, Vector< T, S > > Name D operator+ (U a, const D & b) addition D operator* (U a, const D & b) multiplication D operator/ (U a, const D & b) division std::ostream & operator<< (std::ostream & os, const VectorBase & vec) output the vector D max (const D & v1, const D & v2) element wise max D min (const D & v1, const D & v2) element wise min decltype(auto) distance (const D & a, const D & b) the distance D abs (const D & v) abs D sqrt (const D & v) element-wise sqrt D pow (const D & v, E e) element-wise power D exp (const D & v) element-wise exp D floor (const D & v) element-wise floor D ceil (const D & v) element-wise ceil D lerp (const D & a, const D & b, T t) element-wise linear interpolation Detailed Description template < typename T , size_t S > class dakku :: Vector ; vector Template Parameters : T type S size Public Functions Documentation function operator- inline Vector operator - () const negation of the vector Return : \\(-\\vec v\\) function operator- inline Vector operator - ( const Vector & rhs ) const subtraction function operator- template < ArithmeticType V > inline Vector operator - ( V rhs ) const subtraction Updated on 2022-04-30 at 15:46:11 +0000","title":"dakku::Vector"},{"location":"Classes/classdakku_1_1Vector/#dakkuvector","text":"vector More... #include <vector.h> Inherits from dakku::VectorBase< T, S, Vector< T, S > >","title":"dakku::Vector"},{"location":"Classes/classdakku_1_1Vector/#public-functions","text":"Name Vector operator- () const negation of the vector Vector operator- (const Vector & rhs) const subtraction template <ArithmeticType V> Vector operator- (V rhs) const subtraction","title":"Public Functions"},{"location":"Classes/classdakku_1_1Vector/#additional-inherited-members","text":"Public Functions inherited from dakku::VectorBase< T, S, Vector< T, S > > Name VectorBase () Construct a new Vector Base object all components initialized to zero. template <ArithmeticType Arg> VectorBase (Arg value) Construct a new Vector Base object all components initalized to value VectorBase (const sol::table & table) Construct a new Vector Base object all components initalized to table. template <ArithmeticType Other,typename OtherDerived > VectorBase (const VectorBase < Other, S, OtherDerived > & other) Construct a new Vector Base object with given values. VectorBase (const VectorBase & other) VectorBase ( VectorBase && other) VectorBase & operator= (const VectorBase & other) VectorBase & operator= ( VectorBase && other) const D & derived () const convert to derived type D & derived () convert to derived type template <ArithmeticType Arg> void set (Arg value) set all components to value template <ArithmeticType Arg> void set_by_index (size_t index, Arg value) set data[index] to value template <ArithmeticType... Args,size_t... Is> void set (std::index_sequence< Is... > , Args &&... args) set data to args template <ArithmeticType... Args> void set (Args &&... args) set data to args template <ArithmeticType Other,typename OtherDerived > void set (const VectorBase < Other, S, OtherDerived > & rhs) set data by rhs 's data const T & get (size_t i) const get i'th component size_t size () const size of the vector std::string to_string () const convert vector to string bool has_nans () const check whether there are nan components D clone () const get a copy const T & operator[] (size_t i) const get i'th value T & operator[] (size_t i) get i'th value D & operator+= (const D & rhs) addition template <ArithmeticType V> D & operator+= (V rhs) addition D operator+ (const D & rhs) const addition template <ArithmeticType V> D operator+ (V rhs) const addition D & operator-= (const D & rhs) subtraction template <ArithmeticType V> D & operator-= (V rhs) subtraction D & operator*= (const D & rhs) multiplication template <ArithmeticType V> D & operator*= (V rhs) multiplication D operator* (const D & rhs) const multiplication template <ArithmeticType V> D operator* (V rhs) const multiplication D & operator/= (const D & rhs) division template <ArithmeticType V> D & operator/= (V rhs) division D operator/ (const D & rhs) const division template <ArithmeticType U> D operator/ (U rhs) const division bool operator== (const VectorBase & rhs) const bool operator!= (const VectorBase & rhs) const decltype(auto) x () const get the first element decltype(auto) x () get the first element decltype(auto) y () const get the second element decltype(auto) y () get the second element decltype(auto) z () const get the third element decltype(auto) z () get the fourth element decltype(auto) w () const get the fourth element decltype(auto) w () get the third element size_t max_element_index () const get the index of the max element decltype(auto) max_element () const get the max element in the vector D max (const D & rhs) const element wise max D min (const D & rhs) const element wise min template <typename OtherDerived > decltype(auto) dot (const VectorBase < T, S, OtherDerived > & rhs) const dot product between two vectors decltype(auto) squared_norm () const squared norm decltype(auto) norm () const norm decltype(auto) length () const length decltype(auto) distance (const D & rhs) const the distance D abs () const abs D cross (const D & rhs) const cross product bool is_zero () const check whether all components are zero D sqrt () const element-wise sqrt template <ArithmeticType E> D pow (E e) const element-wise power D exp () const element-wise exp D floor () const element-wise floor D ceil () const element-wise ceil D lerp (const D & b, T t) const element-wise linear interpolation operator std::span< T, S > () operator std::span< const T, S > () const Friends inherited from dakku::VectorBase< T, S, Vector< T, S > > Name D operator+ (U a, const D & b) addition D operator* (U a, const D & b) multiplication D operator/ (U a, const D & b) division std::ostream & operator<< (std::ostream & os, const VectorBase & vec) output the vector D max (const D & v1, const D & v2) element wise max D min (const D & v1, const D & v2) element wise min decltype(auto) distance (const D & a, const D & b) the distance D abs (const D & v) abs D sqrt (const D & v) element-wise sqrt D pow (const D & v, E e) element-wise power D exp (const D & v) element-wise exp D floor (const D & v) element-wise floor D ceil (const D & v) element-wise ceil D lerp (const D & a, const D & b, T t) element-wise linear interpolation","title":"Additional inherited members"},{"location":"Classes/classdakku_1_1Vector/#detailed-description","text":"template < typename T , size_t S > class dakku :: Vector ; vector Template Parameters : T type S size","title":"Detailed Description"},{"location":"Classes/classdakku_1_1Vector/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Classes/classdakku_1_1Vector/#function-operator-","text":"inline Vector operator - () const negation of the vector Return : \\(-\\vec v\\)","title":"function operator-"},{"location":"Classes/classdakku_1_1Vector/#function-operator-_1","text":"inline Vector operator - ( const Vector & rhs ) const subtraction","title":"function operator-"},{"location":"Classes/classdakku_1_1Vector/#function-operator-_2","text":"template < ArithmeticType V > inline Vector operator - ( V rhs ) const subtraction Updated on 2022-04-30 at 15:46:11 +0000","title":"function operator-"},{"location":"Classes/classdakku_1_1VectorBase/","text":"dakku::VectorBase vector base More... #include <vector_base.h> Inherited by dakku::Point< int, 2 > , dakku::Point< float, 3 > , dakku::Vector< float, 3 > Public Functions Name VectorBase () Construct a new Vector Base object all components initialized to zero. template <ArithmeticType Arg> VectorBase (Arg value) Construct a new Vector Base object all components initalized to value VectorBase (const sol::table & table) Construct a new Vector Base object all components initalized to table. template <ArithmeticType Other,typename OtherDerived > VectorBase (const VectorBase < Other, S, OtherDerived > & other) Construct a new Vector Base object with given values. VectorBase (const VectorBase & other) VectorBase ( VectorBase && other) VectorBase & operator= (const VectorBase & other) VectorBase & operator= ( VectorBase && other) const D & derived () const convert to derived type D & derived () convert to derived type template <ArithmeticType Arg> void set (Arg value) set all components to value template <ArithmeticType Arg> void set_by_index (size_t index, Arg value) set data[index] to value template <ArithmeticType... Args,size_t... Is> void set (std::index_sequence< Is... > , Args &&... args) set data to args template <ArithmeticType... Args> void set (Args &&... args) set data to args template <ArithmeticType Other,typename OtherDerived > void set (const VectorBase < Other, S, OtherDerived > & rhs) set data by rhs 's data const T & get (size_t i) const get i'th component size_t size () const size of the vector std::string to_string () const convert vector to string bool has_nans () const check whether there are nan components D clone () const get a copy const T & operator[] (size_t i) const get i'th value T & operator[] (size_t i) get i'th value D & operator+= (const D & rhs) addition template <ArithmeticType V> D & operator+= (V rhs) addition D operator+ (const D & rhs) const addition template <ArithmeticType V> D operator+ (V rhs) const addition D & operator-= (const D & rhs) subtraction template <ArithmeticType V> D & operator-= (V rhs) subtraction D & operator*= (const D & rhs) multiplication template <ArithmeticType V> D & operator*= (V rhs) multiplication D operator* (const D & rhs) const multiplication template <ArithmeticType V> D operator* (V rhs) const multiplication D & operator/= (const D & rhs) division template <ArithmeticType V> D & operator/= (V rhs) division D operator/ (const D & rhs) const division template <ArithmeticType U> D operator/ (U rhs) const division bool operator== (const VectorBase & rhs) const bool operator!= (const VectorBase & rhs) const decltype(auto) x () const get the first element decltype(auto) x () get the first element decltype(auto) y () const get the second element decltype(auto) y () get the second element decltype(auto) z () const get the third element decltype(auto) z () get the fourth element decltype(auto) w () const get the fourth element decltype(auto) w () get the third element size_t max_element_index () const get the index of the max element decltype(auto) max_element () const get the max element in the vector D max (const D & rhs) const element wise max D min (const D & rhs) const element wise min template <typename OtherDerived > decltype(auto) dot (const VectorBase < T, S, OtherDerived > & rhs) const dot product between two vectors decltype(auto) squared_norm () const squared norm decltype(auto) norm () const norm decltype(auto) length () const length decltype(auto) distance (const D & rhs) const the distance D abs () const abs D cross (const D & rhs) const cross product bool is_zero () const check whether all components are zero D sqrt () const element-wise sqrt template <ArithmeticType E> D pow (E e) const element-wise power D exp () const element-wise exp D floor () const element-wise floor D ceil () const element-wise ceil D lerp (const D & b, T t) const element-wise linear interpolation operator std::span< T, S > () operator std::span< const T, S > () const Friends Name D operator+ (U a, const D & b) addition D operator- (U a, const D & b) subtraction D operator* (U a, const D & b) multiplication D operator/ (U a, const D & b) division std::ostream & operator<< (std::ostream & os, const VectorBase & vec) output the vector D max (const D & v1, const D & v2) element wise max D min (const D & v1, const D & v2) element wise min decltype(auto) distance (const D & a, const D & b) the distance D abs (const D & v) abs D sqrt (const D & v) element-wise sqrt D pow (const D & v, E e) element-wise power D exp (const D & v) element-wise exp D floor (const D & v) element-wise floor D ceil (const D & v) element-wise ceil D lerp (const D & a, const D & b, T t) element-wise linear interpolation Detailed Description template < ArithmeticType T , size_t S , typename D > class dakku :: VectorBase ; vector base Template Parameters : T type S size D derived Public Functions Documentation function VectorBase inline VectorBase () Construct a new Vector Base object all components initialized to zero. function VectorBase template < ArithmeticType Arg > inline VectorBase ( Arg value ) Construct a new Vector Base object all components initalized to value Parameters : value init value Template Parameters : Arg value type function VectorBase inline VectorBase ( const sol :: table & table ) Construct a new Vector Base object all components initalized to table. function VectorBase template < ArithmeticType Other , typename OtherDerived > inline explicit VectorBase ( const VectorBase < Other , S , OtherDerived > & other ) Construct a new Vector Base object with given values. Parameters : args init values expr the given expression Template Parameters : Args value types Other OtherDerived Expr Construct a new Vector Base object with a vector expression function VectorBase inline VectorBase ( const VectorBase & other ) function VectorBase inline VectorBase ( VectorBase && other ) function operator= inline VectorBase & operator = ( const VectorBase & other ) function operator= inline VectorBase & operator = ( VectorBase && other ) function derived inline const D & derived () const convert to derived type function derived inline D & derived () convert to derived type function set template < ArithmeticType Arg > inline void set ( Arg value ) set all components to value Parameters : value the given value Template Parameters : Arg value type function set_by_index template < ArithmeticType Arg > inline void set_by_index ( size_t index , Arg value ) set data[index] to value Parameters : index the index of the component value the given value Template Parameters : Arg value type function set template < ArithmeticType ... Args , size_t ... Is > inline void set ( std :: index_sequence < Is ... > , Args && ... args ) set data to args Parameters : args values Template Parameters : Args value types Is indices (generated by std::index_sequence_for) function set template < ArithmeticType ... Args > inline void set ( Args && ... args ) set data to args Parameters : args values Template Parameters : Args value types function set template < ArithmeticType Other , typename OtherDerived > inline void set ( const VectorBase < Other , S , OtherDerived > & rhs ) set data by rhs 's data Parameters : rhs the given vector Template Parameters : Other rhs type OtherDerived rhs derived type function get inline const T & get ( size_t i ) const get i'th component Parameters : i the index Return : the value function size inline size_t size () const size of the vector Return : size function to_string inline std :: string to_string () const convert vector to string Return : the converted string function has_nans inline bool has_nans () const check whether there are nan components Return : true vector contains nan false vector does not contain nans function clone inline D clone () const get a copy function operator[] inline const T & operator []( size_t i ) const get i'th value Parameters : i index Return : value function operator[] inline T & operator []( size_t i ) get i'th value Parameters : i index Return : value function operator+= inline D & operator += ( const D & rhs ) addition Parameters : rhs another vector Return : this function operator+= template < ArithmeticType V > inline D & operator += ( V rhs ) addition Parameters : rhs scalar Return : this function operator+ inline D operator + ( const D & rhs ) const addition Parameters : rhs another vector Return : result function operator+ template < ArithmeticType V > inline D operator + ( V rhs ) const addition Parameters : rhs another vector Return : result function operator-= inline D & operator -= ( const D & rhs ) subtraction Parameters : rhs another vector Return : this function operator-= template < ArithmeticType V > inline D & operator -= ( V rhs ) subtraction Parameters : rhs scalar Return : this function operator*= inline D & operator *= ( const D & rhs ) multiplication Parameters : rhs another vector Return : this function operator*= template < ArithmeticType V > inline D & operator *= ( V rhs ) multiplication Parameters : rhs scalar Return : this function operator* inline D operator * ( const D & rhs ) const multiplication Parameters : rhs another vector Return : result function operator* template < ArithmeticType V > inline D operator * ( V rhs ) const multiplication Parameters : rhs scalar Return : result function operator/= inline D & operator /= ( const D & rhs ) division Parameters : rhs another vector Return : this function operator/= template < ArithmeticType V > inline D & operator /= ( V rhs ) division Parameters : rhs scalar Return : this function operator/ inline D operator / ( const D & rhs ) const division Parameters : rhs another vector Return : result function operator/ template < ArithmeticType U > inline D operator / ( U rhs ) const division Parameters : rhs scalar Return : result function operator== inline bool operator == ( const VectorBase & rhs ) const function operator!= inline bool operator != ( const VectorBase & rhs ) const function x inline decltype ( auto ) x () const get the first element function x inline decltype ( auto ) x () get the first element function y inline decltype ( auto ) y () const get the second element function y inline decltype ( auto ) y () get the second element function z inline decltype ( auto ) z () const get the third element function z inline decltype ( auto ) z () get the fourth element function w inline decltype ( auto ) w () const get the fourth element function w inline decltype ( auto ) w () get the third element function max_element_index inline size_t max_element_index () const get the index of the max element Return : the index function max_element inline decltype ( auto ) max_element () const get the max element in the vector Return : the max value function max inline D max ( const D & rhs ) const element wise max function min inline D min ( const D & rhs ) const element wise min function dot template < typename OtherDerived > inline decltype ( auto ) dot ( const VectorBase < T , S , OtherDerived > & rhs ) const dot product between two vectors Return : \\(\\vec a \\cdot \\vec b\\) function squared_norm inline decltype ( auto ) squared_norm () const squared norm Return : \\(||v|| ^ 2\\) function norm inline decltype ( auto ) norm () const norm Return : \\(||v||\\) function length inline decltype ( auto ) length () const length Return : \\(||v||\\) function distance inline decltype ( auto ) distance ( const D & rhs ) const the distance function abs inline D abs () const abs function cross inline D cross ( const D & rhs ) const cross product function is_zero inline bool is_zero () const check whether all components are zero function sqrt inline D sqrt () const element-wise sqrt function pow template < ArithmeticType E > inline D pow ( E e ) const element-wise power function exp inline D exp () const element-wise exp function floor inline D floor () const element-wise floor function ceil inline D ceil () const element-wise ceil function lerp inline D lerp ( const D & b , T t ) const element-wise linear interpolation function operator std::span< T, S > inline operator std :: span < T , S > () function operator std::span< const T, S > inline operator std :: span < const T , S > () const Friends friend operator+ friend D operator + ( U a , const D & b ); addition Parameters : a \\(aa\\) b \\(\\vec b\\) Return : elementwise add a friend operator- friend D operator - ( U a , const D & b ); subtraction Parameters : a \\(aa\\) b \\(\\vec b\\) Return : elementwise sub friend operator* friend D operator * ( U a , const D & b ); multiplication Parameters : a \\(aa\\) b \\(\\vec b\\) Return : elementwise mul friend operator/ friend D operator / ( U a , const D & b ); division Parameters : a \\(aa\\) b \\(\\vec b\\) Return : elementwise div (broad cast \\(a\\) ) friend operator<< friend std :: ostream & operator << ( std :: ostream & os , const VectorBase & vec ); output the vector Parameters : os ostream vec the vector to output Return : ostream friend max friend D max ( const D & v1 , const D & v2 ); element wise max friend min friend D min ( const D & v1 , const D & v2 ); element wise min friend distance friend decltype ( auto ) distance ( const D & a , const D & b ); the distance friend abs friend D abs ( const D & v ); abs friend sqrt friend D sqrt ( const D & v ); element-wise sqrt friend pow friend D pow ( const D & v , E e ); element-wise power friend exp friend D exp ( const D & v ); element-wise exp friend floor friend D floor ( const D & v ); element-wise floor friend ceil friend D ceil ( const D & v ); element-wise ceil friend lerp friend D lerp ( const D & a , const D & b , T t ); element-wise linear interpolation Updated on 2022-04-30 at 15:46:11 +0000","title":"dakku::VectorBase"},{"location":"Classes/classdakku_1_1VectorBase/#dakkuvectorbase","text":"vector base More... #include <vector_base.h> Inherited by dakku::Point< int, 2 > , dakku::Point< float, 3 > , dakku::Vector< float, 3 >","title":"dakku::VectorBase"},{"location":"Classes/classdakku_1_1VectorBase/#public-functions","text":"Name VectorBase () Construct a new Vector Base object all components initialized to zero. template <ArithmeticType Arg> VectorBase (Arg value) Construct a new Vector Base object all components initalized to value VectorBase (const sol::table & table) Construct a new Vector Base object all components initalized to table. template <ArithmeticType Other,typename OtherDerived > VectorBase (const VectorBase < Other, S, OtherDerived > & other) Construct a new Vector Base object with given values. VectorBase (const VectorBase & other) VectorBase ( VectorBase && other) VectorBase & operator= (const VectorBase & other) VectorBase & operator= ( VectorBase && other) const D & derived () const convert to derived type D & derived () convert to derived type template <ArithmeticType Arg> void set (Arg value) set all components to value template <ArithmeticType Arg> void set_by_index (size_t index, Arg value) set data[index] to value template <ArithmeticType... Args,size_t... Is> void set (std::index_sequence< Is... > , Args &&... args) set data to args template <ArithmeticType... Args> void set (Args &&... args) set data to args template <ArithmeticType Other,typename OtherDerived > void set (const VectorBase < Other, S, OtherDerived > & rhs) set data by rhs 's data const T & get (size_t i) const get i'th component size_t size () const size of the vector std::string to_string () const convert vector to string bool has_nans () const check whether there are nan components D clone () const get a copy const T & operator[] (size_t i) const get i'th value T & operator[] (size_t i) get i'th value D & operator+= (const D & rhs) addition template <ArithmeticType V> D & operator+= (V rhs) addition D operator+ (const D & rhs) const addition template <ArithmeticType V> D operator+ (V rhs) const addition D & operator-= (const D & rhs) subtraction template <ArithmeticType V> D & operator-= (V rhs) subtraction D & operator*= (const D & rhs) multiplication template <ArithmeticType V> D & operator*= (V rhs) multiplication D operator* (const D & rhs) const multiplication template <ArithmeticType V> D operator* (V rhs) const multiplication D & operator/= (const D & rhs) division template <ArithmeticType V> D & operator/= (V rhs) division D operator/ (const D & rhs) const division template <ArithmeticType U> D operator/ (U rhs) const division bool operator== (const VectorBase & rhs) const bool operator!= (const VectorBase & rhs) const decltype(auto) x () const get the first element decltype(auto) x () get the first element decltype(auto) y () const get the second element decltype(auto) y () get the second element decltype(auto) z () const get the third element decltype(auto) z () get the fourth element decltype(auto) w () const get the fourth element decltype(auto) w () get the third element size_t max_element_index () const get the index of the max element decltype(auto) max_element () const get the max element in the vector D max (const D & rhs) const element wise max D min (const D & rhs) const element wise min template <typename OtherDerived > decltype(auto) dot (const VectorBase < T, S, OtherDerived > & rhs) const dot product between two vectors decltype(auto) squared_norm () const squared norm decltype(auto) norm () const norm decltype(auto) length () const length decltype(auto) distance (const D & rhs) const the distance D abs () const abs D cross (const D & rhs) const cross product bool is_zero () const check whether all components are zero D sqrt () const element-wise sqrt template <ArithmeticType E> D pow (E e) const element-wise power D exp () const element-wise exp D floor () const element-wise floor D ceil () const element-wise ceil D lerp (const D & b, T t) const element-wise linear interpolation operator std::span< T, S > () operator std::span< const T, S > () const","title":"Public Functions"},{"location":"Classes/classdakku_1_1VectorBase/#friends","text":"Name D operator+ (U a, const D & b) addition D operator- (U a, const D & b) subtraction D operator* (U a, const D & b) multiplication D operator/ (U a, const D & b) division std::ostream & operator<< (std::ostream & os, const VectorBase & vec) output the vector D max (const D & v1, const D & v2) element wise max D min (const D & v1, const D & v2) element wise min decltype(auto) distance (const D & a, const D & b) the distance D abs (const D & v) abs D sqrt (const D & v) element-wise sqrt D pow (const D & v, E e) element-wise power D exp (const D & v) element-wise exp D floor (const D & v) element-wise floor D ceil (const D & v) element-wise ceil D lerp (const D & a, const D & b, T t) element-wise linear interpolation","title":"Friends"},{"location":"Classes/classdakku_1_1VectorBase/#detailed-description","text":"template < ArithmeticType T , size_t S , typename D > class dakku :: VectorBase ; vector base Template Parameters : T type S size D derived","title":"Detailed Description"},{"location":"Classes/classdakku_1_1VectorBase/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Classes/classdakku_1_1VectorBase/#function-vectorbase","text":"inline VectorBase () Construct a new Vector Base object all components initialized to zero.","title":"function VectorBase"},{"location":"Classes/classdakku_1_1VectorBase/#function-vectorbase_1","text":"template < ArithmeticType Arg > inline VectorBase ( Arg value ) Construct a new Vector Base object all components initalized to value Parameters : value init value Template Parameters : Arg value type","title":"function VectorBase"},{"location":"Classes/classdakku_1_1VectorBase/#function-vectorbase_2","text":"inline VectorBase ( const sol :: table & table ) Construct a new Vector Base object all components initalized to table.","title":"function VectorBase"},{"location":"Classes/classdakku_1_1VectorBase/#function-vectorbase_3","text":"template < ArithmeticType Other , typename OtherDerived > inline explicit VectorBase ( const VectorBase < Other , S , OtherDerived > & other ) Construct a new Vector Base object with given values. Parameters : args init values expr the given expression Template Parameters : Args value types Other OtherDerived Expr Construct a new Vector Base object with a vector expression","title":"function VectorBase"},{"location":"Classes/classdakku_1_1VectorBase/#function-vectorbase_4","text":"inline VectorBase ( const VectorBase & other )","title":"function VectorBase"},{"location":"Classes/classdakku_1_1VectorBase/#function-vectorbase_5","text":"inline VectorBase ( VectorBase && other )","title":"function VectorBase"},{"location":"Classes/classdakku_1_1VectorBase/#function-operator","text":"inline VectorBase & operator = ( const VectorBase & other )","title":"function operator="},{"location":"Classes/classdakku_1_1VectorBase/#function-operator_1","text":"inline VectorBase & operator = ( VectorBase && other )","title":"function operator="},{"location":"Classes/classdakku_1_1VectorBase/#function-derived","text":"inline const D & derived () const convert to derived type","title":"function derived"},{"location":"Classes/classdakku_1_1VectorBase/#function-derived_1","text":"inline D & derived () convert to derived type","title":"function derived"},{"location":"Classes/classdakku_1_1VectorBase/#function-set","text":"template < ArithmeticType Arg > inline void set ( Arg value ) set all components to value Parameters : value the given value Template Parameters : Arg value type","title":"function set"},{"location":"Classes/classdakku_1_1VectorBase/#function-set_by_index","text":"template < ArithmeticType Arg > inline void set_by_index ( size_t index , Arg value ) set data[index] to value Parameters : index the index of the component value the given value Template Parameters : Arg value type","title":"function set_by_index"},{"location":"Classes/classdakku_1_1VectorBase/#function-set_1","text":"template < ArithmeticType ... Args , size_t ... Is > inline void set ( std :: index_sequence < Is ... > , Args && ... args ) set data to args Parameters : args values Template Parameters : Args value types Is indices (generated by std::index_sequence_for)","title":"function set"},{"location":"Classes/classdakku_1_1VectorBase/#function-set_2","text":"template < ArithmeticType ... Args > inline void set ( Args && ... args ) set data to args Parameters : args values Template Parameters : Args value types","title":"function set"},{"location":"Classes/classdakku_1_1VectorBase/#function-set_3","text":"template < ArithmeticType Other , typename OtherDerived > inline void set ( const VectorBase < Other , S , OtherDerived > & rhs ) set data by rhs 's data Parameters : rhs the given vector Template Parameters : Other rhs type OtherDerived rhs derived type","title":"function set"},{"location":"Classes/classdakku_1_1VectorBase/#function-get","text":"inline const T & get ( size_t i ) const get i'th component Parameters : i the index Return : the value","title":"function get"},{"location":"Classes/classdakku_1_1VectorBase/#function-size","text":"inline size_t size () const size of the vector Return : size","title":"function size"},{"location":"Classes/classdakku_1_1VectorBase/#function-to_string","text":"inline std :: string to_string () const convert vector to string Return : the converted string","title":"function to_string"},{"location":"Classes/classdakku_1_1VectorBase/#function-has_nans","text":"inline bool has_nans () const check whether there are nan components Return : true vector contains nan false vector does not contain nans","title":"function has_nans"},{"location":"Classes/classdakku_1_1VectorBase/#function-clone","text":"inline D clone () const get a copy","title":"function clone"},{"location":"Classes/classdakku_1_1VectorBase/#function-operator_2","text":"inline const T & operator []( size_t i ) const get i'th value Parameters : i index Return : value","title":"function operator[]"},{"location":"Classes/classdakku_1_1VectorBase/#function-operator_3","text":"inline T & operator []( size_t i ) get i'th value Parameters : i index Return : value","title":"function operator[]"},{"location":"Classes/classdakku_1_1VectorBase/#function-operator_4","text":"inline D & operator += ( const D & rhs ) addition Parameters : rhs another vector Return : this","title":"function operator+="},{"location":"Classes/classdakku_1_1VectorBase/#function-operator_5","text":"template < ArithmeticType V > inline D & operator += ( V rhs ) addition Parameters : rhs scalar Return : this","title":"function operator+="},{"location":"Classes/classdakku_1_1VectorBase/#function-operator_6","text":"inline D operator + ( const D & rhs ) const addition Parameters : rhs another vector Return : result","title":"function operator+"},{"location":"Classes/classdakku_1_1VectorBase/#function-operator_7","text":"template < ArithmeticType V > inline D operator + ( V rhs ) const addition Parameters : rhs another vector Return : result","title":"function operator+"},{"location":"Classes/classdakku_1_1VectorBase/#function-operator-","text":"inline D & operator -= ( const D & rhs ) subtraction Parameters : rhs another vector Return : this","title":"function operator-="},{"location":"Classes/classdakku_1_1VectorBase/#function-operator-_1","text":"template < ArithmeticType V > inline D & operator -= ( V rhs ) subtraction Parameters : rhs scalar Return : this","title":"function operator-="},{"location":"Classes/classdakku_1_1VectorBase/#function-operator_8","text":"inline D & operator *= ( const D & rhs ) multiplication Parameters : rhs another vector Return : this","title":"function operator*="},{"location":"Classes/classdakku_1_1VectorBase/#function-operator_9","text":"template < ArithmeticType V > inline D & operator *= ( V rhs ) multiplication Parameters : rhs scalar Return : this","title":"function operator*="},{"location":"Classes/classdakku_1_1VectorBase/#function-operator_10","text":"inline D operator * ( const D & rhs ) const multiplication Parameters : rhs another vector Return : result","title":"function operator*"},{"location":"Classes/classdakku_1_1VectorBase/#function-operator_11","text":"template < ArithmeticType V > inline D operator * ( V rhs ) const multiplication Parameters : rhs scalar Return : result","title":"function operator*"},{"location":"Classes/classdakku_1_1VectorBase/#function-operator_12","text":"inline D & operator /= ( const D & rhs ) division Parameters : rhs another vector Return : this","title":"function operator/="},{"location":"Classes/classdakku_1_1VectorBase/#function-operator_13","text":"template < ArithmeticType V > inline D & operator /= ( V rhs ) division Parameters : rhs scalar Return : this","title":"function operator/="},{"location":"Classes/classdakku_1_1VectorBase/#function-operator_14","text":"inline D operator / ( const D & rhs ) const division Parameters : rhs another vector Return : result","title":"function operator/"},{"location":"Classes/classdakku_1_1VectorBase/#function-operator_15","text":"template < ArithmeticType U > inline D operator / ( U rhs ) const division Parameters : rhs scalar Return : result","title":"function operator/"},{"location":"Classes/classdakku_1_1VectorBase/#function-operator_16","text":"inline bool operator == ( const VectorBase & rhs ) const","title":"function operator=="},{"location":"Classes/classdakku_1_1VectorBase/#function-operator_17","text":"inline bool operator != ( const VectorBase & rhs ) const","title":"function operator!="},{"location":"Classes/classdakku_1_1VectorBase/#function-x","text":"inline decltype ( auto ) x () const get the first element","title":"function x"},{"location":"Classes/classdakku_1_1VectorBase/#function-x_1","text":"inline decltype ( auto ) x () get the first element","title":"function x"},{"location":"Classes/classdakku_1_1VectorBase/#function-y","text":"inline decltype ( auto ) y () const get the second element","title":"function y"},{"location":"Classes/classdakku_1_1VectorBase/#function-y_1","text":"inline decltype ( auto ) y () get the second element","title":"function y"},{"location":"Classes/classdakku_1_1VectorBase/#function-z","text":"inline decltype ( auto ) z () const get the third element","title":"function z"},{"location":"Classes/classdakku_1_1VectorBase/#function-z_1","text":"inline decltype ( auto ) z () get the fourth element","title":"function z"},{"location":"Classes/classdakku_1_1VectorBase/#function-w","text":"inline decltype ( auto ) w () const get the fourth element","title":"function w"},{"location":"Classes/classdakku_1_1VectorBase/#function-w_1","text":"inline decltype ( auto ) w () get the third element","title":"function w"},{"location":"Classes/classdakku_1_1VectorBase/#function-max_element_index","text":"inline size_t max_element_index () const get the index of the max element Return : the index","title":"function max_element_index"},{"location":"Classes/classdakku_1_1VectorBase/#function-max_element","text":"inline decltype ( auto ) max_element () const get the max element in the vector Return : the max value","title":"function max_element"},{"location":"Classes/classdakku_1_1VectorBase/#function-max","text":"inline D max ( const D & rhs ) const element wise max","title":"function max"},{"location":"Classes/classdakku_1_1VectorBase/#function-min","text":"inline D min ( const D & rhs ) const element wise min","title":"function min"},{"location":"Classes/classdakku_1_1VectorBase/#function-dot","text":"template < typename OtherDerived > inline decltype ( auto ) dot ( const VectorBase < T , S , OtherDerived > & rhs ) const dot product between two vectors Return : \\(\\vec a \\cdot \\vec b\\)","title":"function dot"},{"location":"Classes/classdakku_1_1VectorBase/#function-squared_norm","text":"inline decltype ( auto ) squared_norm () const squared norm Return : \\(||v|| ^ 2\\)","title":"function squared_norm"},{"location":"Classes/classdakku_1_1VectorBase/#function-norm","text":"inline decltype ( auto ) norm () const norm Return : \\(||v||\\)","title":"function norm"},{"location":"Classes/classdakku_1_1VectorBase/#function-length","text":"inline decltype ( auto ) length () const length Return : \\(||v||\\)","title":"function length"},{"location":"Classes/classdakku_1_1VectorBase/#function-distance","text":"inline decltype ( auto ) distance ( const D & rhs ) const the distance","title":"function distance"},{"location":"Classes/classdakku_1_1VectorBase/#function-abs","text":"inline D abs () const abs","title":"function abs"},{"location":"Classes/classdakku_1_1VectorBase/#function-cross","text":"inline D cross ( const D & rhs ) const cross product","title":"function cross"},{"location":"Classes/classdakku_1_1VectorBase/#function-is_zero","text":"inline bool is_zero () const check whether all components are zero","title":"function is_zero"},{"location":"Classes/classdakku_1_1VectorBase/#function-sqrt","text":"inline D sqrt () const element-wise sqrt","title":"function sqrt"},{"location":"Classes/classdakku_1_1VectorBase/#function-pow","text":"template < ArithmeticType E > inline D pow ( E e ) const element-wise power","title":"function pow"},{"location":"Classes/classdakku_1_1VectorBase/#function-exp","text":"inline D exp () const element-wise exp","title":"function exp"},{"location":"Classes/classdakku_1_1VectorBase/#function-floor","text":"inline D floor () const element-wise floor","title":"function floor"},{"location":"Classes/classdakku_1_1VectorBase/#function-ceil","text":"inline D ceil () const element-wise ceil","title":"function ceil"},{"location":"Classes/classdakku_1_1VectorBase/#function-lerp","text":"inline D lerp ( const D & b , T t ) const element-wise linear interpolation","title":"function lerp"},{"location":"Classes/classdakku_1_1VectorBase/#function-operator-stdspan-t-s","text":"inline operator std :: span < T , S > ()","title":"function operator std::span&lt; T, S &gt;"},{"location":"Classes/classdakku_1_1VectorBase/#function-operator-stdspan-const-t-s","text":"inline operator std :: span < const T , S > () const","title":"function operator std::span&lt; const T, S &gt;"},{"location":"Classes/classdakku_1_1VectorBase/#friends_1","text":"","title":"Friends"},{"location":"Classes/classdakku_1_1VectorBase/#friend-operator","text":"friend D operator + ( U a , const D & b ); addition Parameters : a \\(aa\\) b \\(\\vec b\\) Return : elementwise add a","title":"friend operator+"},{"location":"Classes/classdakku_1_1VectorBase/#friend-operator-","text":"friend D operator - ( U a , const D & b ); subtraction Parameters : a \\(aa\\) b \\(\\vec b\\) Return : elementwise sub","title":"friend operator-"},{"location":"Classes/classdakku_1_1VectorBase/#friend-operator_1","text":"friend D operator * ( U a , const D & b ); multiplication Parameters : a \\(aa\\) b \\(\\vec b\\) Return : elementwise mul","title":"friend operator*"},{"location":"Classes/classdakku_1_1VectorBase/#friend-operator_2","text":"friend D operator / ( U a , const D & b ); division Parameters : a \\(aa\\) b \\(\\vec b\\) Return : elementwise div (broad cast \\(a\\) )","title":"friend operator/"},{"location":"Classes/classdakku_1_1VectorBase/#friend-operator_3","text":"friend std :: ostream & operator << ( std :: ostream & os , const VectorBase & vec ); output the vector Parameters : os ostream vec the vector to output Return : ostream","title":"friend operator&lt;&lt;"},{"location":"Classes/classdakku_1_1VectorBase/#friend-max","text":"friend D max ( const D & v1 , const D & v2 ); element wise max","title":"friend max"},{"location":"Classes/classdakku_1_1VectorBase/#friend-min","text":"friend D min ( const D & v1 , const D & v2 ); element wise min","title":"friend min"},{"location":"Classes/classdakku_1_1VectorBase/#friend-distance","text":"friend decltype ( auto ) distance ( const D & a , const D & b ); the distance","title":"friend distance"},{"location":"Classes/classdakku_1_1VectorBase/#friend-abs","text":"friend D abs ( const D & v ); abs","title":"friend abs"},{"location":"Classes/classdakku_1_1VectorBase/#friend-sqrt","text":"friend D sqrt ( const D & v ); element-wise sqrt","title":"friend sqrt"},{"location":"Classes/classdakku_1_1VectorBase/#friend-pow","text":"friend D pow ( const D & v , E e ); element-wise power","title":"friend pow"},{"location":"Classes/classdakku_1_1VectorBase/#friend-exp","text":"friend D exp ( const D & v ); element-wise exp","title":"friend exp"},{"location":"Classes/classdakku_1_1VectorBase/#friend-floor","text":"friend D floor ( const D & v ); element-wise floor","title":"friend floor"},{"location":"Classes/classdakku_1_1VectorBase/#friend-ceil","text":"friend D ceil ( const D & v ); element-wise ceil","title":"friend ceil"},{"location":"Classes/classdakku_1_1VectorBase/#friend-lerp","text":"friend D lerp ( const D & a , const D & b , T t ); element-wise linear interpolation Updated on 2022-04-30 at 15:46:11 +0000","title":"friend lerp"},{"location":"Examples/","text":"Examples Updated on 2022-04-30 at 15:46:11 +0000","title":"Examples"},{"location":"Examples/#examples","text":"Updated on 2022-04-30 at 15:46:11 +0000","title":"Examples"},{"location":"Files/","text":"Files dir src file src/platform.h dir src/core file src/core/bounds.h file src/core/constants.h file src/core/filter.h file src/core/fwd.h file src/core/logger.h file src/core/lua.h file src/core/math_func.h file src/core/memory.h file src/core/ray.h file src/core/vector.h file src/core/vector_base.h dir src/filters file src/filters/box.h file src/filters/fwd.h file src/filters/triangle.h Updated on 2022-04-30 at 15:46:11 +0000","title":"Files"},{"location":"Files/#files","text":"dir src file src/platform.h dir src/core file src/core/bounds.h file src/core/constants.h file src/core/filter.h file src/core/fwd.h file src/core/logger.h file src/core/lua.h file src/core/math_func.h file src/core/memory.h file src/core/ray.h file src/core/vector.h file src/core/vector_base.h dir src/filters file src/filters/box.h file src/filters/fwd.h file src/filters/triangle.h Updated on 2022-04-30 at 15:46:11 +0000","title":"Files"},{"location":"Files/bounds_8h/","text":"src/core/bounds.h Namespaces Name dakku dakku namespace Classes Name class dakku::BoundsBase bounding box base class dakku::Bounds2 2d bounding box class dakku::Bounds3 3d bounding box class dakku::Bounds2iIterator 2d integer bounds iterator, iterate all pixels inside Source code #ifndef DAKKU_CORE_BOUNDS_H_ #define DAKKU_CORE_BOUNDS_H_ #include <core/vector.h> #include <iterator> #include <utility> namespace dakku { template < ArithmeticType T , size_t S > class BoundsBase { public : BoundsBase () = default ; explicit BoundsBase ( const Point < T , S > & p ) : p_min ( p ), p_max ( p ) {} template < ArithmeticType U > explicit BoundsBase ( const BoundsBase < U , S > & b ) : p_min ( Point < T , S > ( b . p_min )), p_max ( Point < T , S > ( b . p_max )) {} BoundsBase ( const Point < T , S > & p1 , const Point < T , S > & p2 ) : p_min ( min ( p1 , p2 )), p_max ( max ( p1 , p2 )) {} BoundsBase ( const sol :: table & table ) : p_min ( table . get_or ( 1 , table )), p_max ( table . get_or ( 2 , table )) {} [[ nodiscard ]] Vector < T , S > diagonal () const { return p_max - p_min ; } [[ nodiscard ]] size_t max_extent () const { return this -> diagonal (). max_element_index (); } bool operator == ( const BoundsBase & rhs ) const { return p_min == rhs . p_min && p_max == rhs . p_max ; } bool operator != ( const BoundsBase & rhs ) const { return p_min != rhs . p_min || p_max != rhs . p_max ; } [[ nodiscard ]] Point < T , S > lerp ( const Point < float , S > & t ) const { Point < T , S > ret ; for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = std :: lerp ( p_min [ i ], p_max [ i ], t [ i ]); return ret ; } [[ nodiscard ]] Vector < T , S > offset ( const Point < T , S > & p ) const { Vector < T , S > o = p - p_min ; for ( size_t i = 0 ; i < S ; ++ i ) if ( p_max [ i ] > p_min [ i ]) o [ i ] /= p_max [ i ] - p_min [ i ]; return o ; } friend bool overlaps ( const BoundsBase & a , const BoundsBase & b ) { for ( size_t i = 0 ; i < S ; ++ i ) if ( ! ( a . p_max [ i ] >= b . p_min [ i ] && a . p_min [ i ] <= b . p_max [ i ])) return false ; return true ; } [[ nodiscard ]] bool overlaps ( const BoundsBase & rhs ) const { return overlaps ( * this , rhs ); } friend bool inside ( const Point < T , S > & p , const BoundsBase & b ) { for ( size_t i = 0 ; i < S ; ++ i ) if ( ! ( p [ i ] >= b . p_min [ i ] && p [ i ] <= b . p_max [ i ])) return false ; return true ; } [[ nodiscard ]] bool inside ( const Point < T , S > & p ) const { return inside ( p , * this ); } friend bool inside_exclusive ( const Point < T , S > & p , const BoundsBase & b ) { for ( size_t i = 0 ; i < S ; ++ i ) if ( ! ( p [ i ] >= b . p_min [ i ] && p [ i ] < b . p_max [ i ])) return false ; return true ; } [[ nodiscard ]] bool inside_exclusive ( const Point < T , S > & p ) const { return inside_exclusive ( p , * this ); } void bounding_sphere ( Point < T , S > & center , float & rad ) { center = ( p_min + p_max ) / 2 ; rad = inside ( center , * this ) ? distance ( center , p_max ) : 0 ; } friend BoundsBase operator | ( const BoundsBase & a , const BoundsBase & b ) { BoundsBase ret ; ret . p_min = min ( a . p_min , b . p_min ); ret . p_max = max ( a . p_max , b . p_max ); return ret ; } [[ nodiscard ]] BoundsBase union_bounds ( const BoundsBase & rhs ) const { return * this | rhs ; } friend BoundsBase operator | ( const BoundsBase & b , const Point < T , S > & p ) { BoundsBase ret ; ret . p_min = min ( b . p_min , p ); ret . p_max = max ( b . p_max , p ); return ret ; } [[ nodiscard ]] BoundsBase union_bounds ( const Point < T , S > & p ) const { return * this | p ; } friend BoundsBase operator & ( const BoundsBase & a , const BoundsBase & b ) { BoundsBase ret ; // important: assign to pMin/pMax directly and don't run the BoundsBase() // constructor, since it takes min/max of the points passed to it. In // turn, that breaks returning an invalid bound for the case where we // intersect non-overlapping bounds (as we'd like to happen). ret . p_min = max ( a . p_min , b . p_min ); ret . p_max = min ( a . p_max , b . p_max ); return ret ; } [[ nodiscard ]] BoundsBase intersect ( const BoundsBase & rhs ) const { return * this & rhs ; } friend decltype ( auto ) distance_squared ( const Point < T , S > & p , const BoundsBase < T , S > & b ) { return max ( Vector < T , S > {}, max ( b . p_min - p , p - b . p_max )). squared_norm (); } friend decltype ( auto ) distance ( const Point < T , S > & p , const BoundsBase < T , S > & b ) { return std :: sqrt ( distance_squared ( p , b )); } [[ nodiscard ]] std :: string to_string () const { return \"[\" + p_min . to_string () + \", \" + p_max . to_string () + \"]\" ; } friend std :: ostream & operator << ( std :: ostream & os , const BoundsBase & b ) { return os << b . to_string (); } Point < T , S > p_min { std :: numeric_limits < T >:: max ()}; Point < T , S > p_max { std :: numeric_limits < T >:: lowest ()}; }; template < ArithmeticType T > class Bounds2 : public BoundsBase < T , 2 > { public : using BoundsBase < T , 2 >:: BoundsBase ; Bounds2 ( const BoundsBase < T , 2 > & base ) : BoundsBase < T , 2 > ( base ) {} [[ nodiscard ]] decltype ( auto ) area () const { auto d = this -> diagonal (); return d . x () * d . y (); } }; using Bounds2f = Bounds2 < float > ; using Bounds2i = Bounds2 < int > ; template < ArithmeticType T > class Bounds3 : public BoundsBase < T , 3 > { public : using BoundsBase < T , 3 >:: BoundsBase ; Bounds3 ( const BoundsBase < T , 3 > & base ) : BoundsBase < T , 3 > ( base ) {} }; using Bounds3f = Bounds3 < float > ; class Bounds2iIterator : public std :: forward_iterator_tag { public : explicit Bounds2iIterator ( const Bounds2i & b , Point2i p ) : b ( b ), p ( std :: move ( p )) {} Bounds2iIterator operator ++ () { advance (); return * this ; } Bounds2iIterator operator ++ ( int ) { Bounds2iIterator ret = * this ; advance (); return ret ; } bool operator == ( const Bounds2iIterator & rhs ) const { return p == rhs . p && ( & b == & rhs . b ); } bool operator != ( const Bounds2iIterator & rhs ) const { return p != rhs . p || ( & b != & rhs . b ); } Point2i operator * () const { return p ; } private : void advance () { ++ p . x (); if ( p . x () == b . p_max . x ()) { p . x () = b . p_min . x (); ++ p . y (); } } const Bounds2i & b ; Point2i p ; }; inline Bounds2iIterator begin ( const Bounds2i & b ) { return Bounds2iIterator { b , b . p_min }; } inline Bounds2iIterator end ( const Bounds2i & b ) { // normally, the ending point is at the minimum x value and one past // the last valid y value. Point2i pEnd ( b . p_min . x (), b . p_max . y ()); // however, if the bounds are degenerate, override the end point to // equal the start point so that any attempt to iterate over the bounds // exits out immediately. if ( b . p_min . x () >= b . p_max . x () || b . p_min . y () >= b . p_max . y ()) pEnd = b . p_min ; return Bounds2iIterator { b , pEnd }; } DAKKU_DECLARE_LUA_OBJECT ( Bounds , DAKKU_EXPORT_CORE ); } // namespace dakku #endif Updated on 2022-04-30 at 15:46:11 +0000","title":"src/core/bounds.h"},{"location":"Files/bounds_8h/#srccoreboundsh","text":"","title":"src/core/bounds.h"},{"location":"Files/bounds_8h/#namespaces","text":"Name dakku dakku namespace","title":"Namespaces"},{"location":"Files/bounds_8h/#classes","text":"Name class dakku::BoundsBase bounding box base class dakku::Bounds2 2d bounding box class dakku::Bounds3 3d bounding box class dakku::Bounds2iIterator 2d integer bounds iterator, iterate all pixels inside","title":"Classes"},{"location":"Files/bounds_8h/#source-code","text":"#ifndef DAKKU_CORE_BOUNDS_H_ #define DAKKU_CORE_BOUNDS_H_ #include <core/vector.h> #include <iterator> #include <utility> namespace dakku { template < ArithmeticType T , size_t S > class BoundsBase { public : BoundsBase () = default ; explicit BoundsBase ( const Point < T , S > & p ) : p_min ( p ), p_max ( p ) {} template < ArithmeticType U > explicit BoundsBase ( const BoundsBase < U , S > & b ) : p_min ( Point < T , S > ( b . p_min )), p_max ( Point < T , S > ( b . p_max )) {} BoundsBase ( const Point < T , S > & p1 , const Point < T , S > & p2 ) : p_min ( min ( p1 , p2 )), p_max ( max ( p1 , p2 )) {} BoundsBase ( const sol :: table & table ) : p_min ( table . get_or ( 1 , table )), p_max ( table . get_or ( 2 , table )) {} [[ nodiscard ]] Vector < T , S > diagonal () const { return p_max - p_min ; } [[ nodiscard ]] size_t max_extent () const { return this -> diagonal (). max_element_index (); } bool operator == ( const BoundsBase & rhs ) const { return p_min == rhs . p_min && p_max == rhs . p_max ; } bool operator != ( const BoundsBase & rhs ) const { return p_min != rhs . p_min || p_max != rhs . p_max ; } [[ nodiscard ]] Point < T , S > lerp ( const Point < float , S > & t ) const { Point < T , S > ret ; for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = std :: lerp ( p_min [ i ], p_max [ i ], t [ i ]); return ret ; } [[ nodiscard ]] Vector < T , S > offset ( const Point < T , S > & p ) const { Vector < T , S > o = p - p_min ; for ( size_t i = 0 ; i < S ; ++ i ) if ( p_max [ i ] > p_min [ i ]) o [ i ] /= p_max [ i ] - p_min [ i ]; return o ; } friend bool overlaps ( const BoundsBase & a , const BoundsBase & b ) { for ( size_t i = 0 ; i < S ; ++ i ) if ( ! ( a . p_max [ i ] >= b . p_min [ i ] && a . p_min [ i ] <= b . p_max [ i ])) return false ; return true ; } [[ nodiscard ]] bool overlaps ( const BoundsBase & rhs ) const { return overlaps ( * this , rhs ); } friend bool inside ( const Point < T , S > & p , const BoundsBase & b ) { for ( size_t i = 0 ; i < S ; ++ i ) if ( ! ( p [ i ] >= b . p_min [ i ] && p [ i ] <= b . p_max [ i ])) return false ; return true ; } [[ nodiscard ]] bool inside ( const Point < T , S > & p ) const { return inside ( p , * this ); } friend bool inside_exclusive ( const Point < T , S > & p , const BoundsBase & b ) { for ( size_t i = 0 ; i < S ; ++ i ) if ( ! ( p [ i ] >= b . p_min [ i ] && p [ i ] < b . p_max [ i ])) return false ; return true ; } [[ nodiscard ]] bool inside_exclusive ( const Point < T , S > & p ) const { return inside_exclusive ( p , * this ); } void bounding_sphere ( Point < T , S > & center , float & rad ) { center = ( p_min + p_max ) / 2 ; rad = inside ( center , * this ) ? distance ( center , p_max ) : 0 ; } friend BoundsBase operator | ( const BoundsBase & a , const BoundsBase & b ) { BoundsBase ret ; ret . p_min = min ( a . p_min , b . p_min ); ret . p_max = max ( a . p_max , b . p_max ); return ret ; } [[ nodiscard ]] BoundsBase union_bounds ( const BoundsBase & rhs ) const { return * this | rhs ; } friend BoundsBase operator | ( const BoundsBase & b , const Point < T , S > & p ) { BoundsBase ret ; ret . p_min = min ( b . p_min , p ); ret . p_max = max ( b . p_max , p ); return ret ; } [[ nodiscard ]] BoundsBase union_bounds ( const Point < T , S > & p ) const { return * this | p ; } friend BoundsBase operator & ( const BoundsBase & a , const BoundsBase & b ) { BoundsBase ret ; // important: assign to pMin/pMax directly and don't run the BoundsBase() // constructor, since it takes min/max of the points passed to it. In // turn, that breaks returning an invalid bound for the case where we // intersect non-overlapping bounds (as we'd like to happen). ret . p_min = max ( a . p_min , b . p_min ); ret . p_max = min ( a . p_max , b . p_max ); return ret ; } [[ nodiscard ]] BoundsBase intersect ( const BoundsBase & rhs ) const { return * this & rhs ; } friend decltype ( auto ) distance_squared ( const Point < T , S > & p , const BoundsBase < T , S > & b ) { return max ( Vector < T , S > {}, max ( b . p_min - p , p - b . p_max )). squared_norm (); } friend decltype ( auto ) distance ( const Point < T , S > & p , const BoundsBase < T , S > & b ) { return std :: sqrt ( distance_squared ( p , b )); } [[ nodiscard ]] std :: string to_string () const { return \"[\" + p_min . to_string () + \", \" + p_max . to_string () + \"]\" ; } friend std :: ostream & operator << ( std :: ostream & os , const BoundsBase & b ) { return os << b . to_string (); } Point < T , S > p_min { std :: numeric_limits < T >:: max ()}; Point < T , S > p_max { std :: numeric_limits < T >:: lowest ()}; }; template < ArithmeticType T > class Bounds2 : public BoundsBase < T , 2 > { public : using BoundsBase < T , 2 >:: BoundsBase ; Bounds2 ( const BoundsBase < T , 2 > & base ) : BoundsBase < T , 2 > ( base ) {} [[ nodiscard ]] decltype ( auto ) area () const { auto d = this -> diagonal (); return d . x () * d . y (); } }; using Bounds2f = Bounds2 < float > ; using Bounds2i = Bounds2 < int > ; template < ArithmeticType T > class Bounds3 : public BoundsBase < T , 3 > { public : using BoundsBase < T , 3 >:: BoundsBase ; Bounds3 ( const BoundsBase < T , 3 > & base ) : BoundsBase < T , 3 > ( base ) {} }; using Bounds3f = Bounds3 < float > ; class Bounds2iIterator : public std :: forward_iterator_tag { public : explicit Bounds2iIterator ( const Bounds2i & b , Point2i p ) : b ( b ), p ( std :: move ( p )) {} Bounds2iIterator operator ++ () { advance (); return * this ; } Bounds2iIterator operator ++ ( int ) { Bounds2iIterator ret = * this ; advance (); return ret ; } bool operator == ( const Bounds2iIterator & rhs ) const { return p == rhs . p && ( & b == & rhs . b ); } bool operator != ( const Bounds2iIterator & rhs ) const { return p != rhs . p || ( & b != & rhs . b ); } Point2i operator * () const { return p ; } private : void advance () { ++ p . x (); if ( p . x () == b . p_max . x ()) { p . x () = b . p_min . x (); ++ p . y (); } } const Bounds2i & b ; Point2i p ; }; inline Bounds2iIterator begin ( const Bounds2i & b ) { return Bounds2iIterator { b , b . p_min }; } inline Bounds2iIterator end ( const Bounds2i & b ) { // normally, the ending point is at the minimum x value and one past // the last valid y value. Point2i pEnd ( b . p_min . x (), b . p_max . y ()); // however, if the bounds are degenerate, override the end point to // equal the start point so that any attempt to iterate over the bounds // exits out immediately. if ( b . p_min . x () >= b . p_max . x () || b . p_min . y () >= b . p_max . y ()) pEnd = b . p_min ; return Bounds2iIterator { b , pEnd }; } DAKKU_DECLARE_LUA_OBJECT ( Bounds , DAKKU_EXPORT_CORE ); } // namespace dakku #endif Updated on 2022-04-30 at 15:46:11 +0000","title":"Source code"},{"location":"Files/box_8h/","text":"src/filters/box.h Namespaces Name dakku dakku namespace Classes Name class dakku::BoxFilter box filter the box filter is simple, just return \\(1\\) for all values Source code #ifndef DAKKU_FILTERS_BOX_H_ #define DAKKU_FILTERS_BOX_H_ #include <filters/fwd.h> namespace dakku { class DAKKU_EXPORT_FILTERS BoxFilter : public Filter { public : using Filter :: Filter ; [[ nodiscard ]] float evaluate ( const Point2f & p ) const override ; }; DAKKU_EXPORT_FILTERS Filter * create_box_filter ( float x_width , float y_width ); DAKKU_DECLARE_LUA_OBJECT ( BoxFilter , DAKKU_EXPORT_FILTERS ); } // namespace dakku #endif Updated on 2022-04-30 at 15:46:11 +0000","title":"src/filters/box.h"},{"location":"Files/box_8h/#srcfiltersboxh","text":"","title":"src/filters/box.h"},{"location":"Files/box_8h/#namespaces","text":"Name dakku dakku namespace","title":"Namespaces"},{"location":"Files/box_8h/#classes","text":"Name class dakku::BoxFilter box filter the box filter is simple, just return \\(1\\) for all values","title":"Classes"},{"location":"Files/box_8h/#source-code","text":"#ifndef DAKKU_FILTERS_BOX_H_ #define DAKKU_FILTERS_BOX_H_ #include <filters/fwd.h> namespace dakku { class DAKKU_EXPORT_FILTERS BoxFilter : public Filter { public : using Filter :: Filter ; [[ nodiscard ]] float evaluate ( const Point2f & p ) const override ; }; DAKKU_EXPORT_FILTERS Filter * create_box_filter ( float x_width , float y_width ); DAKKU_DECLARE_LUA_OBJECT ( BoxFilter , DAKKU_EXPORT_FILTERS ); } // namespace dakku #endif Updated on 2022-04-30 at 15:46:11 +0000","title":"Source code"},{"location":"Files/constants_8h/","text":"src/core/constants.h Namespaces Name dakku dakku namespace Source code #ifndef DAKKU_CORE_CONSTANTS_H_ #define DAKKU_CORE_CONSTANTS_H_ #include <core/fwd.h> #include <numbers> #include <limits> namespace dakku { static constexpr float INF = std :: numeric_limits < float >:: infinity (); static constexpr float PI = std :: numbers :: pi_v < float > ; static constexpr float INV_PI = static_cast < float > ( 1.0 / std :: numbers :: pi_v < double > ); static constexpr float PI_OVER_2 = static_cast < float > ( std :: numbers :: pi_v < double > / 2.0 ); static constexpr float PI_OVER_4 = static_cast < float > ( std :: numbers :: pi_v < double > / 4.0 ); static constexpr float SHADOW_EPS = 1e-5f ; static constexpr float ONE_MINUS_EPSILON = 1 - std :: numeric_limits < float >:: epsilon (); } // namespace dakku #endif Updated on 2022-04-30 at 15:46:11 +0000","title":"src/core/constants.h"},{"location":"Files/constants_8h/#srccoreconstantsh","text":"","title":"src/core/constants.h"},{"location":"Files/constants_8h/#namespaces","text":"Name dakku dakku namespace","title":"Namespaces"},{"location":"Files/constants_8h/#source-code","text":"#ifndef DAKKU_CORE_CONSTANTS_H_ #define DAKKU_CORE_CONSTANTS_H_ #include <core/fwd.h> #include <numbers> #include <limits> namespace dakku { static constexpr float INF = std :: numeric_limits < float >:: infinity (); static constexpr float PI = std :: numbers :: pi_v < float > ; static constexpr float INV_PI = static_cast < float > ( 1.0 / std :: numbers :: pi_v < double > ); static constexpr float PI_OVER_2 = static_cast < float > ( std :: numbers :: pi_v < double > / 2.0 ); static constexpr float PI_OVER_4 = static_cast < float > ( std :: numbers :: pi_v < double > / 4.0 ); static constexpr float SHADOW_EPS = 1e-5f ; static constexpr float ONE_MINUS_EPSILON = 1 - std :: numeric_limits < float >:: epsilon (); } // namespace dakku #endif Updated on 2022-04-30 at 15:46:11 +0000","title":"Source code"},{"location":"Files/core_2fwd_8h/","text":"src/core/fwd.h Namespaces Name dakku dakku namespace Defines Name DAKKU_EXPORT_CORE Macros Documentation define DAKKU_EXPORT_CORE #define DAKKU_EXPORT_CORE DAKKU_EXPORT Source code #ifndef DAKKU_CORE_FWD_H_ #define DAKKU_CORE_FWD_H_ #include <platform.h> #include <type_traits> namespace dakku { #if DAKKU_BUILD_MODULE != DAKKU_CORE_MODULE #define DAKKU_EXPORT_CORE DAKKU_IMPORT #else #define DAKKU_EXPORT_CORE DAKKU_EXPORT #endif template < typename T > concept ArithmeticType = std :: is_arithmetic_v < std :: decay_t < T >> ; } // namespace dakku #endif Updated on 2022-04-30 at 15:46:11 +0000","title":"src/core/fwd.h"},{"location":"Files/core_2fwd_8h/#srccorefwdh","text":"","title":"src/core/fwd.h"},{"location":"Files/core_2fwd_8h/#namespaces","text":"Name dakku dakku namespace","title":"Namespaces"},{"location":"Files/core_2fwd_8h/#defines","text":"Name DAKKU_EXPORT_CORE","title":"Defines"},{"location":"Files/core_2fwd_8h/#macros-documentation","text":"","title":"Macros Documentation"},{"location":"Files/core_2fwd_8h/#define-dakku_export_core","text":"#define DAKKU_EXPORT_CORE DAKKU_EXPORT","title":"define DAKKU_EXPORT_CORE"},{"location":"Files/core_2fwd_8h/#source-code","text":"#ifndef DAKKU_CORE_FWD_H_ #define DAKKU_CORE_FWD_H_ #include <platform.h> #include <type_traits> namespace dakku { #if DAKKU_BUILD_MODULE != DAKKU_CORE_MODULE #define DAKKU_EXPORT_CORE DAKKU_IMPORT #else #define DAKKU_EXPORT_CORE DAKKU_EXPORT #endif template < typename T > concept ArithmeticType = std :: is_arithmetic_v < std :: decay_t < T >> ; } // namespace dakku #endif Updated on 2022-04-30 at 15:46:11 +0000","title":"Source code"},{"location":"Files/dir_1bc13244e26df1e1f069a1fd18e36da3/","text":"src/filters Files Name src/filters/box.h src/filters/fwd.h src/filters/triangle.h Updated on 2022-04-30 at 15:46:11 +0000","title":"src/filters"},{"location":"Files/dir_1bc13244e26df1e1f069a1fd18e36da3/#srcfilters","text":"","title":"src/filters"},{"location":"Files/dir_1bc13244e26df1e1f069a1fd18e36da3/#files","text":"Name src/filters/box.h src/filters/fwd.h src/filters/triangle.h Updated on 2022-04-30 at 15:46:11 +0000","title":"Files"},{"location":"Files/dir_68267d1309a1af8e8297ef4c3efbcdba/","text":"src Directories Name src/core src/filters Files Name src/platform.h Updated on 2022-04-30 at 15:46:11 +0000","title":"src"},{"location":"Files/dir_68267d1309a1af8e8297ef4c3efbcdba/#src","text":"","title":"src"},{"location":"Files/dir_68267d1309a1af8e8297ef4c3efbcdba/#directories","text":"Name src/core src/filters","title":"Directories"},{"location":"Files/dir_68267d1309a1af8e8297ef4c3efbcdba/#files","text":"Name src/platform.h Updated on 2022-04-30 at 15:46:11 +0000","title":"Files"},{"location":"Files/dir_aebb8dcc11953d78e620bbef0b9e2183/","text":"src/core Files Name src/core/bounds.h src/core/constants.h src/core/filter.h src/core/fwd.h src/core/logger.h src/core/lua.h src/core/math_func.h src/core/memory.h src/core/ray.h src/core/vector.h src/core/vector_base.h Updated on 2022-04-30 at 15:46:11 +0000","title":"src/core"},{"location":"Files/dir_aebb8dcc11953d78e620bbef0b9e2183/#srccore","text":"","title":"src/core"},{"location":"Files/dir_aebb8dcc11953d78e620bbef0b9e2183/#files","text":"Name src/core/bounds.h src/core/constants.h src/core/filter.h src/core/fwd.h src/core/logger.h src/core/lua.h src/core/math_func.h src/core/memory.h src/core/ray.h src/core/vector.h src/core/vector_base.h Updated on 2022-04-30 at 15:46:11 +0000","title":"Files"},{"location":"Files/filter_8h/","text":"src/core/filter.h Namespaces Name dakku dakku namespace Classes Name class dakku::Filter Source code #ifndef DAKKU_CORE_FILTER_H_ #define DAKKU_CORE_FILTER_H_ #include <core/vector.h> namespace dakku { class DAKKU_EXPORT_CORE Filter { public : explicit Filter ( const Vector2f & radius ); [[ nodiscard ]] virtual float evaluate ( const Point2f & p ) const = 0 ; const Vector2f radius ; const Vector2f inv_radius ; }; } // namespace dakku #endif Updated on 2022-04-30 at 15:46:11 +0000","title":"src/core/filter.h"},{"location":"Files/filter_8h/#srccorefilterh","text":"","title":"src/core/filter.h"},{"location":"Files/filter_8h/#namespaces","text":"Name dakku dakku namespace","title":"Namespaces"},{"location":"Files/filter_8h/#classes","text":"Name class dakku::Filter","title":"Classes"},{"location":"Files/filter_8h/#source-code","text":"#ifndef DAKKU_CORE_FILTER_H_ #define DAKKU_CORE_FILTER_H_ #include <core/vector.h> namespace dakku { class DAKKU_EXPORT_CORE Filter { public : explicit Filter ( const Vector2f & radius ); [[ nodiscard ]] virtual float evaluate ( const Point2f & p ) const = 0 ; const Vector2f radius ; const Vector2f inv_radius ; }; } // namespace dakku #endif Updated on 2022-04-30 at 15:46:11 +0000","title":"Source code"},{"location":"Files/filters_2fwd_8h/","text":"src/filters/fwd.h Namespaces Name dakku dakku namespace Defines Name DAKKU_EXPORT_FILTERS Macros Documentation define DAKKU_EXPORT_FILTERS #define DAKKU_EXPORT_FILTERS DAKKU_EXPORT Source code #ifndef DAKKU_FILTERS_FWD_H_ #define DAKKU_FILTERS_FWD_H_ #include <core/filter.h> namespace dakku { #if DAKKU_BUILD_MODULE != DAKKU_FILTERS_MODULE #define DAKKU_EXPORT_FILTERS DAKKU_IMPORT #else #define DAKKU_EXPORT_FILTERS DAKKU_EXPORT #endif } // namespace dakku #endif Updated on 2022-04-30 at 15:46:11 +0000","title":"src/filters/fwd.h"},{"location":"Files/filters_2fwd_8h/#srcfiltersfwdh","text":"","title":"src/filters/fwd.h"},{"location":"Files/filters_2fwd_8h/#namespaces","text":"Name dakku dakku namespace","title":"Namespaces"},{"location":"Files/filters_2fwd_8h/#defines","text":"Name DAKKU_EXPORT_FILTERS","title":"Defines"},{"location":"Files/filters_2fwd_8h/#macros-documentation","text":"","title":"Macros Documentation"},{"location":"Files/filters_2fwd_8h/#define-dakku_export_filters","text":"#define DAKKU_EXPORT_FILTERS DAKKU_EXPORT","title":"define DAKKU_EXPORT_FILTERS"},{"location":"Files/filters_2fwd_8h/#source-code","text":"#ifndef DAKKU_FILTERS_FWD_H_ #define DAKKU_FILTERS_FWD_H_ #include <core/filter.h> namespace dakku { #if DAKKU_BUILD_MODULE != DAKKU_FILTERS_MODULE #define DAKKU_EXPORT_FILTERS DAKKU_IMPORT #else #define DAKKU_EXPORT_FILTERS DAKKU_EXPORT #endif } // namespace dakku #endif Updated on 2022-04-30 at 15:46:11 +0000","title":"Source code"},{"location":"Files/logger_8h/","text":"src/core/logger.h Namespaces Name dakku dakku namespace Classes Name class dakku::Logger logger class Defines Name DAKKU_ERR (...) log error message DAKKU_INFO (...) log info message DAKKU_WARN (...) log warning message DAKKU_DEBUG (...) log debug message DAKKU_CHECK (...) check whether the condition val is true, if not log error messages Macros Documentation define DAKKU_ERR #define DAKKU_ERR( ... ) SPDLOG_LOGGER_CALL ( Logger :: get (). handle (), spdlog :: level :: err , __VA_ARGS__ ) log error message define DAKKU_INFO #define DAKKU_INFO( ... ) SPDLOG_LOGGER_CALL ( Logger :: get (). handle (), spdlog :: level :: info , __VA_ARGS__ ) log info message define DAKKU_WARN #define DAKKU_WARN( ... ) SPDLOG_LOGGER_CALL ( Logger :: get (). handle (), spdlog :: level :: warn , __VA_ARGS__ ) log warning message define DAKKU_DEBUG #define DAKKU_DEBUG( ... ) static_cast < void > ( 0 ) log debug message define DAKKU_CHECK #define DAKKU_CHECK( ... ) static_cast < void > ( 0 ) check whether the condition val is true, if not log error messages Source code #ifndef DAKKU_CORE_LOGGER_H_ #define DAKKU_CORE_LOGGER_H_ #include <core/fwd.h> #include <memory> #include <spdlog/spdlog.h> #include <spdlog/fmt/ostr.h> namespace dakku { class DAKKU_EXPORT_CORE Logger { public : static const Logger & get (); [[ nodiscard ]] spdlog :: logger * handle () const { return _logger . get (); } private : explicit Logger ( std :: shared_ptr < spdlog :: logger > _logger ); std :: shared_ptr < spdlog :: logger > _logger ; }; #define DAKKU_ERR(...) \\ SPDLOG_LOGGER_CALL(Logger::get().handle(), spdlog::level::err, __VA_ARGS__) #define DAKKU_INFO(...) \\ SPDLOG_LOGGER_CALL(Logger::get().handle(), spdlog::level::info, __VA_ARGS__) #define DAKKU_WARN(...) \\ SPDLOG_LOGGER_CALL(Logger::get().handle(), spdlog::level::warn, __VA_ARGS__) #ifdef DAKKU_BUILD_DEBUG #define DAKKU_DEBUG(...) \\ SPDLOG_LOGGER_CALL(Logger::get().handle(), spdlog::level::debug, __VA_ARGS__) #else #define DAKKU_DEBUG(...) static_cast<void>(0) #endif #ifdef DAKKU_BUILD_CHECK #define DAKKU_CHECK(val, ...) \\ do { \\ if (!(val)) { \\ DAKKU_ERR(__VA_ARGS__); \\ std::exit(-1); \\ } \\ } while (0) #else #define DAKKU_CHECK(...) static_cast<void>(0) #endif } // namespace dakku #endif Updated on 2022-04-30 at 15:46:11 +0000","title":"src/core/logger.h"},{"location":"Files/logger_8h/#srccoreloggerh","text":"","title":"src/core/logger.h"},{"location":"Files/logger_8h/#namespaces","text":"Name dakku dakku namespace","title":"Namespaces"},{"location":"Files/logger_8h/#classes","text":"Name class dakku::Logger logger class","title":"Classes"},{"location":"Files/logger_8h/#defines","text":"Name DAKKU_ERR (...) log error message DAKKU_INFO (...) log info message DAKKU_WARN (...) log warning message DAKKU_DEBUG (...) log debug message DAKKU_CHECK (...) check whether the condition val is true, if not log error messages","title":"Defines"},{"location":"Files/logger_8h/#macros-documentation","text":"","title":"Macros Documentation"},{"location":"Files/logger_8h/#define-dakku_err","text":"#define DAKKU_ERR( ... ) SPDLOG_LOGGER_CALL ( Logger :: get (). handle (), spdlog :: level :: err , __VA_ARGS__ ) log error message","title":"define DAKKU_ERR"},{"location":"Files/logger_8h/#define-dakku_info","text":"#define DAKKU_INFO( ... ) SPDLOG_LOGGER_CALL ( Logger :: get (). handle (), spdlog :: level :: info , __VA_ARGS__ ) log info message","title":"define DAKKU_INFO"},{"location":"Files/logger_8h/#define-dakku_warn","text":"#define DAKKU_WARN( ... ) SPDLOG_LOGGER_CALL ( Logger :: get (). handle (), spdlog :: level :: warn , __VA_ARGS__ ) log warning message","title":"define DAKKU_WARN"},{"location":"Files/logger_8h/#define-dakku_debug","text":"#define DAKKU_DEBUG( ... ) static_cast < void > ( 0 ) log debug message","title":"define DAKKU_DEBUG"},{"location":"Files/logger_8h/#define-dakku_check","text":"#define DAKKU_CHECK( ... ) static_cast < void > ( 0 ) check whether the condition val is true, if not log error messages","title":"define DAKKU_CHECK"},{"location":"Files/logger_8h/#source-code","text":"#ifndef DAKKU_CORE_LOGGER_H_ #define DAKKU_CORE_LOGGER_H_ #include <core/fwd.h> #include <memory> #include <spdlog/spdlog.h> #include <spdlog/fmt/ostr.h> namespace dakku { class DAKKU_EXPORT_CORE Logger { public : static const Logger & get (); [[ nodiscard ]] spdlog :: logger * handle () const { return _logger . get (); } private : explicit Logger ( std :: shared_ptr < spdlog :: logger > _logger ); std :: shared_ptr < spdlog :: logger > _logger ; }; #define DAKKU_ERR(...) \\ SPDLOG_LOGGER_CALL(Logger::get().handle(), spdlog::level::err, __VA_ARGS__) #define DAKKU_INFO(...) \\ SPDLOG_LOGGER_CALL(Logger::get().handle(), spdlog::level::info, __VA_ARGS__) #define DAKKU_WARN(...) \\ SPDLOG_LOGGER_CALL(Logger::get().handle(), spdlog::level::warn, __VA_ARGS__) #ifdef DAKKU_BUILD_DEBUG #define DAKKU_DEBUG(...) \\ SPDLOG_LOGGER_CALL(Logger::get().handle(), spdlog::level::debug, __VA_ARGS__) #else #define DAKKU_DEBUG(...) static_cast<void>(0) #endif #ifdef DAKKU_BUILD_CHECK #define DAKKU_CHECK(val, ...) \\ do { \\ if (!(val)) { \\ DAKKU_ERR(__VA_ARGS__); \\ std::exit(-1); \\ } \\ } while (0) #else #define DAKKU_CHECK(...) static_cast<void>(0) #endif } // namespace dakku #endif Updated on 2022-04-30 at 15:46:11 +0000","title":"Source code"},{"location":"Files/lua_8h/","text":"src/core/lua.h Namespaces Name dakku dakku namespace Classes Name class dakku::Lua dakku lua state Defines Name SOL_ALL_SAFETIES_ON DAKKU_DECLARE_LUA_OBJECT (name, export) DAKKU_IMPLEMENT_LUA_OBJECT (name, func) Macros Documentation define SOL_ALL_SAFETIES_ON #define SOL_ALL_SAFETIES_ON 1 define DAKKU_DECLARE_LUA_OBJECT #define DAKKU_DECLARE_LUA_OBJECT( name , export ) struct export _ ## name ## _lua_bind_wrapper { \\ static int _ ## name ## _bind_lua ; \\ } define DAKKU_IMPLEMENT_LUA_OBJECT #define DAKKU_IMPLEMENT_LUA_OBJECT( name , func ) int _ ## name ## _lua_bind_wrapper :: _ ## name ## _bind_lua = ( func )() Source code #ifndef DAKKU_CORE_LUA_H_ #define DAKKU_CORE_LUA_H_ #include <core/fwd.h> #if !defined(SOL_ALL_SAFETIES_ON) #define SOL_ALL_SAFETIES_ON 1 #endif #include <sol/sol.hpp> namespace dakku { class DAKKU_EXPORT_CORE Lua { public : static Lua & instance (); sol :: state & get_state (); private : Lua () = default ; sol :: state state ; }; #define DAKKU_DECLARE_LUA_OBJECT(name, export) \\ struct export _##name##_lua_bind_wrapper { \\ static int _##name##_bind_lua; \\ } #define DAKKU_IMPLEMENT_LUA_OBJECT(name, func) \\ int _##name##_lua_bind_wrapper::_##name##_bind_lua = (func)() } // namespace dakku #endif Updated on 2022-04-30 at 15:46:11 +0000","title":"src/core/lua.h"},{"location":"Files/lua_8h/#srccoreluah","text":"","title":"src/core/lua.h"},{"location":"Files/lua_8h/#namespaces","text":"Name dakku dakku namespace","title":"Namespaces"},{"location":"Files/lua_8h/#classes","text":"Name class dakku::Lua dakku lua state","title":"Classes"},{"location":"Files/lua_8h/#defines","text":"Name SOL_ALL_SAFETIES_ON DAKKU_DECLARE_LUA_OBJECT (name, export) DAKKU_IMPLEMENT_LUA_OBJECT (name, func)","title":"Defines"},{"location":"Files/lua_8h/#macros-documentation","text":"","title":"Macros Documentation"},{"location":"Files/lua_8h/#define-sol_all_safeties_on","text":"#define SOL_ALL_SAFETIES_ON 1","title":"define SOL_ALL_SAFETIES_ON"},{"location":"Files/lua_8h/#define-dakku_declare_lua_object","text":"#define DAKKU_DECLARE_LUA_OBJECT( name , export ) struct export _ ## name ## _lua_bind_wrapper { \\ static int _ ## name ## _bind_lua ; \\ }","title":"define DAKKU_DECLARE_LUA_OBJECT"},{"location":"Files/lua_8h/#define-dakku_implement_lua_object","text":"#define DAKKU_IMPLEMENT_LUA_OBJECT( name , func ) int _ ## name ## _lua_bind_wrapper :: _ ## name ## _bind_lua = ( func )()","title":"define DAKKU_IMPLEMENT_LUA_OBJECT"},{"location":"Files/lua_8h/#source-code","text":"#ifndef DAKKU_CORE_LUA_H_ #define DAKKU_CORE_LUA_H_ #include <core/fwd.h> #if !defined(SOL_ALL_SAFETIES_ON) #define SOL_ALL_SAFETIES_ON 1 #endif #include <sol/sol.hpp> namespace dakku { class DAKKU_EXPORT_CORE Lua { public : static Lua & instance (); sol :: state & get_state (); private : Lua () = default ; sol :: state state ; }; #define DAKKU_DECLARE_LUA_OBJECT(name, export) \\ struct export _##name##_lua_bind_wrapper { \\ static int _##name##_bind_lua; \\ } #define DAKKU_IMPLEMENT_LUA_OBJECT(name, func) \\ int _##name##_lua_bind_wrapper::_##name##_bind_lua = (func)() } // namespace dakku #endif Updated on 2022-04-30 at 15:46:11 +0000","title":"Source code"},{"location":"Files/math__func_8h/","text":"src/core/math_func.h Namespaces Name dakku dakku namespace Source code #ifndef DAKKU_CORE_MATH_FUNC_H_ #define DAKKU_CORE_MATH_FUNC_H_ #include <core/fwd.h> #include <cmath> namespace dakku { template < typename T > requires std :: is_floating_point_v < T > DAKKU_INLINE bool isnan ( T x ) { return std :: isnan ( x ); } template < typename T > requires std :: is_integral_v < T > DAKKU_INLINE bool isnan ( T ) { return false ; } } // namespace dakku #endif Updated on 2022-04-30 at 15:46:11 +0000","title":"src/core/math_func.h"},{"location":"Files/math__func_8h/#srccoremath_funch","text":"","title":"src/core/math_func.h"},{"location":"Files/math__func_8h/#namespaces","text":"Name dakku dakku namespace","title":"Namespaces"},{"location":"Files/math__func_8h/#source-code","text":"#ifndef DAKKU_CORE_MATH_FUNC_H_ #define DAKKU_CORE_MATH_FUNC_H_ #include <core/fwd.h> #include <cmath> namespace dakku { template < typename T > requires std :: is_floating_point_v < T > DAKKU_INLINE bool isnan ( T x ) { return std :: isnan ( x ); } template < typename T > requires std :: is_integral_v < T > DAKKU_INLINE bool isnan ( T ) { return false ; } } // namespace dakku #endif Updated on 2022-04-30 at 15:46:11 +0000","title":"Source code"},{"location":"Files/memory_8h/","text":"src/core/memory.h Namespaces Name dakku dakku namespace Classes Name class dakku::MemoryArena memory arena (unsynchronized) class dakku::GlobalMemoryArena global memory arena Defines Name DAKKU_ALLOCA (type, count) allocated memory from stack Macros Documentation define DAKKU_ALLOCA #define DAKKU_ALLOCA( type , count ) ( reinterpret_cast < ( type ) *> ( alloca (( count ) * sizeof ( type )))) allocated memory from stack Parameters : type type that needs to allocate count the number of [type]s Source code #ifndef DAKKU_CORE_MEMORY_H_ #define DAKKU_CORE_MEMORY_H_ #include <core/logger.h> #include <oneapi/tbb.h> #include <oneapi/tbb/scalable_allocator.h> #if __has_include(<malloc.h>) #include <malloc.h> #endif #if __has_include(<alloca.h>) #include <alloca.h> #endif #include <memory_resource> namespace dakku { #define DAKKU_ALLOCA(type, count) \\ (reinterpret_cast<(type) *>(alloca((count) * sizeof(type)))) class DAKKU_EXPORT_CORE MemoryArena { public : explicit MemoryArena () = default ; explicit MemoryArena ( std :: pmr :: memory_resource * buffer ) : upStream ( buffer ), resource ( & upStream ) {} template < typename T , typename ... Args > T * allocObject ( Args && ... args ) { return std :: pmr :: polymorphic_allocator < T > { & resource }. template new_object < T > ( std :: forward < Args > ( args )...); } void release () { resource . release (); } private : oneapi :: tbb :: cache_aligned_resource upStream { oneapi :: tbb :: scalable_memory_resource ()}; std :: pmr :: unsynchronized_pool_resource resource { & upStream }; }; class DAKKU_EXPORT_CORE GlobalMemoryArena { public : static MemoryArena & instance (); private : GlobalMemoryArena () = default ; MemoryArena arena ; }; } // namespace dakku #endif Updated on 2022-04-30 at 15:46:11 +0000","title":"src/core/memory.h"},{"location":"Files/memory_8h/#srccorememoryh","text":"","title":"src/core/memory.h"},{"location":"Files/memory_8h/#namespaces","text":"Name dakku dakku namespace","title":"Namespaces"},{"location":"Files/memory_8h/#classes","text":"Name class dakku::MemoryArena memory arena (unsynchronized) class dakku::GlobalMemoryArena global memory arena","title":"Classes"},{"location":"Files/memory_8h/#defines","text":"Name DAKKU_ALLOCA (type, count) allocated memory from stack","title":"Defines"},{"location":"Files/memory_8h/#macros-documentation","text":"","title":"Macros Documentation"},{"location":"Files/memory_8h/#define-dakku_alloca","text":"#define DAKKU_ALLOCA( type , count ) ( reinterpret_cast < ( type ) *> ( alloca (( count ) * sizeof ( type )))) allocated memory from stack Parameters : type type that needs to allocate count the number of [type]s","title":"define DAKKU_ALLOCA"},{"location":"Files/memory_8h/#source-code","text":"#ifndef DAKKU_CORE_MEMORY_H_ #define DAKKU_CORE_MEMORY_H_ #include <core/logger.h> #include <oneapi/tbb.h> #include <oneapi/tbb/scalable_allocator.h> #if __has_include(<malloc.h>) #include <malloc.h> #endif #if __has_include(<alloca.h>) #include <alloca.h> #endif #include <memory_resource> namespace dakku { #define DAKKU_ALLOCA(type, count) \\ (reinterpret_cast<(type) *>(alloca((count) * sizeof(type)))) class DAKKU_EXPORT_CORE MemoryArena { public : explicit MemoryArena () = default ; explicit MemoryArena ( std :: pmr :: memory_resource * buffer ) : upStream ( buffer ), resource ( & upStream ) {} template < typename T , typename ... Args > T * allocObject ( Args && ... args ) { return std :: pmr :: polymorphic_allocator < T > { & resource }. template new_object < T > ( std :: forward < Args > ( args )...); } void release () { resource . release (); } private : oneapi :: tbb :: cache_aligned_resource upStream { oneapi :: tbb :: scalable_memory_resource ()}; std :: pmr :: unsynchronized_pool_resource resource { & upStream }; }; class DAKKU_EXPORT_CORE GlobalMemoryArena { public : static MemoryArena & instance (); private : GlobalMemoryArena () = default ; MemoryArena arena ; }; } // namespace dakku #endif Updated on 2022-04-30 at 15:46:11 +0000","title":"Source code"},{"location":"Files/platform_8h/","text":"src/platform.h Namespaces Name dakku dakku namespace Defines Name DAKKU_INLINE DAKKU_EXPORT DAKKU_IMPORT DAKKU_CORE_MODULE dakku core module DAKKU_FILTERS_MODULE dakku filters module DAKKU_MAIN_MODULE dakku main module Macros Documentation define DAKKU_INLINE #define DAKKU_INLINE __attribute__((always_inline)) inline define DAKKU_EXPORT #define DAKKU_EXPORT __attribute__((visibility(\"default\"))) define DAKKU_IMPORT #define DAKKU_IMPORT define DAKKU_CORE_MODULE #define DAKKU_CORE_MODULE 1 dakku core module define DAKKU_FILTERS_MODULE #define DAKKU_FILTERS_MODULE 2 dakku filters module define DAKKU_MAIN_MODULE #define DAKKU_MAIN_MODULE 10 dakku main module Source code #ifndef DAKKU_PLATFORM_H_ #define DAKKU_PLATFORM_H_ #if defined(_MSC_VER) #if !defined(_USE_MATH_DEFINES) && !defined(M_PI) #define _USE_MATH_DEFINES #endif #endif namespace dakku { #if defined(_MSC_VER) #define DAKKU_INLINE __forceinline #define DAKKU_EXPORT __declspec(dllexport) #define DAKKU_IMPORT __declspec(dllimport) #else #define DAKKU_INLINE __attribute__((always_inline)) inline #define DAKKU_EXPORT __attribute__((visibility(\"default\"))) #define DAKKU_IMPORT #endif #define DAKKU_CORE_MODULE 1 #define DAKKU_FILTERS_MODULE 2 #define DAKKU_MAIN_MODULE 10 #if defined(_MSC_VER) #pragma warning(disable : 4251) #endif } // namespace dakku #endif Updated on 2022-04-30 at 15:46:11 +0000","title":"src/platform.h"},{"location":"Files/platform_8h/#srcplatformh","text":"","title":"src/platform.h"},{"location":"Files/platform_8h/#namespaces","text":"Name dakku dakku namespace","title":"Namespaces"},{"location":"Files/platform_8h/#defines","text":"Name DAKKU_INLINE DAKKU_EXPORT DAKKU_IMPORT DAKKU_CORE_MODULE dakku core module DAKKU_FILTERS_MODULE dakku filters module DAKKU_MAIN_MODULE dakku main module","title":"Defines"},{"location":"Files/platform_8h/#macros-documentation","text":"","title":"Macros Documentation"},{"location":"Files/platform_8h/#define-dakku_inline","text":"#define DAKKU_INLINE __attribute__((always_inline)) inline","title":"define DAKKU_INLINE"},{"location":"Files/platform_8h/#define-dakku_export","text":"#define DAKKU_EXPORT __attribute__((visibility(\"default\")))","title":"define DAKKU_EXPORT"},{"location":"Files/platform_8h/#define-dakku_import","text":"#define DAKKU_IMPORT","title":"define DAKKU_IMPORT"},{"location":"Files/platform_8h/#define-dakku_core_module","text":"#define DAKKU_CORE_MODULE 1 dakku core module","title":"define DAKKU_CORE_MODULE"},{"location":"Files/platform_8h/#define-dakku_filters_module","text":"#define DAKKU_FILTERS_MODULE 2 dakku filters module","title":"define DAKKU_FILTERS_MODULE"},{"location":"Files/platform_8h/#define-dakku_main_module","text":"#define DAKKU_MAIN_MODULE 10 dakku main module","title":"define DAKKU_MAIN_MODULE"},{"location":"Files/platform_8h/#source-code","text":"#ifndef DAKKU_PLATFORM_H_ #define DAKKU_PLATFORM_H_ #if defined(_MSC_VER) #if !defined(_USE_MATH_DEFINES) && !defined(M_PI) #define _USE_MATH_DEFINES #endif #endif namespace dakku { #if defined(_MSC_VER) #define DAKKU_INLINE __forceinline #define DAKKU_EXPORT __declspec(dllexport) #define DAKKU_IMPORT __declspec(dllimport) #else #define DAKKU_INLINE __attribute__((always_inline)) inline #define DAKKU_EXPORT __attribute__((visibility(\"default\"))) #define DAKKU_IMPORT #endif #define DAKKU_CORE_MODULE 1 #define DAKKU_FILTERS_MODULE 2 #define DAKKU_MAIN_MODULE 10 #if defined(_MSC_VER) #pragma warning(disable : 4251) #endif } // namespace dakku #endif Updated on 2022-04-30 at 15:46:11 +0000","title":"Source code"},{"location":"Files/ray_8h/","text":"src/core/ray.h Namespaces Name dakku dakku namespace Classes Name class dakku::Ray ray class dakku::RayDifferential differential ray Source code #ifndef DAKKU_CORE_RAY_H_ #define DAKKU_CORE_RAY_H_ #include <core/vector.h> #include <core/constants.h> namespace dakku { class Ray { public : Ray () = default ; explicit Ray ( Point3f o , Vector3f d , float t_max = INF ) : o ( std :: move ( o )), d ( std :: move ( d )), tMax ( t_max ) {} Point3f operator ()( float t ) const { return o + d * t ; } [[ nodiscard ]] bool has_nans () const { return o . has_nans () || d . has_nans () || isnan ( tMax ); } Point3f o ; Vector3f d ; mutable float tMax { INF }; }; class RayDifferential : public Ray { public : RayDifferential () = default ; explicit RayDifferential ( const Point3f & o , const Vector3f & d , float t_max = INF ) : Ray ( o , d , t_max ) {} [[ nodiscard ]] bool has_nans () const { return Ray :: has_nans () || ( has_differentials && ( rx_origin . has_nans () || ry_origin . has_nans () || rx_direction . has_nans () || ry_direction . has_nans ())); } void scale_differentials ( float s ) { rx_origin = o + ( rx_origin - o ) * s ; ry_origin = o + ( ry_origin - o ) * s ; rx_direction = d + ( rx_direction - d ) * s ; ry_direction = d + ( ry_direction - d ) * s ; } bool has_differentials { false }; Point3f rx_origin ; Point3f ry_origin ; Vector3f rx_direction ; Vector3f ry_direction ; }; } // namespace dakku #endif Updated on 2022-04-30 at 15:46:11 +0000","title":"src/core/ray.h"},{"location":"Files/ray_8h/#srccorerayh","text":"","title":"src/core/ray.h"},{"location":"Files/ray_8h/#namespaces","text":"Name dakku dakku namespace","title":"Namespaces"},{"location":"Files/ray_8h/#classes","text":"Name class dakku::Ray ray class dakku::RayDifferential differential ray","title":"Classes"},{"location":"Files/ray_8h/#source-code","text":"#ifndef DAKKU_CORE_RAY_H_ #define DAKKU_CORE_RAY_H_ #include <core/vector.h> #include <core/constants.h> namespace dakku { class Ray { public : Ray () = default ; explicit Ray ( Point3f o , Vector3f d , float t_max = INF ) : o ( std :: move ( o )), d ( std :: move ( d )), tMax ( t_max ) {} Point3f operator ()( float t ) const { return o + d * t ; } [[ nodiscard ]] bool has_nans () const { return o . has_nans () || d . has_nans () || isnan ( tMax ); } Point3f o ; Vector3f d ; mutable float tMax { INF }; }; class RayDifferential : public Ray { public : RayDifferential () = default ; explicit RayDifferential ( const Point3f & o , const Vector3f & d , float t_max = INF ) : Ray ( o , d , t_max ) {} [[ nodiscard ]] bool has_nans () const { return Ray :: has_nans () || ( has_differentials && ( rx_origin . has_nans () || ry_origin . has_nans () || rx_direction . has_nans () || ry_direction . has_nans ())); } void scale_differentials ( float s ) { rx_origin = o + ( rx_origin - o ) * s ; ry_origin = o + ( ry_origin - o ) * s ; rx_direction = d + ( rx_direction - d ) * s ; ry_direction = d + ( ry_direction - d ) * s ; } bool has_differentials { false }; Point3f rx_origin ; Point3f ry_origin ; Vector3f rx_direction ; Vector3f ry_direction ; }; } // namespace dakku #endif Updated on 2022-04-30 at 15:46:11 +0000","title":"Source code"},{"location":"Files/triangle_8h/","text":"src/filters/triangle.h Namespaces Name dakku dakku namespace Classes Name class dakku::TriangleFilter triangle filter the weight falls off linearly from the filter center over the square extent of the filter Source code #ifndef DAKKU_FILTERS_Triangle_H_ #define DAKKU_FILTERS_Triangle_H_ #include <filters/fwd.h> namespace dakku { class DAKKU_EXPORT_FILTERS TriangleFilter : public Filter { public : using Filter :: Filter ; [[ nodiscard ]] float evaluate ( const Point2f & p ) const override ; }; DAKKU_EXPORT_FILTERS Filter * create_triangle_filter ( float x_width , float y_width ); DAKKU_DECLARE_LUA_OBJECT ( TriangleFilter , DAKKU_EXPORT_FILTERS ); } // namespace dakku #endif Updated on 2022-04-30 at 15:46:11 +0000","title":"src/filters/triangle.h"},{"location":"Files/triangle_8h/#srcfilterstriangleh","text":"","title":"src/filters/triangle.h"},{"location":"Files/triangle_8h/#namespaces","text":"Name dakku dakku namespace","title":"Namespaces"},{"location":"Files/triangle_8h/#classes","text":"Name class dakku::TriangleFilter triangle filter the weight falls off linearly from the filter center over the square extent of the filter","title":"Classes"},{"location":"Files/triangle_8h/#source-code","text":"#ifndef DAKKU_FILTERS_Triangle_H_ #define DAKKU_FILTERS_Triangle_H_ #include <filters/fwd.h> namespace dakku { class DAKKU_EXPORT_FILTERS TriangleFilter : public Filter { public : using Filter :: Filter ; [[ nodiscard ]] float evaluate ( const Point2f & p ) const override ; }; DAKKU_EXPORT_FILTERS Filter * create_triangle_filter ( float x_width , float y_width ); DAKKU_DECLARE_LUA_OBJECT ( TriangleFilter , DAKKU_EXPORT_FILTERS ); } // namespace dakku #endif Updated on 2022-04-30 at 15:46:11 +0000","title":"Source code"},{"location":"Files/vector_8h/","text":"src/core/vector.h Namespaces Name dakku dakku namespace Classes Name class dakku::Vector vector class dakku::Point point class dakku::Normal normal Source code #ifndef DAKKU_CORE_VECTOR_H_ #define DAKKU_CORE_VECTOR_H_ #include <core/vector_base.h> #include <core/lua.h> namespace dakku { template < typename T , size_t S > class Vector : public VectorBase < T , S , Vector < T , S >> { public : using VectorBase < T , S , Vector < T , S >>:: VectorBase ; Vector operator - () const { Vector ret = * this ; for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = - ret [ i ]; return ret ; } Vector operator - ( const Vector & rhs ) const { Vector ret = * this ; ret -= rhs ; return ret ; } template < ArithmeticType V > Vector operator - ( V rhs ) const { Vector ret = * this ; ret -= rhs ; return ret ; } }; using Vector2i = Vector < int , 2 > ; using Vector2f = Vector < float , 2 > ; using Vector3i = Vector < int , 3 > ; using Vector3f = Vector < float , 3 > ; DAKKU_DECLARE_LUA_OBJECT ( Vector2i , DAKKU_EXPORT_CORE ); DAKKU_DECLARE_LUA_OBJECT ( Vector2f , DAKKU_EXPORT_CORE ); DAKKU_DECLARE_LUA_OBJECT ( Vector3i , DAKKU_EXPORT_CORE ); DAKKU_DECLARE_LUA_OBJECT ( Vector3f , DAKKU_EXPORT_CORE ); template < typename T , size_t S > class Point : public VectorBase < T , S , Point < T , S >> { public : using VectorBase < T , S , Point < T , S >>:: VectorBase ; Point operator - () const { Point ret = * this ; for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = - ret [ i ]; return ret ; } template < ArithmeticType V > Point operator - ( V rhs ) const { Point ret = * this ; ret -= rhs ; return ret ; } Vector < T , S > operator - ( const Point & rhs ) const { Point ret = * this ; ret -= rhs ; return Vector < T , S > { ret }; } Point operator - ( const Vector < T , S > & rhs ) const { Point ret = * this ; ret -= Point ( rhs ); return ret ; } friend Point operator + ( const Point & a , const Vector < T , S > & b ) { return Point ( Vector < T , S > ( a ) + b ); } }; using Point3f = Point < float , 3 > ; using Point3i = Point < int , 3 > ; using Point2f = Point < float , 2 > ; using Point2i = Point < int , 2 > ; DAKKU_DECLARE_LUA_OBJECT ( Point3f , DAKKU_EXPORT_CORE ); DAKKU_DECLARE_LUA_OBJECT ( Point3i , DAKKU_EXPORT_CORE ); DAKKU_DECLARE_LUA_OBJECT ( Point2f , DAKKU_EXPORT_CORE ); DAKKU_DECLARE_LUA_OBJECT ( Point2i , DAKKU_EXPORT_CORE ); template < typename T , size_t S > class Normal : public VectorBase < T , S , Normal < T , S >> { public : using VectorBase < T , S , Normal < T , S >>:: VectorBase ; Normal operator - () const { Normal ret = * this ; for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = - ret [ i ]; return ret ; } Normal operator - ( const Normal & rhs ) const { Normal ret = * this ; ret -= rhs ; return ret ; } template < ArithmeticType V > Normal operator - ( V rhs ) const { Normal ret = * this ; ret -= rhs ; return ret ; } }; using Normal3f = Normal < float , 3 > ; DAKKU_DECLARE_LUA_OBJECT ( Normal3f , DAKKU_EXPORT_CORE ); } // namespace dakku #endif Updated on 2022-04-30 at 15:46:11 +0000","title":"src/core/vector.h"},{"location":"Files/vector_8h/#srccorevectorh","text":"","title":"src/core/vector.h"},{"location":"Files/vector_8h/#namespaces","text":"Name dakku dakku namespace","title":"Namespaces"},{"location":"Files/vector_8h/#classes","text":"Name class dakku::Vector vector class dakku::Point point class dakku::Normal normal","title":"Classes"},{"location":"Files/vector_8h/#source-code","text":"#ifndef DAKKU_CORE_VECTOR_H_ #define DAKKU_CORE_VECTOR_H_ #include <core/vector_base.h> #include <core/lua.h> namespace dakku { template < typename T , size_t S > class Vector : public VectorBase < T , S , Vector < T , S >> { public : using VectorBase < T , S , Vector < T , S >>:: VectorBase ; Vector operator - () const { Vector ret = * this ; for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = - ret [ i ]; return ret ; } Vector operator - ( const Vector & rhs ) const { Vector ret = * this ; ret -= rhs ; return ret ; } template < ArithmeticType V > Vector operator - ( V rhs ) const { Vector ret = * this ; ret -= rhs ; return ret ; } }; using Vector2i = Vector < int , 2 > ; using Vector2f = Vector < float , 2 > ; using Vector3i = Vector < int , 3 > ; using Vector3f = Vector < float , 3 > ; DAKKU_DECLARE_LUA_OBJECT ( Vector2i , DAKKU_EXPORT_CORE ); DAKKU_DECLARE_LUA_OBJECT ( Vector2f , DAKKU_EXPORT_CORE ); DAKKU_DECLARE_LUA_OBJECT ( Vector3i , DAKKU_EXPORT_CORE ); DAKKU_DECLARE_LUA_OBJECT ( Vector3f , DAKKU_EXPORT_CORE ); template < typename T , size_t S > class Point : public VectorBase < T , S , Point < T , S >> { public : using VectorBase < T , S , Point < T , S >>:: VectorBase ; Point operator - () const { Point ret = * this ; for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = - ret [ i ]; return ret ; } template < ArithmeticType V > Point operator - ( V rhs ) const { Point ret = * this ; ret -= rhs ; return ret ; } Vector < T , S > operator - ( const Point & rhs ) const { Point ret = * this ; ret -= rhs ; return Vector < T , S > { ret }; } Point operator - ( const Vector < T , S > & rhs ) const { Point ret = * this ; ret -= Point ( rhs ); return ret ; } friend Point operator + ( const Point & a , const Vector < T , S > & b ) { return Point ( Vector < T , S > ( a ) + b ); } }; using Point3f = Point < float , 3 > ; using Point3i = Point < int , 3 > ; using Point2f = Point < float , 2 > ; using Point2i = Point < int , 2 > ; DAKKU_DECLARE_LUA_OBJECT ( Point3f , DAKKU_EXPORT_CORE ); DAKKU_DECLARE_LUA_OBJECT ( Point3i , DAKKU_EXPORT_CORE ); DAKKU_DECLARE_LUA_OBJECT ( Point2f , DAKKU_EXPORT_CORE ); DAKKU_DECLARE_LUA_OBJECT ( Point2i , DAKKU_EXPORT_CORE ); template < typename T , size_t S > class Normal : public VectorBase < T , S , Normal < T , S >> { public : using VectorBase < T , S , Normal < T , S >>:: VectorBase ; Normal operator - () const { Normal ret = * this ; for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = - ret [ i ]; return ret ; } Normal operator - ( const Normal & rhs ) const { Normal ret = * this ; ret -= rhs ; return ret ; } template < ArithmeticType V > Normal operator - ( V rhs ) const { Normal ret = * this ; ret -= rhs ; return ret ; } }; using Normal3f = Normal < float , 3 > ; DAKKU_DECLARE_LUA_OBJECT ( Normal3f , DAKKU_EXPORT_CORE ); } // namespace dakku #endif Updated on 2022-04-30 at 15:46:11 +0000","title":"Source code"},{"location":"Files/vector__base_8h/","text":"src/core/vector_base.h Namespaces Name dakku dakku namespace Classes Name class dakku::VectorBase vector base Source code #ifndef DAKKU_CORE_VECTOR_BASE_H_ #define DAKKU_CORE_VECTOR_BASE_H_ #include <core/logger.h> #include <core/lua.h> #include <array> #include <numeric> #include <span> namespace dakku { template < ArithmeticType T , size_t S , typename D > class VectorBase { public : VectorBase () : _data () {} template < ArithmeticType Arg > VectorBase ( Arg value ) { set ( value ); DAKKU_CHECK ( ! has_nans (), \"has nan\" ); } VectorBase ( const sol :: table & table ) { for ( size_t i = 0 ; i < S ; ++ i ) _data [ i ] = table . get_or ( i + 1 , T { 0 }); DAKKU_CHECK ( ! has_nans (), \"has nan\" ); } template < ArithmeticType ... Args > requires ( sizeof ...( Args ) == S ) VectorBase ( Args && ... args ) { set ( std :: forward < Args > ( args )...); } template < ArithmeticType Other , typename OtherDerived > explicit VectorBase ( const VectorBase < Other , S , OtherDerived > & other ) { set ( other ); DAKKU_CHECK ( ! has_nans (), \"has nan\" ); } VectorBase ( const VectorBase & other ) : _data ( other . _data ) { DAKKU_CHECK ( ! has_nans (), \"has nan\" ); } VectorBase ( VectorBase && other ) noexcept : _data ( std :: move ( other . _data )) { DAKKU_CHECK ( ! has_nans (), \"has nan\" ); } VectorBase & operator = ( const VectorBase & other ) { if ( this == & other ) return * this ; _data = other . _data ; DAKKU_CHECK ( ! has_nans (), \"has nan\" ); return * this ; } VectorBase & operator = ( VectorBase && other ) noexcept { if ( this == & other ) return * this ; _data = std :: move ( other . _data ); DAKKU_CHECK ( ! has_nans (), \"has nan\" ); return * this ; } const D & derived () const { return static_cast < const D &> ( * this ); } D & derived () { return const_cast < D &> ( static_cast < const VectorBase &> ( * this ). derived ()); } template < ArithmeticType Arg > void set ( Arg value ) { _data . fill ( static_cast < T > ( value )); } template < ArithmeticType Arg > void set_by_index ( size_t index , Arg value ) { DAKKU_CHECK ( 0 <= index && index < S , \"index out of range: {} >= {}\" , index , S ); _data [ index ] = static_cast < T > ( value ); } template < ArithmeticType ... Args , size_t ... Is > requires ( sizeof ...( Args ) == S ) void set ( std :: index_sequence < Is ... > , Args && ... args ) { ( set_by_index ( Is , std :: forward < Args > ( args )), ...); } template < ArithmeticType ... Args > requires ( sizeof ...( Args ) == S ) void set ( Args && ... args ) { set ( std :: index_sequence_for < Args ... > {}, std :: forward < Args > ( args )...); } template < ArithmeticType Other , typename OtherDerived > void set ( const VectorBase < Other , S , OtherDerived > & rhs ) { for ( size_t i = 0 ; i < S ; ++ i ) _data [ i ] = static_cast < T > ( rhs [ i ]); } const T & get ( size_t i ) const { DAKKU_CHECK ( 0 <= i && i < S , \"index out of range {} >= {}\" , i , S ); return _data [ i ]; } [[ nodiscard ]] size_t size () const { return S ; } [[ nodiscard ]] std :: string to_string () const { std :: string ret { \"[\" }; for ( size_t i = 0 ; i < _data . size (); ++ i ) { ret += std :: to_string ( _data [ i ]); if ( i + 1 != _data . size ()) ret += \", \" ; } return ret + \"]\" ; } [[ nodiscard ]] bool has_nans () const { return std :: any_of ( std :: begin ( _data ), std :: end ( _data ), []( T x ) { return isnan ( x ); }); } D clone () const { return D { derived ()}; } const T & operator []( size_t i ) const { return _data [ i ]; } T & operator []( size_t i ) { return const_cast < T &> ( static_cast < const VectorBase &> ( * this )[ i ]); } D & operator += ( const D & rhs ) { for ( size_t i = 0 ; i < S ; ++ i ) _data [ i ] += rhs [ i ]; return derived (); } template < ArithmeticType V > D & operator += ( V rhs ) { for ( size_t i = 0 ; i < S ; ++ i ) _data [ i ] += rhs ; return derived (); } D operator + ( const D & rhs ) const { D ret = derived (); ret += rhs ; return ret ; } template < ArithmeticType V > D operator + ( V rhs ) const { D ret = derived (); ret += rhs ; return ret ; } template < ArithmeticType U > friend D operator + ( U a , const D & b ) { return b + a ; } D & operator -= ( const D & rhs ) { for ( size_t i = 0 ; i < S ; ++ i ) _data [ i ] -= rhs [ i ]; return derived (); } template < ArithmeticType V > D & operator -= ( V rhs ) { for ( size_t i = 0 ; i < S ; ++ i ) _data [ i ] -= rhs ; return derived (); } template < ArithmeticType U > friend D operator - ( U a , const D & b ) { D ret = - b ; ret += a ; return ret ; } D & operator *= ( const D & rhs ) { for ( size_t i = 0 ; i < S ; ++ i ) _data [ i ] *= rhs [ i ]; return derived (); } template < ArithmeticType V > D & operator *= ( V rhs ) { for ( size_t i = 0 ; i < S ; ++ i ) _data [ i ] *= rhs ; return derived (); } D operator * ( const D & rhs ) const { D ret = derived (); ret *= rhs ; return ret ; } template < ArithmeticType V > D operator * ( V rhs ) const { D ret = derived (); ret *= rhs ; return ret ; } template < ArithmeticType U > friend D operator * ( U a , const D & b ) { return b * a ; } D & operator /= ( const D & rhs ) { for ( size_t i = 0 ; i < S ; ++ i ) _data [ i ] /= rhs [ i ]; return derived (); } template < ArithmeticType V > D & operator /= ( V rhs ) { return derived () *= static_cast < T > ( T { 1 } / rhs ); } D operator / ( const D & rhs ) const { D ret = derived (); ret /= rhs ; return ret ; } template < ArithmeticType U > D operator / ( U rhs ) const { D ret = derived (); ret /= rhs ; return ret ; } template < ArithmeticType U > friend D operator / ( U a , const D & b ) { return D ( a ) / b ; } friend std :: ostream & operator << ( std :: ostream & os , const VectorBase & vec ) { return os << vec . to_string (); } bool operator == ( const VectorBase & rhs ) const { return _data == rhs . _data ; } bool operator != ( const VectorBase & rhs ) const { return _data != rhs . _data ; } decltype ( auto ) x () const { static_assert ( S >= 1 , \"not enough size to get x\" ); return _data [ 0 ]; } decltype ( auto ) x () { static_assert ( S >= 1 , \"not enough size to get x\" ); return _data [ 0 ]; } decltype ( auto ) y () const { static_assert ( S >= 2 , \"not enough size to get y\" ); return _data [ 1 ]; } decltype ( auto ) y () { static_assert ( S >= 2 , \"not enough size to get y\" ); return _data [ 1 ]; } decltype ( auto ) z () const { static_assert ( S >= 3 , \"not enough size to get z\" ); return _data [ 2 ]; } decltype ( auto ) z () { static_assert ( S >= 3 , \"not enough size to get w\" ); return _data [ 2 ]; } decltype ( auto ) w () const { static_assert ( S >= 4 , \"not enough size to get w\" ); return _data [ 3 ]; } decltype ( auto ) w () { static_assert ( S >= 4 , \"not enough size to get z\" ); return _data [ 3 ]; } [[ nodiscard ]] size_t max_element_index () const { return std :: distance ( _data . begin (), std :: max_element ( _data . begin (), _data . end ())); } decltype ( auto ) max_element () const { return _data [ max_element_index ()]; } friend D max ( const D & v1 , const D & v2 ) { D ret = v1 ; for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = std :: max ( ret [ i ], v2 [ i ]); return ret ; } D max ( const D & rhs ) const { return max ( derived (), rhs ); } friend D min ( const D & v1 , const D & v2 ) { D ret = v1 ; for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = std :: min ( ret [ i ], v2 [ i ]); return ret ; } D min ( const D & rhs ) const { return min ( derived (), rhs ); } template < typename OtherDerived > decltype ( auto ) dot ( const VectorBase < T , S , OtherDerived > & rhs ) const { return std :: inner_product ( _data . begin (), _data . end (), rhs . _data . begin (), T {}); } decltype ( auto ) squared_norm () const { return this -> dot ( * this ); } decltype ( auto ) norm () const { return std :: sqrt ( squared_norm ()); } decltype ( auto ) length () const { return norm (); } friend decltype ( auto ) distance ( const D & a , const D & b ) { return ( a - b ). length (); } decltype ( auto ) distance ( const D & rhs ) const { return distance ( derived (), rhs ); } friend D abs ( const D & v ) { D ret = v ; for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = std :: abs ( ret [ i ]); return ret ; } D abs () const { return abs ( derived ()); } D cross ( const D & rhs ) const { static_assert ( S == 3 , \"only 3d vector support cross product\" ); return D {( y () * rhs . z ()) - ( z () * rhs . y ()), ( z () * rhs . x ()) - ( x () * rhs . z ()), ( x () * rhs . y ()) - ( y () * rhs . x ())}; } [[ nodiscard ]] bool is_zero () const { return std :: all_of ( _data . begin (), _data . end (), []( const T & v ) { return v == 0 ; }); } friend D sqrt ( const D & v ) { D ret = v ; for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = static_cast < T > ( std :: sqrt ( ret [ i ])); return ret ; } D sqrt () const { return sqrt ( derived ()); } template < ArithmeticType E > friend D pow ( const D & v , E e ) { D ret = v ; for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = static_cast < T > ( std :: pow ( ret [ i ], e )); return ret ; } template < ArithmeticType E > D pow ( E e ) const { return pow ( derived (), e ); } friend D exp ( const D & v ) { D ret = v ; for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = static_cast < T > ( std :: exp ( ret [ i ])); return ret ; } D exp () const { return exp ( derived ()); } friend D floor ( const D & v ) { D ret = v ; for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = std :: floor ( ret [ i ]); return ret ; } D floor () const { return floor ( derived ()); } friend D ceil ( const D & v ) { D ret = v ; for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = std :: ceil ( ret [ i ]); return ret ; } D ceil () const { return ceil ( derived ()); } friend D lerp ( const D & a , const D & b , T t ) { D ret ; for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = std :: lerp ( a [ i ], b [ i ], t ); return ret ; } D lerp ( const D & b , T t ) const { return lerp ( derived (), b , t ); } operator std :: span < T , S > () { return std :: span { _data }; } operator std :: span < const T , S > () const { return std :: span { _data }; } private : std :: array < T , S > _data ; }; } // namespace dakku #endif Updated on 2022-04-30 at 15:46:11 +0000","title":"src/core/vector_base.h"},{"location":"Files/vector__base_8h/#srccorevector_baseh","text":"","title":"src/core/vector_base.h"},{"location":"Files/vector__base_8h/#namespaces","text":"Name dakku dakku namespace","title":"Namespaces"},{"location":"Files/vector__base_8h/#classes","text":"Name class dakku::VectorBase vector base","title":"Classes"},{"location":"Files/vector__base_8h/#source-code","text":"#ifndef DAKKU_CORE_VECTOR_BASE_H_ #define DAKKU_CORE_VECTOR_BASE_H_ #include <core/logger.h> #include <core/lua.h> #include <array> #include <numeric> #include <span> namespace dakku { template < ArithmeticType T , size_t S , typename D > class VectorBase { public : VectorBase () : _data () {} template < ArithmeticType Arg > VectorBase ( Arg value ) { set ( value ); DAKKU_CHECK ( ! has_nans (), \"has nan\" ); } VectorBase ( const sol :: table & table ) { for ( size_t i = 0 ; i < S ; ++ i ) _data [ i ] = table . get_or ( i + 1 , T { 0 }); DAKKU_CHECK ( ! has_nans (), \"has nan\" ); } template < ArithmeticType ... Args > requires ( sizeof ...( Args ) == S ) VectorBase ( Args && ... args ) { set ( std :: forward < Args > ( args )...); } template < ArithmeticType Other , typename OtherDerived > explicit VectorBase ( const VectorBase < Other , S , OtherDerived > & other ) { set ( other ); DAKKU_CHECK ( ! has_nans (), \"has nan\" ); } VectorBase ( const VectorBase & other ) : _data ( other . _data ) { DAKKU_CHECK ( ! has_nans (), \"has nan\" ); } VectorBase ( VectorBase && other ) noexcept : _data ( std :: move ( other . _data )) { DAKKU_CHECK ( ! has_nans (), \"has nan\" ); } VectorBase & operator = ( const VectorBase & other ) { if ( this == & other ) return * this ; _data = other . _data ; DAKKU_CHECK ( ! has_nans (), \"has nan\" ); return * this ; } VectorBase & operator = ( VectorBase && other ) noexcept { if ( this == & other ) return * this ; _data = std :: move ( other . _data ); DAKKU_CHECK ( ! has_nans (), \"has nan\" ); return * this ; } const D & derived () const { return static_cast < const D &> ( * this ); } D & derived () { return const_cast < D &> ( static_cast < const VectorBase &> ( * this ). derived ()); } template < ArithmeticType Arg > void set ( Arg value ) { _data . fill ( static_cast < T > ( value )); } template < ArithmeticType Arg > void set_by_index ( size_t index , Arg value ) { DAKKU_CHECK ( 0 <= index && index < S , \"index out of range: {} >= {}\" , index , S ); _data [ index ] = static_cast < T > ( value ); } template < ArithmeticType ... Args , size_t ... Is > requires ( sizeof ...( Args ) == S ) void set ( std :: index_sequence < Is ... > , Args && ... args ) { ( set_by_index ( Is , std :: forward < Args > ( args )), ...); } template < ArithmeticType ... Args > requires ( sizeof ...( Args ) == S ) void set ( Args && ... args ) { set ( std :: index_sequence_for < Args ... > {}, std :: forward < Args > ( args )...); } template < ArithmeticType Other , typename OtherDerived > void set ( const VectorBase < Other , S , OtherDerived > & rhs ) { for ( size_t i = 0 ; i < S ; ++ i ) _data [ i ] = static_cast < T > ( rhs [ i ]); } const T & get ( size_t i ) const { DAKKU_CHECK ( 0 <= i && i < S , \"index out of range {} >= {}\" , i , S ); return _data [ i ]; } [[ nodiscard ]] size_t size () const { return S ; } [[ nodiscard ]] std :: string to_string () const { std :: string ret { \"[\" }; for ( size_t i = 0 ; i < _data . size (); ++ i ) { ret += std :: to_string ( _data [ i ]); if ( i + 1 != _data . size ()) ret += \", \" ; } return ret + \"]\" ; } [[ nodiscard ]] bool has_nans () const { return std :: any_of ( std :: begin ( _data ), std :: end ( _data ), []( T x ) { return isnan ( x ); }); } D clone () const { return D { derived ()}; } const T & operator []( size_t i ) const { return _data [ i ]; } T & operator []( size_t i ) { return const_cast < T &> ( static_cast < const VectorBase &> ( * this )[ i ]); } D & operator += ( const D & rhs ) { for ( size_t i = 0 ; i < S ; ++ i ) _data [ i ] += rhs [ i ]; return derived (); } template < ArithmeticType V > D & operator += ( V rhs ) { for ( size_t i = 0 ; i < S ; ++ i ) _data [ i ] += rhs ; return derived (); } D operator + ( const D & rhs ) const { D ret = derived (); ret += rhs ; return ret ; } template < ArithmeticType V > D operator + ( V rhs ) const { D ret = derived (); ret += rhs ; return ret ; } template < ArithmeticType U > friend D operator + ( U a , const D & b ) { return b + a ; } D & operator -= ( const D & rhs ) { for ( size_t i = 0 ; i < S ; ++ i ) _data [ i ] -= rhs [ i ]; return derived (); } template < ArithmeticType V > D & operator -= ( V rhs ) { for ( size_t i = 0 ; i < S ; ++ i ) _data [ i ] -= rhs ; return derived (); } template < ArithmeticType U > friend D operator - ( U a , const D & b ) { D ret = - b ; ret += a ; return ret ; } D & operator *= ( const D & rhs ) { for ( size_t i = 0 ; i < S ; ++ i ) _data [ i ] *= rhs [ i ]; return derived (); } template < ArithmeticType V > D & operator *= ( V rhs ) { for ( size_t i = 0 ; i < S ; ++ i ) _data [ i ] *= rhs ; return derived (); } D operator * ( const D & rhs ) const { D ret = derived (); ret *= rhs ; return ret ; } template < ArithmeticType V > D operator * ( V rhs ) const { D ret = derived (); ret *= rhs ; return ret ; } template < ArithmeticType U > friend D operator * ( U a , const D & b ) { return b * a ; } D & operator /= ( const D & rhs ) { for ( size_t i = 0 ; i < S ; ++ i ) _data [ i ] /= rhs [ i ]; return derived (); } template < ArithmeticType V > D & operator /= ( V rhs ) { return derived () *= static_cast < T > ( T { 1 } / rhs ); } D operator / ( const D & rhs ) const { D ret = derived (); ret /= rhs ; return ret ; } template < ArithmeticType U > D operator / ( U rhs ) const { D ret = derived (); ret /= rhs ; return ret ; } template < ArithmeticType U > friend D operator / ( U a , const D & b ) { return D ( a ) / b ; } friend std :: ostream & operator << ( std :: ostream & os , const VectorBase & vec ) { return os << vec . to_string (); } bool operator == ( const VectorBase & rhs ) const { return _data == rhs . _data ; } bool operator != ( const VectorBase & rhs ) const { return _data != rhs . _data ; } decltype ( auto ) x () const { static_assert ( S >= 1 , \"not enough size to get x\" ); return _data [ 0 ]; } decltype ( auto ) x () { static_assert ( S >= 1 , \"not enough size to get x\" ); return _data [ 0 ]; } decltype ( auto ) y () const { static_assert ( S >= 2 , \"not enough size to get y\" ); return _data [ 1 ]; } decltype ( auto ) y () { static_assert ( S >= 2 , \"not enough size to get y\" ); return _data [ 1 ]; } decltype ( auto ) z () const { static_assert ( S >= 3 , \"not enough size to get z\" ); return _data [ 2 ]; } decltype ( auto ) z () { static_assert ( S >= 3 , \"not enough size to get w\" ); return _data [ 2 ]; } decltype ( auto ) w () const { static_assert ( S >= 4 , \"not enough size to get w\" ); return _data [ 3 ]; } decltype ( auto ) w () { static_assert ( S >= 4 , \"not enough size to get z\" ); return _data [ 3 ]; } [[ nodiscard ]] size_t max_element_index () const { return std :: distance ( _data . begin (), std :: max_element ( _data . begin (), _data . end ())); } decltype ( auto ) max_element () const { return _data [ max_element_index ()]; } friend D max ( const D & v1 , const D & v2 ) { D ret = v1 ; for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = std :: max ( ret [ i ], v2 [ i ]); return ret ; } D max ( const D & rhs ) const { return max ( derived (), rhs ); } friend D min ( const D & v1 , const D & v2 ) { D ret = v1 ; for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = std :: min ( ret [ i ], v2 [ i ]); return ret ; } D min ( const D & rhs ) const { return min ( derived (), rhs ); } template < typename OtherDerived > decltype ( auto ) dot ( const VectorBase < T , S , OtherDerived > & rhs ) const { return std :: inner_product ( _data . begin (), _data . end (), rhs . _data . begin (), T {}); } decltype ( auto ) squared_norm () const { return this -> dot ( * this ); } decltype ( auto ) norm () const { return std :: sqrt ( squared_norm ()); } decltype ( auto ) length () const { return norm (); } friend decltype ( auto ) distance ( const D & a , const D & b ) { return ( a - b ). length (); } decltype ( auto ) distance ( const D & rhs ) const { return distance ( derived (), rhs ); } friend D abs ( const D & v ) { D ret = v ; for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = std :: abs ( ret [ i ]); return ret ; } D abs () const { return abs ( derived ()); } D cross ( const D & rhs ) const { static_assert ( S == 3 , \"only 3d vector support cross product\" ); return D {( y () * rhs . z ()) - ( z () * rhs . y ()), ( z () * rhs . x ()) - ( x () * rhs . z ()), ( x () * rhs . y ()) - ( y () * rhs . x ())}; } [[ nodiscard ]] bool is_zero () const { return std :: all_of ( _data . begin (), _data . end (), []( const T & v ) { return v == 0 ; }); } friend D sqrt ( const D & v ) { D ret = v ; for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = static_cast < T > ( std :: sqrt ( ret [ i ])); return ret ; } D sqrt () const { return sqrt ( derived ()); } template < ArithmeticType E > friend D pow ( const D & v , E e ) { D ret = v ; for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = static_cast < T > ( std :: pow ( ret [ i ], e )); return ret ; } template < ArithmeticType E > D pow ( E e ) const { return pow ( derived (), e ); } friend D exp ( const D & v ) { D ret = v ; for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = static_cast < T > ( std :: exp ( ret [ i ])); return ret ; } D exp () const { return exp ( derived ()); } friend D floor ( const D & v ) { D ret = v ; for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = std :: floor ( ret [ i ]); return ret ; } D floor () const { return floor ( derived ()); } friend D ceil ( const D & v ) { D ret = v ; for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = std :: ceil ( ret [ i ]); return ret ; } D ceil () const { return ceil ( derived ()); } friend D lerp ( const D & a , const D & b , T t ) { D ret ; for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = std :: lerp ( a [ i ], b [ i ], t ); return ret ; } D lerp ( const D & b , T t ) const { return lerp ( derived (), b , t ); } operator std :: span < T , S > () { return std :: span { _data }; } operator std :: span < const T , S > () const { return std :: span { _data }; } private : std :: array < T , S > _data ; }; } // namespace dakku #endif Updated on 2022-04-30 at 15:46:11 +0000","title":"Source code"},{"location":"Modules/","text":"Modules Updated on 2022-04-30 at 15:46:11 +0000","title":"Modules"},{"location":"Modules/#modules","text":"Updated on 2022-04-30 at 15:46:11 +0000","title":"Modules"},{"location":"Namespaces/","text":"Namespaces namespace dakku dakku namespace namespace std Updated on 2022-04-30 at 15:46:11 +0000","title":"Namespaces"},{"location":"Namespaces/#namespaces","text":"namespace dakku dakku namespace namespace std Updated on 2022-04-30 at 15:46:11 +0000","title":"Namespaces"},{"location":"Namespaces/namespacedakku/","text":"dakku dakku namespace Classes Name class dakku::Bounds2 2d bounding box class dakku::Bounds2iIterator 2d integer bounds iterator, iterate all pixels inside class dakku::Bounds3 3d bounding box class dakku::BoundsBase bounding box base class dakku::BoxFilter box filter the box filter is simple, just return \\(1\\) for all values class dakku::Filter class dakku::GlobalMemoryArena global memory arena class dakku::Logger logger class class dakku::Lua dakku lua state class dakku::MemoryArena memory arena (unsynchronized) class dakku::Normal normal class dakku::Point point class dakku::Ray ray class dakku::RayDifferential differential ray class dakku::TriangleFilter triangle filter the weight falls off linearly from the filter center over the square extent of the filter class dakku::Vector vector class dakku::VectorBase vector base Types Name using Bounds2 < float > Bounds2f 2d float bounds using Bounds2 < int > Bounds2i 2d int bounds using Bounds3 < float > Bounds3f 3d float bounds using Vector < int, 2 > Vector2i 2d int vector using Vector < float, 2 > Vector2f 2d float vector using Vector < int, 3 > Vector3i 3d int vector using Vector < float, 3 > Vector3f 3d float vector using Point < float, 3 > Point3f 3d float point using Point < int, 3 > Point3i 3d int point using Point < float, 2 > Point2f 2d float point using Point < int, 2 > Point2i 2d int point using Normal < float, 3 > Normal3f 3d float normal Functions Name Bounds2iIterator begin (const Bounds2i & b) begin of the bounds2i iteration Bounds2iIterator end (const Bounds2i & b) end of the bounds2i iteration DAKKU_DECLARE_LUA_OBJECT (Bounds , DAKKU_EXPORT_CORE ) template <typename T > DAKKU_INLINE bool isnan (T x) check whether x is not a number template <typename T > DAKKU_INLINE bool isnan (T ) check whether x is not a number DAKKU_DECLARE_LUA_OBJECT ( Vector2i , DAKKU_EXPORT_CORE ) DAKKU_DECLARE_LUA_OBJECT ( Vector2f , DAKKU_EXPORT_CORE ) DAKKU_DECLARE_LUA_OBJECT ( Vector3i , DAKKU_EXPORT_CORE ) DAKKU_DECLARE_LUA_OBJECT ( Vector3f , DAKKU_EXPORT_CORE ) DAKKU_DECLARE_LUA_OBJECT ( Point3f , DAKKU_EXPORT_CORE ) DAKKU_DECLARE_LUA_OBJECT ( Point3i , DAKKU_EXPORT_CORE ) DAKKU_DECLARE_LUA_OBJECT ( Point2f , DAKKU_EXPORT_CORE ) DAKKU_DECLARE_LUA_OBJECT ( Point2i , DAKKU_EXPORT_CORE ) DAKKU_DECLARE_LUA_OBJECT ( Normal3f , DAKKU_EXPORT_CORE ) DAKKU_EXPORT_FILTERS Filter * create_box_filter (float x_width, float y_width) Create a box filter object. DAKKU_DECLARE_LUA_OBJECT ( BoxFilter , DAKKU_EXPORT_FILTERS ) DAKKU_EXPORT_FILTERS Filter * create_triangle_filter (float x_width, float y_width) Create a triangle filter object. DAKKU_DECLARE_LUA_OBJECT ( TriangleFilter , DAKKU_EXPORT_FILTERS ) Attributes Name constexpr float INF infinity constexpr float PI PI. constexpr float INV_PI \\(\\frac 1 \\pi\\) constexpr float PI_OVER_2 \\(\\frac \\pi 2\\) constexpr float PI_OVER_4 \\(\\frac \\pi 4\\) constexpr float SHADOW_EPS shadow epsilon, used for shadow ray, offset ray origin constexpr float ONE_MINUS_EPSILON 1 - eps Types Documentation using Bounds2f using dakku :: Bounds2f = typedef Bounds2 < float > ; 2d float bounds using Bounds2i using dakku :: Bounds2i = typedef Bounds2 < int > ; 2d int bounds using Bounds3f using dakku :: Bounds3f = typedef Bounds3 < float > ; 3d float bounds using Vector2i using dakku :: Vector2i = typedef Vector < int , 2 > ; 2d int vector using Vector2f using dakku :: Vector2f = typedef Vector < float , 2 > ; 2d float vector using Vector3i using dakku :: Vector3i = typedef Vector < int , 3 > ; 3d int vector using Vector3f using dakku :: Vector3f = typedef Vector < float , 3 > ; 3d float vector using Point3f using dakku :: Point3f = typedef Point < float , 3 > ; 3d float point using Point3i using dakku :: Point3i = typedef Point < int , 3 > ; 3d int point using Point2f using dakku :: Point2f = typedef Point < float , 2 > ; 2d float point using Point2i using dakku :: Point2i = typedef Point < int , 2 > ; 2d int point using Normal3f using dakku :: Normal3f = typedef Normal < float , 3 > ; 3d float normal Functions Documentation function begin inline Bounds2iIterator begin ( const Bounds2i & b ) begin of the bounds2i iteration function end inline Bounds2iIterator end ( const Bounds2i & b ) end of the bounds2i iteration function DAKKU_DECLARE_LUA_OBJECT DAKKU_DECLARE_LUA_OBJECT ( Bounds , DAKKU_EXPORT_CORE ) function isnan template < typename T > DAKKU_INLINE bool isnan ( T x ) check whether x is not a number Parameters : x given value Template Parameters : T type (floating point) Return : whether x is nan function isnan template < typename T > DAKKU_INLINE bool isnan ( T ) check whether x is not a number Template Parameters : T type (integer) Return : false (all integers are not nans) function DAKKU_DECLARE_LUA_OBJECT DAKKU_DECLARE_LUA_OBJECT ( Vector2i , DAKKU_EXPORT_CORE ) function DAKKU_DECLARE_LUA_OBJECT DAKKU_DECLARE_LUA_OBJECT ( Vector2f , DAKKU_EXPORT_CORE ) function DAKKU_DECLARE_LUA_OBJECT DAKKU_DECLARE_LUA_OBJECT ( Vector3i , DAKKU_EXPORT_CORE ) function DAKKU_DECLARE_LUA_OBJECT DAKKU_DECLARE_LUA_OBJECT ( Vector3f , DAKKU_EXPORT_CORE ) function DAKKU_DECLARE_LUA_OBJECT DAKKU_DECLARE_LUA_OBJECT ( Point3f , DAKKU_EXPORT_CORE ) function DAKKU_DECLARE_LUA_OBJECT DAKKU_DECLARE_LUA_OBJECT ( Point3i , DAKKU_EXPORT_CORE ) function DAKKU_DECLARE_LUA_OBJECT DAKKU_DECLARE_LUA_OBJECT ( Point2f , DAKKU_EXPORT_CORE ) function DAKKU_DECLARE_LUA_OBJECT DAKKU_DECLARE_LUA_OBJECT ( Point2i , DAKKU_EXPORT_CORE ) function DAKKU_DECLARE_LUA_OBJECT DAKKU_DECLARE_LUA_OBJECT ( Normal3f , DAKKU_EXPORT_CORE ) function create_box_filter DAKKU_EXPORT_FILTERSFilter * create_box_filter ( float x_width , float y_width ) Create a box filter object. function DAKKU_DECLARE_LUA_OBJECT DAKKU_DECLARE_LUA_OBJECT ( BoxFilter , DAKKU_EXPORT_FILTERS ) function create_triangle_filter DAKKU_EXPORT_FILTERSFilter * create_triangle_filter ( float x_width , float y_width ) Create a triangle filter object. function DAKKU_DECLARE_LUA_OBJECT DAKKU_DECLARE_LUA_OBJECT ( TriangleFilter , DAKKU_EXPORT_FILTERS ) Attributes Documentation variable INF static constexpr float INF = std :: numeric_limits < float >:: infinity (); infinity variable PI static constexpr float PI = std :: numbers :: pi_v < float > ; PI. variable INV_PI static constexpr float INV_PI = static_cast < float > ( 1.0 / std :: numbers :: pi_v < double > ); \\(\\frac 1 \\pi\\) variable PI_OVER_2 static constexpr float PI_OVER_2 = static_cast < float > ( std :: numbers :: pi_v < double > / 2.0 ); \\(\\frac \\pi 2\\) variable PI_OVER_4 static constexpr float PI_OVER_4 = static_cast < float > ( std :: numbers :: pi_v < double > / 4.0 ); \\(\\frac \\pi 4\\) variable SHADOW_EPS static constexpr float SHADOW_EPS = 1e-5f ; shadow epsilon, used for shadow ray, offset ray origin variable ONE_MINUS_EPSILON static constexpr float ONE_MINUS_EPSILON = 1 - std :: numeric_limits < float >:: epsilon (); 1 - eps Updated on 2022-04-30 at 15:46:11 +0000","title":"dakku"},{"location":"Namespaces/namespacedakku/#dakku","text":"dakku namespace","title":"dakku"},{"location":"Namespaces/namespacedakku/#classes","text":"Name class dakku::Bounds2 2d bounding box class dakku::Bounds2iIterator 2d integer bounds iterator, iterate all pixels inside class dakku::Bounds3 3d bounding box class dakku::BoundsBase bounding box base class dakku::BoxFilter box filter the box filter is simple, just return \\(1\\) for all values class dakku::Filter class dakku::GlobalMemoryArena global memory arena class dakku::Logger logger class class dakku::Lua dakku lua state class dakku::MemoryArena memory arena (unsynchronized) class dakku::Normal normal class dakku::Point point class dakku::Ray ray class dakku::RayDifferential differential ray class dakku::TriangleFilter triangle filter the weight falls off linearly from the filter center over the square extent of the filter class dakku::Vector vector class dakku::VectorBase vector base","title":"Classes"},{"location":"Namespaces/namespacedakku/#types","text":"Name using Bounds2 < float > Bounds2f 2d float bounds using Bounds2 < int > Bounds2i 2d int bounds using Bounds3 < float > Bounds3f 3d float bounds using Vector < int, 2 > Vector2i 2d int vector using Vector < float, 2 > Vector2f 2d float vector using Vector < int, 3 > Vector3i 3d int vector using Vector < float, 3 > Vector3f 3d float vector using Point < float, 3 > Point3f 3d float point using Point < int, 3 > Point3i 3d int point using Point < float, 2 > Point2f 2d float point using Point < int, 2 > Point2i 2d int point using Normal < float, 3 > Normal3f 3d float normal","title":"Types"},{"location":"Namespaces/namespacedakku/#functions","text":"Name Bounds2iIterator begin (const Bounds2i & b) begin of the bounds2i iteration Bounds2iIterator end (const Bounds2i & b) end of the bounds2i iteration DAKKU_DECLARE_LUA_OBJECT (Bounds , DAKKU_EXPORT_CORE ) template <typename T > DAKKU_INLINE bool isnan (T x) check whether x is not a number template <typename T > DAKKU_INLINE bool isnan (T ) check whether x is not a number DAKKU_DECLARE_LUA_OBJECT ( Vector2i , DAKKU_EXPORT_CORE ) DAKKU_DECLARE_LUA_OBJECT ( Vector2f , DAKKU_EXPORT_CORE ) DAKKU_DECLARE_LUA_OBJECT ( Vector3i , DAKKU_EXPORT_CORE ) DAKKU_DECLARE_LUA_OBJECT ( Vector3f , DAKKU_EXPORT_CORE ) DAKKU_DECLARE_LUA_OBJECT ( Point3f , DAKKU_EXPORT_CORE ) DAKKU_DECLARE_LUA_OBJECT ( Point3i , DAKKU_EXPORT_CORE ) DAKKU_DECLARE_LUA_OBJECT ( Point2f , DAKKU_EXPORT_CORE ) DAKKU_DECLARE_LUA_OBJECT ( Point2i , DAKKU_EXPORT_CORE ) DAKKU_DECLARE_LUA_OBJECT ( Normal3f , DAKKU_EXPORT_CORE ) DAKKU_EXPORT_FILTERS Filter * create_box_filter (float x_width, float y_width) Create a box filter object. DAKKU_DECLARE_LUA_OBJECT ( BoxFilter , DAKKU_EXPORT_FILTERS ) DAKKU_EXPORT_FILTERS Filter * create_triangle_filter (float x_width, float y_width) Create a triangle filter object. DAKKU_DECLARE_LUA_OBJECT ( TriangleFilter , DAKKU_EXPORT_FILTERS )","title":"Functions"},{"location":"Namespaces/namespacedakku/#attributes","text":"Name constexpr float INF infinity constexpr float PI PI. constexpr float INV_PI \\(\\frac 1 \\pi\\) constexpr float PI_OVER_2 \\(\\frac \\pi 2\\) constexpr float PI_OVER_4 \\(\\frac \\pi 4\\) constexpr float SHADOW_EPS shadow epsilon, used for shadow ray, offset ray origin constexpr float ONE_MINUS_EPSILON 1 - eps","title":"Attributes"},{"location":"Namespaces/namespacedakku/#types-documentation","text":"","title":"Types Documentation"},{"location":"Namespaces/namespacedakku/#using-bounds2f","text":"using dakku :: Bounds2f = typedef Bounds2 < float > ; 2d float bounds","title":"using Bounds2f"},{"location":"Namespaces/namespacedakku/#using-bounds2i","text":"using dakku :: Bounds2i = typedef Bounds2 < int > ; 2d int bounds","title":"using Bounds2i"},{"location":"Namespaces/namespacedakku/#using-bounds3f","text":"using dakku :: Bounds3f = typedef Bounds3 < float > ; 3d float bounds","title":"using Bounds3f"},{"location":"Namespaces/namespacedakku/#using-vector2i","text":"using dakku :: Vector2i = typedef Vector < int , 2 > ; 2d int vector","title":"using Vector2i"},{"location":"Namespaces/namespacedakku/#using-vector2f","text":"using dakku :: Vector2f = typedef Vector < float , 2 > ; 2d float vector","title":"using Vector2f"},{"location":"Namespaces/namespacedakku/#using-vector3i","text":"using dakku :: Vector3i = typedef Vector < int , 3 > ; 3d int vector","title":"using Vector3i"},{"location":"Namespaces/namespacedakku/#using-vector3f","text":"using dakku :: Vector3f = typedef Vector < float , 3 > ; 3d float vector","title":"using Vector3f"},{"location":"Namespaces/namespacedakku/#using-point3f","text":"using dakku :: Point3f = typedef Point < float , 3 > ; 3d float point","title":"using Point3f"},{"location":"Namespaces/namespacedakku/#using-point3i","text":"using dakku :: Point3i = typedef Point < int , 3 > ; 3d int point","title":"using Point3i"},{"location":"Namespaces/namespacedakku/#using-point2f","text":"using dakku :: Point2f = typedef Point < float , 2 > ; 2d float point","title":"using Point2f"},{"location":"Namespaces/namespacedakku/#using-point2i","text":"using dakku :: Point2i = typedef Point < int , 2 > ; 2d int point","title":"using Point2i"},{"location":"Namespaces/namespacedakku/#using-normal3f","text":"using dakku :: Normal3f = typedef Normal < float , 3 > ; 3d float normal","title":"using Normal3f"},{"location":"Namespaces/namespacedakku/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Namespaces/namespacedakku/#function-begin","text":"inline Bounds2iIterator begin ( const Bounds2i & b ) begin of the bounds2i iteration","title":"function begin"},{"location":"Namespaces/namespacedakku/#function-end","text":"inline Bounds2iIterator end ( const Bounds2i & b ) end of the bounds2i iteration","title":"function end"},{"location":"Namespaces/namespacedakku/#function-dakku_declare_lua_object","text":"DAKKU_DECLARE_LUA_OBJECT ( Bounds , DAKKU_EXPORT_CORE )","title":"function DAKKU_DECLARE_LUA_OBJECT"},{"location":"Namespaces/namespacedakku/#function-isnan","text":"template < typename T > DAKKU_INLINE bool isnan ( T x ) check whether x is not a number Parameters : x given value Template Parameters : T type (floating point) Return : whether x is nan","title":"function isnan"},{"location":"Namespaces/namespacedakku/#function-isnan_1","text":"template < typename T > DAKKU_INLINE bool isnan ( T ) check whether x is not a number Template Parameters : T type (integer) Return : false (all integers are not nans)","title":"function isnan"},{"location":"Namespaces/namespacedakku/#function-dakku_declare_lua_object_1","text":"DAKKU_DECLARE_LUA_OBJECT ( Vector2i , DAKKU_EXPORT_CORE )","title":"function DAKKU_DECLARE_LUA_OBJECT"},{"location":"Namespaces/namespacedakku/#function-dakku_declare_lua_object_2","text":"DAKKU_DECLARE_LUA_OBJECT ( Vector2f , DAKKU_EXPORT_CORE )","title":"function DAKKU_DECLARE_LUA_OBJECT"},{"location":"Namespaces/namespacedakku/#function-dakku_declare_lua_object_3","text":"DAKKU_DECLARE_LUA_OBJECT ( Vector3i , DAKKU_EXPORT_CORE )","title":"function DAKKU_DECLARE_LUA_OBJECT"},{"location":"Namespaces/namespacedakku/#function-dakku_declare_lua_object_4","text":"DAKKU_DECLARE_LUA_OBJECT ( Vector3f , DAKKU_EXPORT_CORE )","title":"function DAKKU_DECLARE_LUA_OBJECT"},{"location":"Namespaces/namespacedakku/#function-dakku_declare_lua_object_5","text":"DAKKU_DECLARE_LUA_OBJECT ( Point3f , DAKKU_EXPORT_CORE )","title":"function DAKKU_DECLARE_LUA_OBJECT"},{"location":"Namespaces/namespacedakku/#function-dakku_declare_lua_object_6","text":"DAKKU_DECLARE_LUA_OBJECT ( Point3i , DAKKU_EXPORT_CORE )","title":"function DAKKU_DECLARE_LUA_OBJECT"},{"location":"Namespaces/namespacedakku/#function-dakku_declare_lua_object_7","text":"DAKKU_DECLARE_LUA_OBJECT ( Point2f , DAKKU_EXPORT_CORE )","title":"function DAKKU_DECLARE_LUA_OBJECT"},{"location":"Namespaces/namespacedakku/#function-dakku_declare_lua_object_8","text":"DAKKU_DECLARE_LUA_OBJECT ( Point2i , DAKKU_EXPORT_CORE )","title":"function DAKKU_DECLARE_LUA_OBJECT"},{"location":"Namespaces/namespacedakku/#function-dakku_declare_lua_object_9","text":"DAKKU_DECLARE_LUA_OBJECT ( Normal3f , DAKKU_EXPORT_CORE )","title":"function DAKKU_DECLARE_LUA_OBJECT"},{"location":"Namespaces/namespacedakku/#function-create_box_filter","text":"DAKKU_EXPORT_FILTERSFilter * create_box_filter ( float x_width , float y_width ) Create a box filter object.","title":"function create_box_filter"},{"location":"Namespaces/namespacedakku/#function-dakku_declare_lua_object_10","text":"DAKKU_DECLARE_LUA_OBJECT ( BoxFilter , DAKKU_EXPORT_FILTERS )","title":"function DAKKU_DECLARE_LUA_OBJECT"},{"location":"Namespaces/namespacedakku/#function-create_triangle_filter","text":"DAKKU_EXPORT_FILTERSFilter * create_triangle_filter ( float x_width , float y_width ) Create a triangle filter object.","title":"function create_triangle_filter"},{"location":"Namespaces/namespacedakku/#function-dakku_declare_lua_object_11","text":"DAKKU_DECLARE_LUA_OBJECT ( TriangleFilter , DAKKU_EXPORT_FILTERS )","title":"function DAKKU_DECLARE_LUA_OBJECT"},{"location":"Namespaces/namespacedakku/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"Namespaces/namespacedakku/#variable-inf","text":"static constexpr float INF = std :: numeric_limits < float >:: infinity (); infinity","title":"variable INF"},{"location":"Namespaces/namespacedakku/#variable-pi","text":"static constexpr float PI = std :: numbers :: pi_v < float > ; PI.","title":"variable PI"},{"location":"Namespaces/namespacedakku/#variable-inv_pi","text":"static constexpr float INV_PI = static_cast < float > ( 1.0 / std :: numbers :: pi_v < double > ); \\(\\frac 1 \\pi\\)","title":"variable INV_PI"},{"location":"Namespaces/namespacedakku/#variable-pi_over_2","text":"static constexpr float PI_OVER_2 = static_cast < float > ( std :: numbers :: pi_v < double > / 2.0 ); \\(\\frac \\pi 2\\)","title":"variable PI_OVER_2"},{"location":"Namespaces/namespacedakku/#variable-pi_over_4","text":"static constexpr float PI_OVER_4 = static_cast < float > ( std :: numbers :: pi_v < double > / 4.0 ); \\(\\frac \\pi 4\\)","title":"variable PI_OVER_4"},{"location":"Namespaces/namespacedakku/#variable-shadow_eps","text":"static constexpr float SHADOW_EPS = 1e-5f ; shadow epsilon, used for shadow ray, offset ray origin","title":"variable SHADOW_EPS"},{"location":"Namespaces/namespacedakku/#variable-one_minus_epsilon","text":"static constexpr float ONE_MINUS_EPSILON = 1 - std :: numeric_limits < float >:: epsilon (); 1 - eps Updated on 2022-04-30 at 15:46:11 +0000","title":"variable ONE_MINUS_EPSILON"},{"location":"Namespaces/namespacestd/","text":"std Updated on 2022-04-30 at 15:46:11 +0000","title":"std"},{"location":"Namespaces/namespacestd/#std","text":"Updated on 2022-04-30 at 15:46:11 +0000","title":"std"},{"location":"Pages/","text":"Pages page dakku documentation Updated on 2022-04-30 at 15:46:11 +0000","title":"Pages"},{"location":"Pages/#pages","text":"page dakku documentation Updated on 2022-04-30 at 15:46:11 +0000","title":"Pages"}]}