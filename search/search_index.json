{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"dakku documentation This is the documentation of dakku renderer. Updated on 2022-04-25 at 11:08:31 +0000","title":"dakku documentation"},{"location":"#dakku-documentation","text":"This is the documentation of dakku renderer. Updated on 2022-04-25 at 11:08:31 +0000","title":"dakku documentation"},{"location":"Classes/","text":"Classes namespace dakku dakku namespace class BoundsBase bounding box base class Logger logger class class Lua dakku lua state class Normal normal class Point point class Vector vector class VectorBase vector base Updated on 2022-04-25 at 11:08:31 +0000","title":"Classes"},{"location":"Classes/#classes","text":"namespace dakku dakku namespace class BoundsBase bounding box base class Logger logger class class Lua dakku lua state class Normal normal class Point point class Vector vector class VectorBase vector base Updated on 2022-04-25 at 11:08:31 +0000","title":"Classes"},{"location":"Classes/classdakku_1_1BoundsBase/","text":"dakku::BoundsBase bounding box base More... #include <bounds.h> Public Functions Name BoundsBase () =default default constructor Public Attributes Name Point < T, S > pMin left bottom corner of the bounds Point < T, S > pMax right top corner of the bounds Detailed Description template < ArithmeticType T , size_t S > class dakku :: BoundsBase ; bounding box base Template Parameters : T data type S dimension Public Functions Documentation function BoundsBase BoundsBase () = default default constructor Public Attributes Documentation variable pMin Point < T , S > pMin { std :: numeric_limits < T >:: max ()}; left bottom corner of the bounds variable pMax Point < T , S > pMax { std :: numeric_limits < T >:: lowest ()}; right top corner of the bounds Updated on 2022-04-25 at 11:08:30 +0000","title":"dakku::BoundsBase"},{"location":"Classes/classdakku_1_1BoundsBase/#dakkuboundsbase","text":"bounding box base More... #include <bounds.h>","title":"dakku::BoundsBase"},{"location":"Classes/classdakku_1_1BoundsBase/#public-functions","text":"Name BoundsBase () =default default constructor","title":"Public Functions"},{"location":"Classes/classdakku_1_1BoundsBase/#public-attributes","text":"Name Point < T, S > pMin left bottom corner of the bounds Point < T, S > pMax right top corner of the bounds","title":"Public Attributes"},{"location":"Classes/classdakku_1_1BoundsBase/#detailed-description","text":"template < ArithmeticType T , size_t S > class dakku :: BoundsBase ; bounding box base Template Parameters : T data type S dimension","title":"Detailed Description"},{"location":"Classes/classdakku_1_1BoundsBase/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Classes/classdakku_1_1BoundsBase/#function-boundsbase","text":"BoundsBase () = default default constructor","title":"function BoundsBase"},{"location":"Classes/classdakku_1_1BoundsBase/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"Classes/classdakku_1_1BoundsBase/#variable-pmin","text":"Point < T , S > pMin { std :: numeric_limits < T >:: max ()}; left bottom corner of the bounds","title":"variable pMin"},{"location":"Classes/classdakku_1_1BoundsBase/#variable-pmax","text":"Point < T , S > pMax { std :: numeric_limits < T >:: lowest ()}; right top corner of the bounds Updated on 2022-04-25 at 11:08:30 +0000","title":"variable pMax"},{"location":"Classes/classdakku_1_1Logger/","text":"dakku::Logger logger class #include <logger.h> Public Functions Name const Logger & get () get logger instance spdlog::logger * handle () const get raw spdlog::logger handle Public Functions Documentation function get static const Logger & get () get logger instance Return : the logger instance function handle inline spdlog :: logger * handle () const get raw spdlog::logger handle Return : the corresponding spdlog::logger Updated on 2022-04-25 at 11:08:30 +0000","title":"dakku::Logger"},{"location":"Classes/classdakku_1_1Logger/#dakkulogger","text":"logger class #include <logger.h>","title":"dakku::Logger"},{"location":"Classes/classdakku_1_1Logger/#public-functions","text":"Name const Logger & get () get logger instance spdlog::logger * handle () const get raw spdlog::logger handle","title":"Public Functions"},{"location":"Classes/classdakku_1_1Logger/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Classes/classdakku_1_1Logger/#function-get","text":"static const Logger & get () get logger instance Return : the logger instance","title":"function get"},{"location":"Classes/classdakku_1_1Logger/#function-handle","text":"inline spdlog :: logger * handle () const get raw spdlog::logger handle Return : the corresponding spdlog::logger Updated on 2022-04-25 at 11:08:30 +0000","title":"function handle"},{"location":"Classes/classdakku_1_1Lua/","text":"dakku::Lua dakku lua state #include <lua.h> Public Functions Name Lua & instance () get lua instance sol::state & get_state () get lua state Public Functions Documentation function instance static Lua & instance () get lua instance function get_state sol :: state & get_state () get lua state Updated on 2022-04-25 at 11:08:30 +0000","title":"dakku::Lua"},{"location":"Classes/classdakku_1_1Lua/#dakkulua","text":"dakku lua state #include <lua.h>","title":"dakku::Lua"},{"location":"Classes/classdakku_1_1Lua/#public-functions","text":"Name Lua & instance () get lua instance sol::state & get_state () get lua state","title":"Public Functions"},{"location":"Classes/classdakku_1_1Lua/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Classes/classdakku_1_1Lua/#function-instance","text":"static Lua & instance () get lua instance","title":"function instance"},{"location":"Classes/classdakku_1_1Lua/#function-get_state","text":"sol :: state & get_state () get lua state Updated on 2022-04-25 at 11:08:30 +0000","title":"function get_state"},{"location":"Classes/classdakku_1_1Normal/","text":"dakku::Normal normal More... #include <vector.h> Inherits from dakku::VectorBase< T, S, Normal< T, S > > Public Functions Name Normal operator- () const negation of the vector Normal operator- (const Normal & rhs) const subtraction template <ArithmeticType V> Normal operator- (V rhs) const subtraction Additional inherited members Public Functions inherited from dakku::VectorBase< T, S, Normal< T, S > > Name VectorBase () Construct a new Vector Base object all components initialized to zero. template <ArithmeticType Arg> VectorBase (Arg value) Construct a new Vector Base object all components initalized to value VectorBase (const sol::table & table) Construct a new Vector Base object all components initalized to table. template <ArithmeticType Other,typename OtherDerived > VectorBase (const VectorBase < Other, S, OtherDerived > & other) Construct a new Vector Base object with given values. VectorBase (const VectorBase & other) VectorBase ( VectorBase && other) VectorBase & operator= (const VectorBase & other) VectorBase & operator= ( VectorBase && other) const D & derived () const convert to derived type D & derived () convert to derived type template <ArithmeticType Arg> void set (Arg value) set all components to value template <ArithmeticType Arg> void set_by_index (size_t index, Arg value) set data[index] to value template <ArithmeticType... Args,size_t... Is> void set (std::index_sequence< Is... > , Args &&... args) set data to args template <ArithmeticType... Args> void set (Args &&... args) set data to args template <ArithmeticType Other,typename OtherDerived > void set (const VectorBase < Other, S, OtherDerived > & rhs) set data by rhs 's data const T & get (size_t i) const get i'th component size_t size () const size of the vector std::string to_string () const convert vector to string bool has_nans () const check whether there are nan components D clone () const get a copy const T & operator[] (size_t i) const get i'th value T & operator[] (size_t i) get i'th value D & operator+= (const D & rhs) addition template <ArithmeticType V> D & operator+= (V rhs) addition D operator+ (const D & rhs) const addition template <ArithmeticType V> D operator+ (V rhs) const addition D & operator-= (const D & rhs) subtraction template <ArithmeticType V> D & operator-= (V rhs) subtraction D & operator*= (const D & rhs) multiplication template <ArithmeticType V> D & operator*= (V rhs) multiplication D operator* (const D & rhs) const multiplication template <ArithmeticType V> D operator* (V rhs) const multiplication D & operator/= (const D & rhs) division template <ArithmeticType V> D & operator/= (V rhs) division D operator/ (const D & rhs) const division template <ArithmeticType U> D operator/ (U rhs) const division bool operator== (const VectorBase & rhs) const bool operator!= (const VectorBase & rhs) const decltype(auto) x () const get the first element decltype(auto) x () get the first element decltype(auto) y () const get the second element decltype(auto) y () get the second element decltype(auto) z () const get the third element decltype(auto) z () get the fourth element decltype(auto) w () const get the fourth element decltype(auto) w () get the third element size_t max_element_index () const get the index of the max element decltype(auto) max_element () const get the max element in the vector D max (const D & rhs) const element wise max D min (const D & rhs) const element wise min template <typename OtherDerived > decltype(auto) dot (const VectorBase < T, S, OtherDerived > & rhs) const dot product between two vectors decltype(auto) squaredNorm () const squared norm decltype(auto) norm () const norm decltype(auto) length () const length decltype(auto) distance (const D & rhs) const the distance D abs () const abs D cross (const D & rhs) const cross product bool is_zero () const check whether all components are zero D sqrt () const element-wise sqrt template <ArithmeticType E> D pow (E e) const element-wise power D exp () const element-wise exp D floor () const element-wise floor D ceil () const element-wise ceil D lerp (const D & b, T t) const element-wise linear interpolation operator std::span< T, S > () operator std::span< const T, S > () const Friends inherited from dakku::VectorBase< T, S, Normal< T, S > > Name D operator+ (U a, const D & b) addition D operator* (U a, const D & b) multiplication D operator/ (U a, const D & b) division std::ostream & operator<< (std::ostream & os, const VectorBase & vec) output the vector D max (const D & v1, const D & v2) element wise max D min (const D & v1, const D & v2) element wise min decltype(auto) distance (const D & a, const D & b) the distance D abs (const D & v) abs D sqrt (const D & v) element-wise sqrt D pow (const D & v, E e) element-wise power D exp (const D & v) element-wise exp D floor (const D & v) element-wise floor D ceil (const D & v) element-wise ceil D lerp (const D & a, const D & b, T t) element-wise linear interpolation Detailed Description template < typename T , size_t S > class dakku :: Normal ; normal Template Parameters : T type S size Public Functions Documentation function operator- inline Normal operator - () const negation of the vector Return : \\(-\\vec v\\) function operator- inline Normal operator - ( const Normal & rhs ) const subtraction function operator- template < ArithmeticType V > inline Normal operator - ( V rhs ) const subtraction Updated on 2022-04-25 at 11:08:30 +0000","title":"dakku::Normal"},{"location":"Classes/classdakku_1_1Normal/#dakkunormal","text":"normal More... #include <vector.h> Inherits from dakku::VectorBase< T, S, Normal< T, S > >","title":"dakku::Normal"},{"location":"Classes/classdakku_1_1Normal/#public-functions","text":"Name Normal operator- () const negation of the vector Normal operator- (const Normal & rhs) const subtraction template <ArithmeticType V> Normal operator- (V rhs) const subtraction","title":"Public Functions"},{"location":"Classes/classdakku_1_1Normal/#additional-inherited-members","text":"Public Functions inherited from dakku::VectorBase< T, S, Normal< T, S > > Name VectorBase () Construct a new Vector Base object all components initialized to zero. template <ArithmeticType Arg> VectorBase (Arg value) Construct a new Vector Base object all components initalized to value VectorBase (const sol::table & table) Construct a new Vector Base object all components initalized to table. template <ArithmeticType Other,typename OtherDerived > VectorBase (const VectorBase < Other, S, OtherDerived > & other) Construct a new Vector Base object with given values. VectorBase (const VectorBase & other) VectorBase ( VectorBase && other) VectorBase & operator= (const VectorBase & other) VectorBase & operator= ( VectorBase && other) const D & derived () const convert to derived type D & derived () convert to derived type template <ArithmeticType Arg> void set (Arg value) set all components to value template <ArithmeticType Arg> void set_by_index (size_t index, Arg value) set data[index] to value template <ArithmeticType... Args,size_t... Is> void set (std::index_sequence< Is... > , Args &&... args) set data to args template <ArithmeticType... Args> void set (Args &&... args) set data to args template <ArithmeticType Other,typename OtherDerived > void set (const VectorBase < Other, S, OtherDerived > & rhs) set data by rhs 's data const T & get (size_t i) const get i'th component size_t size () const size of the vector std::string to_string () const convert vector to string bool has_nans () const check whether there are nan components D clone () const get a copy const T & operator[] (size_t i) const get i'th value T & operator[] (size_t i) get i'th value D & operator+= (const D & rhs) addition template <ArithmeticType V> D & operator+= (V rhs) addition D operator+ (const D & rhs) const addition template <ArithmeticType V> D operator+ (V rhs) const addition D & operator-= (const D & rhs) subtraction template <ArithmeticType V> D & operator-= (V rhs) subtraction D & operator*= (const D & rhs) multiplication template <ArithmeticType V> D & operator*= (V rhs) multiplication D operator* (const D & rhs) const multiplication template <ArithmeticType V> D operator* (V rhs) const multiplication D & operator/= (const D & rhs) division template <ArithmeticType V> D & operator/= (V rhs) division D operator/ (const D & rhs) const division template <ArithmeticType U> D operator/ (U rhs) const division bool operator== (const VectorBase & rhs) const bool operator!= (const VectorBase & rhs) const decltype(auto) x () const get the first element decltype(auto) x () get the first element decltype(auto) y () const get the second element decltype(auto) y () get the second element decltype(auto) z () const get the third element decltype(auto) z () get the fourth element decltype(auto) w () const get the fourth element decltype(auto) w () get the third element size_t max_element_index () const get the index of the max element decltype(auto) max_element () const get the max element in the vector D max (const D & rhs) const element wise max D min (const D & rhs) const element wise min template <typename OtherDerived > decltype(auto) dot (const VectorBase < T, S, OtherDerived > & rhs) const dot product between two vectors decltype(auto) squaredNorm () const squared norm decltype(auto) norm () const norm decltype(auto) length () const length decltype(auto) distance (const D & rhs) const the distance D abs () const abs D cross (const D & rhs) const cross product bool is_zero () const check whether all components are zero D sqrt () const element-wise sqrt template <ArithmeticType E> D pow (E e) const element-wise power D exp () const element-wise exp D floor () const element-wise floor D ceil () const element-wise ceil D lerp (const D & b, T t) const element-wise linear interpolation operator std::span< T, S > () operator std::span< const T, S > () const Friends inherited from dakku::VectorBase< T, S, Normal< T, S > > Name D operator+ (U a, const D & b) addition D operator* (U a, const D & b) multiplication D operator/ (U a, const D & b) division std::ostream & operator<< (std::ostream & os, const VectorBase & vec) output the vector D max (const D & v1, const D & v2) element wise max D min (const D & v1, const D & v2) element wise min decltype(auto) distance (const D & a, const D & b) the distance D abs (const D & v) abs D sqrt (const D & v) element-wise sqrt D pow (const D & v, E e) element-wise power D exp (const D & v) element-wise exp D floor (const D & v) element-wise floor D ceil (const D & v) element-wise ceil D lerp (const D & a, const D & b, T t) element-wise linear interpolation","title":"Additional inherited members"},{"location":"Classes/classdakku_1_1Normal/#detailed-description","text":"template < typename T , size_t S > class dakku :: Normal ; normal Template Parameters : T type S size","title":"Detailed Description"},{"location":"Classes/classdakku_1_1Normal/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Classes/classdakku_1_1Normal/#function-operator-","text":"inline Normal operator - () const negation of the vector Return : \\(-\\vec v\\)","title":"function operator-"},{"location":"Classes/classdakku_1_1Normal/#function-operator-_1","text":"inline Normal operator - ( const Normal & rhs ) const subtraction","title":"function operator-"},{"location":"Classes/classdakku_1_1Normal/#function-operator-_2","text":"template < ArithmeticType V > inline Normal operator - ( V rhs ) const subtraction Updated on 2022-04-25 at 11:08:30 +0000","title":"function operator-"},{"location":"Classes/classdakku_1_1Point/","text":"dakku::Point point More... #include <vector.h> Inherits from dakku::VectorBase< T, S, Point< T, S > > Public Functions Name Point operator- () const negation of the point template <ArithmeticType V> Point operator- (V rhs) const subtraction Vector < T, S > operator- (const Point & rhs) const subtraction Point operator- (const Vector < T, S > & rhs) const subtraction Additional inherited members Public Functions inherited from dakku::VectorBase< T, S, Point< T, S > > Name VectorBase () Construct a new Vector Base object all components initialized to zero. template <ArithmeticType Arg> VectorBase (Arg value) Construct a new Vector Base object all components initalized to value VectorBase (const sol::table & table) Construct a new Vector Base object all components initalized to table. template <ArithmeticType Other,typename OtherDerived > VectorBase (const VectorBase < Other, S, OtherDerived > & other) Construct a new Vector Base object with given values. VectorBase (const VectorBase & other) VectorBase ( VectorBase && other) VectorBase & operator= (const VectorBase & other) VectorBase & operator= ( VectorBase && other) const D & derived () const convert to derived type D & derived () convert to derived type template <ArithmeticType Arg> void set (Arg value) set all components to value template <ArithmeticType Arg> void set_by_index (size_t index, Arg value) set data[index] to value template <ArithmeticType... Args,size_t... Is> void set (std::index_sequence< Is... > , Args &&... args) set data to args template <ArithmeticType... Args> void set (Args &&... args) set data to args template <ArithmeticType Other,typename OtherDerived > void set (const VectorBase < Other, S, OtherDerived > & rhs) set data by rhs 's data const T & get (size_t i) const get i'th component size_t size () const size of the vector std::string to_string () const convert vector to string bool has_nans () const check whether there are nan components D clone () const get a copy const T & operator[] (size_t i) const get i'th value T & operator[] (size_t i) get i'th value D & operator+= (const D & rhs) addition template <ArithmeticType V> D & operator+= (V rhs) addition D operator+ (const D & rhs) const addition template <ArithmeticType V> D operator+ (V rhs) const addition D & operator-= (const D & rhs) subtraction template <ArithmeticType V> D & operator-= (V rhs) subtraction D & operator*= (const D & rhs) multiplication template <ArithmeticType V> D & operator*= (V rhs) multiplication D operator* (const D & rhs) const multiplication template <ArithmeticType V> D operator* (V rhs) const multiplication D & operator/= (const D & rhs) division template <ArithmeticType V> D & operator/= (V rhs) division D operator/ (const D & rhs) const division template <ArithmeticType U> D operator/ (U rhs) const division bool operator== (const VectorBase & rhs) const bool operator!= (const VectorBase & rhs) const decltype(auto) x () const get the first element decltype(auto) x () get the first element decltype(auto) y () const get the second element decltype(auto) y () get the second element decltype(auto) z () const get the third element decltype(auto) z () get the fourth element decltype(auto) w () const get the fourth element decltype(auto) w () get the third element size_t max_element_index () const get the index of the max element decltype(auto) max_element () const get the max element in the vector D max (const D & rhs) const element wise max D min (const D & rhs) const element wise min template <typename OtherDerived > decltype(auto) dot (const VectorBase < T, S, OtherDerived > & rhs) const dot product between two vectors decltype(auto) squaredNorm () const squared norm decltype(auto) norm () const norm decltype(auto) length () const length decltype(auto) distance (const D & rhs) const the distance D abs () const abs D cross (const D & rhs) const cross product bool is_zero () const check whether all components are zero D sqrt () const element-wise sqrt template <ArithmeticType E> D pow (E e) const element-wise power D exp () const element-wise exp D floor () const element-wise floor D ceil () const element-wise ceil D lerp (const D & b, T t) const element-wise linear interpolation operator std::span< T, S > () operator std::span< const T, S > () const Friends inherited from dakku::VectorBase< T, S, Point< T, S > > Name D operator+ (U a, const D & b) addition D operator* (U a, const D & b) multiplication D operator/ (U a, const D & b) division std::ostream & operator<< (std::ostream & os, const VectorBase & vec) output the vector D max (const D & v1, const D & v2) element wise max D min (const D & v1, const D & v2) element wise min decltype(auto) distance (const D & a, const D & b) the distance D abs (const D & v) abs D sqrt (const D & v) element-wise sqrt D pow (const D & v, E e) element-wise power D exp (const D & v) element-wise exp D floor (const D & v) element-wise floor D ceil (const D & v) element-wise ceil D lerp (const D & a, const D & b, T t) element-wise linear interpolation Detailed Description template < typename T , size_t S > class dakku :: Point ; point Template Parameters : T type S size Public Functions Documentation function operator- inline Point operator - () const negation of the point Return : \\(-v\\) function operator- template < ArithmeticType V > inline Point operator - ( V rhs ) const subtraction function operator- inline Vector < T , S > operator - ( const Point & rhs ) const subtraction function operator- inline Point operator - ( const Vector < T , S > & rhs ) const subtraction Updated on 2022-04-25 at 11:08:30 +0000","title":"dakku::Point"},{"location":"Classes/classdakku_1_1Point/#dakkupoint","text":"point More... #include <vector.h> Inherits from dakku::VectorBase< T, S, Point< T, S > >","title":"dakku::Point"},{"location":"Classes/classdakku_1_1Point/#public-functions","text":"Name Point operator- () const negation of the point template <ArithmeticType V> Point operator- (V rhs) const subtraction Vector < T, S > operator- (const Point & rhs) const subtraction Point operator- (const Vector < T, S > & rhs) const subtraction","title":"Public Functions"},{"location":"Classes/classdakku_1_1Point/#additional-inherited-members","text":"Public Functions inherited from dakku::VectorBase< T, S, Point< T, S > > Name VectorBase () Construct a new Vector Base object all components initialized to zero. template <ArithmeticType Arg> VectorBase (Arg value) Construct a new Vector Base object all components initalized to value VectorBase (const sol::table & table) Construct a new Vector Base object all components initalized to table. template <ArithmeticType Other,typename OtherDerived > VectorBase (const VectorBase < Other, S, OtherDerived > & other) Construct a new Vector Base object with given values. VectorBase (const VectorBase & other) VectorBase ( VectorBase && other) VectorBase & operator= (const VectorBase & other) VectorBase & operator= ( VectorBase && other) const D & derived () const convert to derived type D & derived () convert to derived type template <ArithmeticType Arg> void set (Arg value) set all components to value template <ArithmeticType Arg> void set_by_index (size_t index, Arg value) set data[index] to value template <ArithmeticType... Args,size_t... Is> void set (std::index_sequence< Is... > , Args &&... args) set data to args template <ArithmeticType... Args> void set (Args &&... args) set data to args template <ArithmeticType Other,typename OtherDerived > void set (const VectorBase < Other, S, OtherDerived > & rhs) set data by rhs 's data const T & get (size_t i) const get i'th component size_t size () const size of the vector std::string to_string () const convert vector to string bool has_nans () const check whether there are nan components D clone () const get a copy const T & operator[] (size_t i) const get i'th value T & operator[] (size_t i) get i'th value D & operator+= (const D & rhs) addition template <ArithmeticType V> D & operator+= (V rhs) addition D operator+ (const D & rhs) const addition template <ArithmeticType V> D operator+ (V rhs) const addition D & operator-= (const D & rhs) subtraction template <ArithmeticType V> D & operator-= (V rhs) subtraction D & operator*= (const D & rhs) multiplication template <ArithmeticType V> D & operator*= (V rhs) multiplication D operator* (const D & rhs) const multiplication template <ArithmeticType V> D operator* (V rhs) const multiplication D & operator/= (const D & rhs) division template <ArithmeticType V> D & operator/= (V rhs) division D operator/ (const D & rhs) const division template <ArithmeticType U> D operator/ (U rhs) const division bool operator== (const VectorBase & rhs) const bool operator!= (const VectorBase & rhs) const decltype(auto) x () const get the first element decltype(auto) x () get the first element decltype(auto) y () const get the second element decltype(auto) y () get the second element decltype(auto) z () const get the third element decltype(auto) z () get the fourth element decltype(auto) w () const get the fourth element decltype(auto) w () get the third element size_t max_element_index () const get the index of the max element decltype(auto) max_element () const get the max element in the vector D max (const D & rhs) const element wise max D min (const D & rhs) const element wise min template <typename OtherDerived > decltype(auto) dot (const VectorBase < T, S, OtherDerived > & rhs) const dot product between two vectors decltype(auto) squaredNorm () const squared norm decltype(auto) norm () const norm decltype(auto) length () const length decltype(auto) distance (const D & rhs) const the distance D abs () const abs D cross (const D & rhs) const cross product bool is_zero () const check whether all components are zero D sqrt () const element-wise sqrt template <ArithmeticType E> D pow (E e) const element-wise power D exp () const element-wise exp D floor () const element-wise floor D ceil () const element-wise ceil D lerp (const D & b, T t) const element-wise linear interpolation operator std::span< T, S > () operator std::span< const T, S > () const Friends inherited from dakku::VectorBase< T, S, Point< T, S > > Name D operator+ (U a, const D & b) addition D operator* (U a, const D & b) multiplication D operator/ (U a, const D & b) division std::ostream & operator<< (std::ostream & os, const VectorBase & vec) output the vector D max (const D & v1, const D & v2) element wise max D min (const D & v1, const D & v2) element wise min decltype(auto) distance (const D & a, const D & b) the distance D abs (const D & v) abs D sqrt (const D & v) element-wise sqrt D pow (const D & v, E e) element-wise power D exp (const D & v) element-wise exp D floor (const D & v) element-wise floor D ceil (const D & v) element-wise ceil D lerp (const D & a, const D & b, T t) element-wise linear interpolation","title":"Additional inherited members"},{"location":"Classes/classdakku_1_1Point/#detailed-description","text":"template < typename T , size_t S > class dakku :: Point ; point Template Parameters : T type S size","title":"Detailed Description"},{"location":"Classes/classdakku_1_1Point/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Classes/classdakku_1_1Point/#function-operator-","text":"inline Point operator - () const negation of the point Return : \\(-v\\)","title":"function operator-"},{"location":"Classes/classdakku_1_1Point/#function-operator-_1","text":"template < ArithmeticType V > inline Point operator - ( V rhs ) const subtraction","title":"function operator-"},{"location":"Classes/classdakku_1_1Point/#function-operator-_2","text":"inline Vector < T , S > operator - ( const Point & rhs ) const subtraction","title":"function operator-"},{"location":"Classes/classdakku_1_1Point/#function-operator-_3","text":"inline Point operator - ( const Vector < T , S > & rhs ) const subtraction Updated on 2022-04-25 at 11:08:30 +0000","title":"function operator-"},{"location":"Classes/classdakku_1_1Vector/","text":"dakku::Vector vector More... #include <vector.h> Inherits from dakku::VectorBase< T, S, Vector< T, S > > Public Functions Name Vector operator- () const negation of the vector Vector operator- (const Vector & rhs) const subtraction template <ArithmeticType V> Vector operator- (V rhs) const subtraction Additional inherited members Public Functions inherited from dakku::VectorBase< T, S, Vector< T, S > > Name VectorBase () Construct a new Vector Base object all components initialized to zero. template <ArithmeticType Arg> VectorBase (Arg value) Construct a new Vector Base object all components initalized to value VectorBase (const sol::table & table) Construct a new Vector Base object all components initalized to table. template <ArithmeticType Other,typename OtherDerived > VectorBase (const VectorBase < Other, S, OtherDerived > & other) Construct a new Vector Base object with given values. VectorBase (const VectorBase & other) VectorBase ( VectorBase && other) VectorBase & operator= (const VectorBase & other) VectorBase & operator= ( VectorBase && other) const D & derived () const convert to derived type D & derived () convert to derived type template <ArithmeticType Arg> void set (Arg value) set all components to value template <ArithmeticType Arg> void set_by_index (size_t index, Arg value) set data[index] to value template <ArithmeticType... Args,size_t... Is> void set (std::index_sequence< Is... > , Args &&... args) set data to args template <ArithmeticType... Args> void set (Args &&... args) set data to args template <ArithmeticType Other,typename OtherDerived > void set (const VectorBase < Other, S, OtherDerived > & rhs) set data by rhs 's data const T & get (size_t i) const get i'th component size_t size () const size of the vector std::string to_string () const convert vector to string bool has_nans () const check whether there are nan components D clone () const get a copy const T & operator[] (size_t i) const get i'th value T & operator[] (size_t i) get i'th value D & operator+= (const D & rhs) addition template <ArithmeticType V> D & operator+= (V rhs) addition D operator+ (const D & rhs) const addition template <ArithmeticType V> D operator+ (V rhs) const addition D & operator-= (const D & rhs) subtraction template <ArithmeticType V> D & operator-= (V rhs) subtraction D & operator*= (const D & rhs) multiplication template <ArithmeticType V> D & operator*= (V rhs) multiplication D operator* (const D & rhs) const multiplication template <ArithmeticType V> D operator* (V rhs) const multiplication D & operator/= (const D & rhs) division template <ArithmeticType V> D & operator/= (V rhs) division D operator/ (const D & rhs) const division template <ArithmeticType U> D operator/ (U rhs) const division bool operator== (const VectorBase & rhs) const bool operator!= (const VectorBase & rhs) const decltype(auto) x () const get the first element decltype(auto) x () get the first element decltype(auto) y () const get the second element decltype(auto) y () get the second element decltype(auto) z () const get the third element decltype(auto) z () get the fourth element decltype(auto) w () const get the fourth element decltype(auto) w () get the third element size_t max_element_index () const get the index of the max element decltype(auto) max_element () const get the max element in the vector D max (const D & rhs) const element wise max D min (const D & rhs) const element wise min template <typename OtherDerived > decltype(auto) dot (const VectorBase < T, S, OtherDerived > & rhs) const dot product between two vectors decltype(auto) squaredNorm () const squared norm decltype(auto) norm () const norm decltype(auto) length () const length decltype(auto) distance (const D & rhs) const the distance D abs () const abs D cross (const D & rhs) const cross product bool is_zero () const check whether all components are zero D sqrt () const element-wise sqrt template <ArithmeticType E> D pow (E e) const element-wise power D exp () const element-wise exp D floor () const element-wise floor D ceil () const element-wise ceil D lerp (const D & b, T t) const element-wise linear interpolation operator std::span< T, S > () operator std::span< const T, S > () const Friends inherited from dakku::VectorBase< T, S, Vector< T, S > > Name D operator+ (U a, const D & b) addition D operator* (U a, const D & b) multiplication D operator/ (U a, const D & b) division std::ostream & operator<< (std::ostream & os, const VectorBase & vec) output the vector D max (const D & v1, const D & v2) element wise max D min (const D & v1, const D & v2) element wise min decltype(auto) distance (const D & a, const D & b) the distance D abs (const D & v) abs D sqrt (const D & v) element-wise sqrt D pow (const D & v, E e) element-wise power D exp (const D & v) element-wise exp D floor (const D & v) element-wise floor D ceil (const D & v) element-wise ceil D lerp (const D & a, const D & b, T t) element-wise linear interpolation Detailed Description template < typename T , size_t S > class dakku :: Vector ; vector Template Parameters : T type S size Public Functions Documentation function operator- inline Vector operator - () const negation of the vector Return : \\(-\\vec v\\) function operator- inline Vector operator - ( const Vector & rhs ) const subtraction function operator- template < ArithmeticType V > inline Vector operator - ( V rhs ) const subtraction Updated on 2022-04-25 at 11:08:30 +0000","title":"dakku::Vector"},{"location":"Classes/classdakku_1_1Vector/#dakkuvector","text":"vector More... #include <vector.h> Inherits from dakku::VectorBase< T, S, Vector< T, S > >","title":"dakku::Vector"},{"location":"Classes/classdakku_1_1Vector/#public-functions","text":"Name Vector operator- () const negation of the vector Vector operator- (const Vector & rhs) const subtraction template <ArithmeticType V> Vector operator- (V rhs) const subtraction","title":"Public Functions"},{"location":"Classes/classdakku_1_1Vector/#additional-inherited-members","text":"Public Functions inherited from dakku::VectorBase< T, S, Vector< T, S > > Name VectorBase () Construct a new Vector Base object all components initialized to zero. template <ArithmeticType Arg> VectorBase (Arg value) Construct a new Vector Base object all components initalized to value VectorBase (const sol::table & table) Construct a new Vector Base object all components initalized to table. template <ArithmeticType Other,typename OtherDerived > VectorBase (const VectorBase < Other, S, OtherDerived > & other) Construct a new Vector Base object with given values. VectorBase (const VectorBase & other) VectorBase ( VectorBase && other) VectorBase & operator= (const VectorBase & other) VectorBase & operator= ( VectorBase && other) const D & derived () const convert to derived type D & derived () convert to derived type template <ArithmeticType Arg> void set (Arg value) set all components to value template <ArithmeticType Arg> void set_by_index (size_t index, Arg value) set data[index] to value template <ArithmeticType... Args,size_t... Is> void set (std::index_sequence< Is... > , Args &&... args) set data to args template <ArithmeticType... Args> void set (Args &&... args) set data to args template <ArithmeticType Other,typename OtherDerived > void set (const VectorBase < Other, S, OtherDerived > & rhs) set data by rhs 's data const T & get (size_t i) const get i'th component size_t size () const size of the vector std::string to_string () const convert vector to string bool has_nans () const check whether there are nan components D clone () const get a copy const T & operator[] (size_t i) const get i'th value T & operator[] (size_t i) get i'th value D & operator+= (const D & rhs) addition template <ArithmeticType V> D & operator+= (V rhs) addition D operator+ (const D & rhs) const addition template <ArithmeticType V> D operator+ (V rhs) const addition D & operator-= (const D & rhs) subtraction template <ArithmeticType V> D & operator-= (V rhs) subtraction D & operator*= (const D & rhs) multiplication template <ArithmeticType V> D & operator*= (V rhs) multiplication D operator* (const D & rhs) const multiplication template <ArithmeticType V> D operator* (V rhs) const multiplication D & operator/= (const D & rhs) division template <ArithmeticType V> D & operator/= (V rhs) division D operator/ (const D & rhs) const division template <ArithmeticType U> D operator/ (U rhs) const division bool operator== (const VectorBase & rhs) const bool operator!= (const VectorBase & rhs) const decltype(auto) x () const get the first element decltype(auto) x () get the first element decltype(auto) y () const get the second element decltype(auto) y () get the second element decltype(auto) z () const get the third element decltype(auto) z () get the fourth element decltype(auto) w () const get the fourth element decltype(auto) w () get the third element size_t max_element_index () const get the index of the max element decltype(auto) max_element () const get the max element in the vector D max (const D & rhs) const element wise max D min (const D & rhs) const element wise min template <typename OtherDerived > decltype(auto) dot (const VectorBase < T, S, OtherDerived > & rhs) const dot product between two vectors decltype(auto) squaredNorm () const squared norm decltype(auto) norm () const norm decltype(auto) length () const length decltype(auto) distance (const D & rhs) const the distance D abs () const abs D cross (const D & rhs) const cross product bool is_zero () const check whether all components are zero D sqrt () const element-wise sqrt template <ArithmeticType E> D pow (E e) const element-wise power D exp () const element-wise exp D floor () const element-wise floor D ceil () const element-wise ceil D lerp (const D & b, T t) const element-wise linear interpolation operator std::span< T, S > () operator std::span< const T, S > () const Friends inherited from dakku::VectorBase< T, S, Vector< T, S > > Name D operator+ (U a, const D & b) addition D operator* (U a, const D & b) multiplication D operator/ (U a, const D & b) division std::ostream & operator<< (std::ostream & os, const VectorBase & vec) output the vector D max (const D & v1, const D & v2) element wise max D min (const D & v1, const D & v2) element wise min decltype(auto) distance (const D & a, const D & b) the distance D abs (const D & v) abs D sqrt (const D & v) element-wise sqrt D pow (const D & v, E e) element-wise power D exp (const D & v) element-wise exp D floor (const D & v) element-wise floor D ceil (const D & v) element-wise ceil D lerp (const D & a, const D & b, T t) element-wise linear interpolation","title":"Additional inherited members"},{"location":"Classes/classdakku_1_1Vector/#detailed-description","text":"template < typename T , size_t S > class dakku :: Vector ; vector Template Parameters : T type S size","title":"Detailed Description"},{"location":"Classes/classdakku_1_1Vector/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Classes/classdakku_1_1Vector/#function-operator-","text":"inline Vector operator - () const negation of the vector Return : \\(-\\vec v\\)","title":"function operator-"},{"location":"Classes/classdakku_1_1Vector/#function-operator-_1","text":"inline Vector operator - ( const Vector & rhs ) const subtraction","title":"function operator-"},{"location":"Classes/classdakku_1_1Vector/#function-operator-_2","text":"template < ArithmeticType V > inline Vector operator - ( V rhs ) const subtraction Updated on 2022-04-25 at 11:08:30 +0000","title":"function operator-"},{"location":"Classes/classdakku_1_1VectorBase/","text":"dakku::VectorBase vector base More... #include <vector_base.h> Public Functions Name VectorBase () Construct a new Vector Base object all components initialized to zero. template <ArithmeticType Arg> VectorBase (Arg value) Construct a new Vector Base object all components initalized to value VectorBase (const sol::table & table) Construct a new Vector Base object all components initalized to table. template <ArithmeticType Other,typename OtherDerived > VectorBase (const VectorBase < Other, S, OtherDerived > & other) Construct a new Vector Base object with given values. VectorBase (const VectorBase & other) VectorBase ( VectorBase && other) VectorBase & operator= (const VectorBase & other) VectorBase & operator= ( VectorBase && other) const D & derived () const convert to derived type D & derived () convert to derived type template <ArithmeticType Arg> void set (Arg value) set all components to value template <ArithmeticType Arg> void set_by_index (size_t index, Arg value) set data[index] to value template <ArithmeticType... Args,size_t... Is> void set (std::index_sequence< Is... > , Args &&... args) set data to args template <ArithmeticType... Args> void set (Args &&... args) set data to args template <ArithmeticType Other,typename OtherDerived > void set (const VectorBase < Other, S, OtherDerived > & rhs) set data by rhs 's data const T & get (size_t i) const get i'th component size_t size () const size of the vector std::string to_string () const convert vector to string bool has_nans () const check whether there are nan components D clone () const get a copy const T & operator[] (size_t i) const get i'th value T & operator[] (size_t i) get i'th value D & operator+= (const D & rhs) addition template <ArithmeticType V> D & operator+= (V rhs) addition D operator+ (const D & rhs) const addition template <ArithmeticType V> D operator+ (V rhs) const addition D & operator-= (const D & rhs) subtraction template <ArithmeticType V> D & operator-= (V rhs) subtraction D & operator*= (const D & rhs) multiplication template <ArithmeticType V> D & operator*= (V rhs) multiplication D operator* (const D & rhs) const multiplication template <ArithmeticType V> D operator* (V rhs) const multiplication D & operator/= (const D & rhs) division template <ArithmeticType V> D & operator/= (V rhs) division D operator/ (const D & rhs) const division template <ArithmeticType U> D operator/ (U rhs) const division bool operator== (const VectorBase & rhs) const bool operator!= (const VectorBase & rhs) const decltype(auto) x () const get the first element decltype(auto) x () get the first element decltype(auto) y () const get the second element decltype(auto) y () get the second element decltype(auto) z () const get the third element decltype(auto) z () get the fourth element decltype(auto) w () const get the fourth element decltype(auto) w () get the third element size_t max_element_index () const get the index of the max element decltype(auto) max_element () const get the max element in the vector D max (const D & rhs) const element wise max D min (const D & rhs) const element wise min template <typename OtherDerived > decltype(auto) dot (const VectorBase < T, S, OtherDerived > & rhs) const dot product between two vectors decltype(auto) squaredNorm () const squared norm decltype(auto) norm () const norm decltype(auto) length () const length decltype(auto) distance (const D & rhs) const the distance D abs () const abs D cross (const D & rhs) const cross product bool is_zero () const check whether all components are zero D sqrt () const element-wise sqrt template <ArithmeticType E> D pow (E e) const element-wise power D exp () const element-wise exp D floor () const element-wise floor D ceil () const element-wise ceil D lerp (const D & b, T t) const element-wise linear interpolation operator std::span< T, S > () operator std::span< const T, S > () const Friends Name D operator+ (U a, const D & b) addition D operator- (U a, const D & b) subtraction D operator* (U a, const D & b) multiplication D operator/ (U a, const D & b) division std::ostream & operator<< (std::ostream & os, const VectorBase & vec) output the vector D max (const D & v1, const D & v2) element wise max D min (const D & v1, const D & v2) element wise min decltype(auto) distance (const D & a, const D & b) the distance D abs (const D & v) abs D sqrt (const D & v) element-wise sqrt D pow (const D & v, E e) element-wise power D exp (const D & v) element-wise exp D floor (const D & v) element-wise floor D ceil (const D & v) element-wise ceil D lerp (const D & a, const D & b, T t) element-wise linear interpolation Detailed Description template < ArithmeticType T , size_t S , typename D > class dakku :: VectorBase ; vector base Template Parameters : T type S size D derived Public Functions Documentation function VectorBase inline VectorBase () Construct a new Vector Base object all components initialized to zero. function VectorBase template < ArithmeticType Arg > inline VectorBase ( Arg value ) Construct a new Vector Base object all components initalized to value Parameters : value init value Template Parameters : Arg value type function VectorBase inline VectorBase ( const sol :: table & table ) Construct a new Vector Base object all components initalized to table. function VectorBase template < ArithmeticType Other , typename OtherDerived > inline explicit VectorBase ( const VectorBase < Other , S , OtherDerived > & other ) Construct a new Vector Base object with given values. Parameters : args init values expr the given expression Template Parameters : Args value types Other OtherDerived Expr Construct a new Vector Base object with a vector expression function VectorBase inline VectorBase ( const VectorBase & other ) function VectorBase inline VectorBase ( VectorBase && other ) function operator= inline VectorBase & operator = ( const VectorBase & other ) function operator= inline VectorBase & operator = ( VectorBase && other ) function derived inline const D & derived () const convert to derived type function derived inline D & derived () convert to derived type function set template < ArithmeticType Arg > inline void set ( Arg value ) set all components to value Parameters : value the given value Template Parameters : Arg value type function set_by_index template < ArithmeticType Arg > inline void set_by_index ( size_t index , Arg value ) set data[index] to value Parameters : index the index of the component value the given value Template Parameters : Arg value type function set template < ArithmeticType ... Args , size_t ... Is > inline void set ( std :: index_sequence < Is ... > , Args && ... args ) set data to args Parameters : args values Template Parameters : Args value types Is indices (generated by std::index_sequence_for) function set template < ArithmeticType ... Args > inline void set ( Args && ... args ) set data to args Parameters : args values Template Parameters : Args value types function set template < ArithmeticType Other , typename OtherDerived > inline void set ( const VectorBase < Other , S , OtherDerived > & rhs ) set data by rhs 's data Parameters : rhs the given vector Template Parameters : Other rhs type OtherDerived rhs derived type function get inline const T & get ( size_t i ) const get i'th component Parameters : i the index Return : the value function size inline size_t size () const size of the vector Return : size function to_string inline std :: string to_string () const convert vector to string Return : the converted string function has_nans inline bool has_nans () const check whether there are nan components Return : true vector contains nan false vector does not contain nans function clone inline D clone () const get a copy function operator[] inline const T & operator []( size_t i ) const get i'th value Parameters : i index Return : value function operator[] inline T & operator []( size_t i ) get i'th value Parameters : i index Return : value function operator+= inline D & operator += ( const D & rhs ) addition Parameters : rhs another vector Return : this function operator+= template < ArithmeticType V > inline D & operator += ( V rhs ) addition Parameters : rhs scalar Return : this function operator+ inline D operator + ( const D & rhs ) const addition Parameters : rhs another vector Return : result function operator+ template < ArithmeticType V > inline D operator + ( V rhs ) const addition Parameters : rhs another vector Return : result function operator-= inline D & operator -= ( const D & rhs ) subtraction Parameters : rhs another vector Return : this function operator-= template < ArithmeticType V > inline D & operator -= ( V rhs ) subtraction Parameters : rhs scalar Return : this function operator*= inline D & operator *= ( const D & rhs ) multiplication Parameters : rhs another vector Return : this function operator*= template < ArithmeticType V > inline D & operator *= ( V rhs ) multiplication Parameters : rhs scalar Return : this function operator* inline D operator * ( const D & rhs ) const multiplication Parameters : rhs another vector Return : result function operator* template < ArithmeticType V > inline D operator * ( V rhs ) const multiplication Parameters : rhs scalar Return : result function operator/= inline D & operator /= ( const D & rhs ) division Parameters : rhs another vector Return : this function operator/= template < ArithmeticType V > inline D & operator /= ( V rhs ) division Parameters : rhs scalar Return : this function operator/ inline D operator / ( const D & rhs ) const division Parameters : rhs another vector Return : result function operator/ template < ArithmeticType U > inline D operator / ( U rhs ) const division Parameters : rhs scalar Return : result function operator== inline bool operator == ( const VectorBase & rhs ) const function operator!= inline bool operator != ( const VectorBase & rhs ) const function x inline decltype ( auto ) x () const get the first element function x inline decltype ( auto ) x () get the first element function y inline decltype ( auto ) y () const get the second element function y inline decltype ( auto ) y () get the second element function z inline decltype ( auto ) z () const get the third element function z inline decltype ( auto ) z () get the fourth element function w inline decltype ( auto ) w () const get the fourth element function w inline decltype ( auto ) w () get the third element function max_element_index inline size_t max_element_index () const get the index of the max element Return : the index function max_element inline decltype ( auto ) max_element () const get the max element in the vector Return : the max value function max inline D max ( const D & rhs ) const element wise max function min inline D min ( const D & rhs ) const element wise min function dot template < typename OtherDerived > inline decltype ( auto ) dot ( const VectorBase < T , S , OtherDerived > & rhs ) const dot product between two vectors Return : \\(\\vec a \\cdot \\vec b\\) function squaredNorm inline decltype ( auto ) squaredNorm () const squared norm Return : \\(||v|| ^ 2\\) function norm inline decltype ( auto ) norm () const norm Return : \\(||v||\\) function length inline decltype ( auto ) length () const length Return : \\(||v||\\) function distance inline decltype ( auto ) distance ( const D & rhs ) const the distance function abs inline D abs () const abs function cross inline D cross ( const D & rhs ) const cross product function is_zero inline bool is_zero () const check whether all components are zero function sqrt inline D sqrt () const element-wise sqrt function pow template < ArithmeticType E > inline D pow ( E e ) const element-wise power function exp inline D exp () const element-wise exp function floor inline D floor () const element-wise floor function ceil inline D ceil () const element-wise ceil function lerp inline D lerp ( const D & b , T t ) const element-wise linear interpolation function operator std::span< T, S > inline operator std :: span < T , S > () function operator std::span< const T, S > inline operator std :: span < const T , S > () const Friends friend operator+ friend D operator + ( U a , const D & b ); addition Parameters : a \\(aa\\) b \\(\\vec b\\) Return : elementwise add a friend operator- friend D operator - ( U a , const D & b ); subtraction Parameters : a \\(aa\\) b \\(\\vec b\\) Return : elementwise sub friend operator* friend D operator * ( U a , const D & b ); multiplication Parameters : a \\(aa\\) b \\(\\vec b\\) Return : elementwise mul friend operator/ friend D operator / ( U a , const D & b ); division Parameters : a \\(aa\\) b \\(\\vec b\\) Return : elementwise div (broad cast \\(a\\) ) friend operator<< friend std :: ostream & operator << ( std :: ostream & os , const VectorBase & vec ); output the vector Parameters : os ostream vec the vector to output Return : ostream friend max friend D max ( const D & v1 , const D & v2 ); element wise max friend min friend D min ( const D & v1 , const D & v2 ); element wise min friend distance friend decltype ( auto ) distance ( const D & a , const D & b ); the distance friend abs friend D abs ( const D & v ); abs friend sqrt friend D sqrt ( const D & v ); element-wise sqrt friend pow friend D pow ( const D & v , E e ); element-wise power friend exp friend D exp ( const D & v ); element-wise exp friend floor friend D floor ( const D & v ); element-wise floor friend ceil friend D ceil ( const D & v ); element-wise ceil friend lerp friend D lerp ( const D & a , const D & b , T t ); element-wise linear interpolation Updated on 2022-04-25 at 11:08:30 +0000","title":"dakku::VectorBase"},{"location":"Classes/classdakku_1_1VectorBase/#dakkuvectorbase","text":"vector base More... #include <vector_base.h>","title":"dakku::VectorBase"},{"location":"Classes/classdakku_1_1VectorBase/#public-functions","text":"Name VectorBase () Construct a new Vector Base object all components initialized to zero. template <ArithmeticType Arg> VectorBase (Arg value) Construct a new Vector Base object all components initalized to value VectorBase (const sol::table & table) Construct a new Vector Base object all components initalized to table. template <ArithmeticType Other,typename OtherDerived > VectorBase (const VectorBase < Other, S, OtherDerived > & other) Construct a new Vector Base object with given values. VectorBase (const VectorBase & other) VectorBase ( VectorBase && other) VectorBase & operator= (const VectorBase & other) VectorBase & operator= ( VectorBase && other) const D & derived () const convert to derived type D & derived () convert to derived type template <ArithmeticType Arg> void set (Arg value) set all components to value template <ArithmeticType Arg> void set_by_index (size_t index, Arg value) set data[index] to value template <ArithmeticType... Args,size_t... Is> void set (std::index_sequence< Is... > , Args &&... args) set data to args template <ArithmeticType... Args> void set (Args &&... args) set data to args template <ArithmeticType Other,typename OtherDerived > void set (const VectorBase < Other, S, OtherDerived > & rhs) set data by rhs 's data const T & get (size_t i) const get i'th component size_t size () const size of the vector std::string to_string () const convert vector to string bool has_nans () const check whether there are nan components D clone () const get a copy const T & operator[] (size_t i) const get i'th value T & operator[] (size_t i) get i'th value D & operator+= (const D & rhs) addition template <ArithmeticType V> D & operator+= (V rhs) addition D operator+ (const D & rhs) const addition template <ArithmeticType V> D operator+ (V rhs) const addition D & operator-= (const D & rhs) subtraction template <ArithmeticType V> D & operator-= (V rhs) subtraction D & operator*= (const D & rhs) multiplication template <ArithmeticType V> D & operator*= (V rhs) multiplication D operator* (const D & rhs) const multiplication template <ArithmeticType V> D operator* (V rhs) const multiplication D & operator/= (const D & rhs) division template <ArithmeticType V> D & operator/= (V rhs) division D operator/ (const D & rhs) const division template <ArithmeticType U> D operator/ (U rhs) const division bool operator== (const VectorBase & rhs) const bool operator!= (const VectorBase & rhs) const decltype(auto) x () const get the first element decltype(auto) x () get the first element decltype(auto) y () const get the second element decltype(auto) y () get the second element decltype(auto) z () const get the third element decltype(auto) z () get the fourth element decltype(auto) w () const get the fourth element decltype(auto) w () get the third element size_t max_element_index () const get the index of the max element decltype(auto) max_element () const get the max element in the vector D max (const D & rhs) const element wise max D min (const D & rhs) const element wise min template <typename OtherDerived > decltype(auto) dot (const VectorBase < T, S, OtherDerived > & rhs) const dot product between two vectors decltype(auto) squaredNorm () const squared norm decltype(auto) norm () const norm decltype(auto) length () const length decltype(auto) distance (const D & rhs) const the distance D abs () const abs D cross (const D & rhs) const cross product bool is_zero () const check whether all components are zero D sqrt () const element-wise sqrt template <ArithmeticType E> D pow (E e) const element-wise power D exp () const element-wise exp D floor () const element-wise floor D ceil () const element-wise ceil D lerp (const D & b, T t) const element-wise linear interpolation operator std::span< T, S > () operator std::span< const T, S > () const","title":"Public Functions"},{"location":"Classes/classdakku_1_1VectorBase/#friends","text":"Name D operator+ (U a, const D & b) addition D operator- (U a, const D & b) subtraction D operator* (U a, const D & b) multiplication D operator/ (U a, const D & b) division std::ostream & operator<< (std::ostream & os, const VectorBase & vec) output the vector D max (const D & v1, const D & v2) element wise max D min (const D & v1, const D & v2) element wise min decltype(auto) distance (const D & a, const D & b) the distance D abs (const D & v) abs D sqrt (const D & v) element-wise sqrt D pow (const D & v, E e) element-wise power D exp (const D & v) element-wise exp D floor (const D & v) element-wise floor D ceil (const D & v) element-wise ceil D lerp (const D & a, const D & b, T t) element-wise linear interpolation","title":"Friends"},{"location":"Classes/classdakku_1_1VectorBase/#detailed-description","text":"template < ArithmeticType T , size_t S , typename D > class dakku :: VectorBase ; vector base Template Parameters : T type S size D derived","title":"Detailed Description"},{"location":"Classes/classdakku_1_1VectorBase/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Classes/classdakku_1_1VectorBase/#function-vectorbase","text":"inline VectorBase () Construct a new Vector Base object all components initialized to zero.","title":"function VectorBase"},{"location":"Classes/classdakku_1_1VectorBase/#function-vectorbase_1","text":"template < ArithmeticType Arg > inline VectorBase ( Arg value ) Construct a new Vector Base object all components initalized to value Parameters : value init value Template Parameters : Arg value type","title":"function VectorBase"},{"location":"Classes/classdakku_1_1VectorBase/#function-vectorbase_2","text":"inline VectorBase ( const sol :: table & table ) Construct a new Vector Base object all components initalized to table.","title":"function VectorBase"},{"location":"Classes/classdakku_1_1VectorBase/#function-vectorbase_3","text":"template < ArithmeticType Other , typename OtherDerived > inline explicit VectorBase ( const VectorBase < Other , S , OtherDerived > & other ) Construct a new Vector Base object with given values. Parameters : args init values expr the given expression Template Parameters : Args value types Other OtherDerived Expr Construct a new Vector Base object with a vector expression","title":"function VectorBase"},{"location":"Classes/classdakku_1_1VectorBase/#function-vectorbase_4","text":"inline VectorBase ( const VectorBase & other )","title":"function VectorBase"},{"location":"Classes/classdakku_1_1VectorBase/#function-vectorbase_5","text":"inline VectorBase ( VectorBase && other )","title":"function VectorBase"},{"location":"Classes/classdakku_1_1VectorBase/#function-operator","text":"inline VectorBase & operator = ( const VectorBase & other )","title":"function operator="},{"location":"Classes/classdakku_1_1VectorBase/#function-operator_1","text":"inline VectorBase & operator = ( VectorBase && other )","title":"function operator="},{"location":"Classes/classdakku_1_1VectorBase/#function-derived","text":"inline const D & derived () const convert to derived type","title":"function derived"},{"location":"Classes/classdakku_1_1VectorBase/#function-derived_1","text":"inline D & derived () convert to derived type","title":"function derived"},{"location":"Classes/classdakku_1_1VectorBase/#function-set","text":"template < ArithmeticType Arg > inline void set ( Arg value ) set all components to value Parameters : value the given value Template Parameters : Arg value type","title":"function set"},{"location":"Classes/classdakku_1_1VectorBase/#function-set_by_index","text":"template < ArithmeticType Arg > inline void set_by_index ( size_t index , Arg value ) set data[index] to value Parameters : index the index of the component value the given value Template Parameters : Arg value type","title":"function set_by_index"},{"location":"Classes/classdakku_1_1VectorBase/#function-set_1","text":"template < ArithmeticType ... Args , size_t ... Is > inline void set ( std :: index_sequence < Is ... > , Args && ... args ) set data to args Parameters : args values Template Parameters : Args value types Is indices (generated by std::index_sequence_for)","title":"function set"},{"location":"Classes/classdakku_1_1VectorBase/#function-set_2","text":"template < ArithmeticType ... Args > inline void set ( Args && ... args ) set data to args Parameters : args values Template Parameters : Args value types","title":"function set"},{"location":"Classes/classdakku_1_1VectorBase/#function-set_3","text":"template < ArithmeticType Other , typename OtherDerived > inline void set ( const VectorBase < Other , S , OtherDerived > & rhs ) set data by rhs 's data Parameters : rhs the given vector Template Parameters : Other rhs type OtherDerived rhs derived type","title":"function set"},{"location":"Classes/classdakku_1_1VectorBase/#function-get","text":"inline const T & get ( size_t i ) const get i'th component Parameters : i the index Return : the value","title":"function get"},{"location":"Classes/classdakku_1_1VectorBase/#function-size","text":"inline size_t size () const size of the vector Return : size","title":"function size"},{"location":"Classes/classdakku_1_1VectorBase/#function-to_string","text":"inline std :: string to_string () const convert vector to string Return : the converted string","title":"function to_string"},{"location":"Classes/classdakku_1_1VectorBase/#function-has_nans","text":"inline bool has_nans () const check whether there are nan components Return : true vector contains nan false vector does not contain nans","title":"function has_nans"},{"location":"Classes/classdakku_1_1VectorBase/#function-clone","text":"inline D clone () const get a copy","title":"function clone"},{"location":"Classes/classdakku_1_1VectorBase/#function-operator_2","text":"inline const T & operator []( size_t i ) const get i'th value Parameters : i index Return : value","title":"function operator[]"},{"location":"Classes/classdakku_1_1VectorBase/#function-operator_3","text":"inline T & operator []( size_t i ) get i'th value Parameters : i index Return : value","title":"function operator[]"},{"location":"Classes/classdakku_1_1VectorBase/#function-operator_4","text":"inline D & operator += ( const D & rhs ) addition Parameters : rhs another vector Return : this","title":"function operator+="},{"location":"Classes/classdakku_1_1VectorBase/#function-operator_5","text":"template < ArithmeticType V > inline D & operator += ( V rhs ) addition Parameters : rhs scalar Return : this","title":"function operator+="},{"location":"Classes/classdakku_1_1VectorBase/#function-operator_6","text":"inline D operator + ( const D & rhs ) const addition Parameters : rhs another vector Return : result","title":"function operator+"},{"location":"Classes/classdakku_1_1VectorBase/#function-operator_7","text":"template < ArithmeticType V > inline D operator + ( V rhs ) const addition Parameters : rhs another vector Return : result","title":"function operator+"},{"location":"Classes/classdakku_1_1VectorBase/#function-operator-","text":"inline D & operator -= ( const D & rhs ) subtraction Parameters : rhs another vector Return : this","title":"function operator-="},{"location":"Classes/classdakku_1_1VectorBase/#function-operator-_1","text":"template < ArithmeticType V > inline D & operator -= ( V rhs ) subtraction Parameters : rhs scalar Return : this","title":"function operator-="},{"location":"Classes/classdakku_1_1VectorBase/#function-operator_8","text":"inline D & operator *= ( const D & rhs ) multiplication Parameters : rhs another vector Return : this","title":"function operator*="},{"location":"Classes/classdakku_1_1VectorBase/#function-operator_9","text":"template < ArithmeticType V > inline D & operator *= ( V rhs ) multiplication Parameters : rhs scalar Return : this","title":"function operator*="},{"location":"Classes/classdakku_1_1VectorBase/#function-operator_10","text":"inline D operator * ( const D & rhs ) const multiplication Parameters : rhs another vector Return : result","title":"function operator*"},{"location":"Classes/classdakku_1_1VectorBase/#function-operator_11","text":"template < ArithmeticType V > inline D operator * ( V rhs ) const multiplication Parameters : rhs scalar Return : result","title":"function operator*"},{"location":"Classes/classdakku_1_1VectorBase/#function-operator_12","text":"inline D & operator /= ( const D & rhs ) division Parameters : rhs another vector Return : this","title":"function operator/="},{"location":"Classes/classdakku_1_1VectorBase/#function-operator_13","text":"template < ArithmeticType V > inline D & operator /= ( V rhs ) division Parameters : rhs scalar Return : this","title":"function operator/="},{"location":"Classes/classdakku_1_1VectorBase/#function-operator_14","text":"inline D operator / ( const D & rhs ) const division Parameters : rhs another vector Return : result","title":"function operator/"},{"location":"Classes/classdakku_1_1VectorBase/#function-operator_15","text":"template < ArithmeticType U > inline D operator / ( U rhs ) const division Parameters : rhs scalar Return : result","title":"function operator/"},{"location":"Classes/classdakku_1_1VectorBase/#function-operator_16","text":"inline bool operator == ( const VectorBase & rhs ) const","title":"function operator=="},{"location":"Classes/classdakku_1_1VectorBase/#function-operator_17","text":"inline bool operator != ( const VectorBase & rhs ) const","title":"function operator!="},{"location":"Classes/classdakku_1_1VectorBase/#function-x","text":"inline decltype ( auto ) x () const get the first element","title":"function x"},{"location":"Classes/classdakku_1_1VectorBase/#function-x_1","text":"inline decltype ( auto ) x () get the first element","title":"function x"},{"location":"Classes/classdakku_1_1VectorBase/#function-y","text":"inline decltype ( auto ) y () const get the second element","title":"function y"},{"location":"Classes/classdakku_1_1VectorBase/#function-y_1","text":"inline decltype ( auto ) y () get the second element","title":"function y"},{"location":"Classes/classdakku_1_1VectorBase/#function-z","text":"inline decltype ( auto ) z () const get the third element","title":"function z"},{"location":"Classes/classdakku_1_1VectorBase/#function-z_1","text":"inline decltype ( auto ) z () get the fourth element","title":"function z"},{"location":"Classes/classdakku_1_1VectorBase/#function-w","text":"inline decltype ( auto ) w () const get the fourth element","title":"function w"},{"location":"Classes/classdakku_1_1VectorBase/#function-w_1","text":"inline decltype ( auto ) w () get the third element","title":"function w"},{"location":"Classes/classdakku_1_1VectorBase/#function-max_element_index","text":"inline size_t max_element_index () const get the index of the max element Return : the index","title":"function max_element_index"},{"location":"Classes/classdakku_1_1VectorBase/#function-max_element","text":"inline decltype ( auto ) max_element () const get the max element in the vector Return : the max value","title":"function max_element"},{"location":"Classes/classdakku_1_1VectorBase/#function-max","text":"inline D max ( const D & rhs ) const element wise max","title":"function max"},{"location":"Classes/classdakku_1_1VectorBase/#function-min","text":"inline D min ( const D & rhs ) const element wise min","title":"function min"},{"location":"Classes/classdakku_1_1VectorBase/#function-dot","text":"template < typename OtherDerived > inline decltype ( auto ) dot ( const VectorBase < T , S , OtherDerived > & rhs ) const dot product between two vectors Return : \\(\\vec a \\cdot \\vec b\\)","title":"function dot"},{"location":"Classes/classdakku_1_1VectorBase/#function-squarednorm","text":"inline decltype ( auto ) squaredNorm () const squared norm Return : \\(||v|| ^ 2\\)","title":"function squaredNorm"},{"location":"Classes/classdakku_1_1VectorBase/#function-norm","text":"inline decltype ( auto ) norm () const norm Return : \\(||v||\\)","title":"function norm"},{"location":"Classes/classdakku_1_1VectorBase/#function-length","text":"inline decltype ( auto ) length () const length Return : \\(||v||\\)","title":"function length"},{"location":"Classes/classdakku_1_1VectorBase/#function-distance","text":"inline decltype ( auto ) distance ( const D & rhs ) const the distance","title":"function distance"},{"location":"Classes/classdakku_1_1VectorBase/#function-abs","text":"inline D abs () const abs","title":"function abs"},{"location":"Classes/classdakku_1_1VectorBase/#function-cross","text":"inline D cross ( const D & rhs ) const cross product","title":"function cross"},{"location":"Classes/classdakku_1_1VectorBase/#function-is_zero","text":"inline bool is_zero () const check whether all components are zero","title":"function is_zero"},{"location":"Classes/classdakku_1_1VectorBase/#function-sqrt","text":"inline D sqrt () const element-wise sqrt","title":"function sqrt"},{"location":"Classes/classdakku_1_1VectorBase/#function-pow","text":"template < ArithmeticType E > inline D pow ( E e ) const element-wise power","title":"function pow"},{"location":"Classes/classdakku_1_1VectorBase/#function-exp","text":"inline D exp () const element-wise exp","title":"function exp"},{"location":"Classes/classdakku_1_1VectorBase/#function-floor","text":"inline D floor () const element-wise floor","title":"function floor"},{"location":"Classes/classdakku_1_1VectorBase/#function-ceil","text":"inline D ceil () const element-wise ceil","title":"function ceil"},{"location":"Classes/classdakku_1_1VectorBase/#function-lerp","text":"inline D lerp ( const D & b , T t ) const element-wise linear interpolation","title":"function lerp"},{"location":"Classes/classdakku_1_1VectorBase/#function-operator-stdspan-t-s","text":"inline operator std :: span < T , S > ()","title":"function operator std::span&lt; T, S &gt;"},{"location":"Classes/classdakku_1_1VectorBase/#function-operator-stdspan-const-t-s","text":"inline operator std :: span < const T , S > () const","title":"function operator std::span&lt; const T, S &gt;"},{"location":"Classes/classdakku_1_1VectorBase/#friends_1","text":"","title":"Friends"},{"location":"Classes/classdakku_1_1VectorBase/#friend-operator","text":"friend D operator + ( U a , const D & b ); addition Parameters : a \\(aa\\) b \\(\\vec b\\) Return : elementwise add a","title":"friend operator+"},{"location":"Classes/classdakku_1_1VectorBase/#friend-operator-","text":"friend D operator - ( U a , const D & b ); subtraction Parameters : a \\(aa\\) b \\(\\vec b\\) Return : elementwise sub","title":"friend operator-"},{"location":"Classes/classdakku_1_1VectorBase/#friend-operator_1","text":"friend D operator * ( U a , const D & b ); multiplication Parameters : a \\(aa\\) b \\(\\vec b\\) Return : elementwise mul","title":"friend operator*"},{"location":"Classes/classdakku_1_1VectorBase/#friend-operator_2","text":"friend D operator / ( U a , const D & b ); division Parameters : a \\(aa\\) b \\(\\vec b\\) Return : elementwise div (broad cast \\(a\\) )","title":"friend operator/"},{"location":"Classes/classdakku_1_1VectorBase/#friend-operator_3","text":"friend std :: ostream & operator << ( std :: ostream & os , const VectorBase & vec ); output the vector Parameters : os ostream vec the vector to output Return : ostream","title":"friend operator&lt;&lt;"},{"location":"Classes/classdakku_1_1VectorBase/#friend-max","text":"friend D max ( const D & v1 , const D & v2 ); element wise max","title":"friend max"},{"location":"Classes/classdakku_1_1VectorBase/#friend-min","text":"friend D min ( const D & v1 , const D & v2 ); element wise min","title":"friend min"},{"location":"Classes/classdakku_1_1VectorBase/#friend-distance","text":"friend decltype ( auto ) distance ( const D & a , const D & b ); the distance","title":"friend distance"},{"location":"Classes/classdakku_1_1VectorBase/#friend-abs","text":"friend D abs ( const D & v ); abs","title":"friend abs"},{"location":"Classes/classdakku_1_1VectorBase/#friend-sqrt","text":"friend D sqrt ( const D & v ); element-wise sqrt","title":"friend sqrt"},{"location":"Classes/classdakku_1_1VectorBase/#friend-pow","text":"friend D pow ( const D & v , E e ); element-wise power","title":"friend pow"},{"location":"Classes/classdakku_1_1VectorBase/#friend-exp","text":"friend D exp ( const D & v ); element-wise exp","title":"friend exp"},{"location":"Classes/classdakku_1_1VectorBase/#friend-floor","text":"friend D floor ( const D & v ); element-wise floor","title":"friend floor"},{"location":"Classes/classdakku_1_1VectorBase/#friend-ceil","text":"friend D ceil ( const D & v ); element-wise ceil","title":"friend ceil"},{"location":"Classes/classdakku_1_1VectorBase/#friend-lerp","text":"friend D lerp ( const D & a , const D & b , T t ); element-wise linear interpolation Updated on 2022-04-25 at 11:08:30 +0000","title":"friend lerp"},{"location":"Examples/","text":"Examples Updated on 2022-04-25 at 11:08:31 +0000","title":"Examples"},{"location":"Examples/#examples","text":"Updated on 2022-04-25 at 11:08:31 +0000","title":"Examples"},{"location":"Files/","text":"Files dir src file src/platform.h dir src/core file src/core/bounds.h file src/core/constants.h file src/core/fwd.h file src/core/logger.h file src/core/lua.h file src/core/math_func.h file src/core/vector.h file src/core/vector_base.h Updated on 2022-04-25 at 11:08:31 +0000","title":"Files"},{"location":"Files/#files","text":"dir src file src/platform.h dir src/core file src/core/bounds.h file src/core/constants.h file src/core/fwd.h file src/core/logger.h file src/core/lua.h file src/core/math_func.h file src/core/vector.h file src/core/vector_base.h Updated on 2022-04-25 at 11:08:31 +0000","title":"Files"},{"location":"Files/bounds_8h/","text":"src/core/bounds.h Namespaces Name dakku dakku namespace Classes Name class dakku::BoundsBase bounding box base Source code #ifndef DAKKU_CORE_BOUNDS_H_ #define DAKKU_CORE_BOUNDS_H_ #include <core/vector.h> #include <iterator> #include <utility> namespace dakku { template < ArithmeticType T , size_t S > class BoundsBase { public : BoundsBase () = default ; Point < T , S > pMin { std :: numeric_limits < T >:: max ()}; Point < T , S > pMax { std :: numeric_limits < T >:: lowest ()}; }; } // namespace dakku #endif Updated on 2022-04-25 at 11:08:30 +0000","title":"src/core/bounds.h"},{"location":"Files/bounds_8h/#srccoreboundsh","text":"","title":"src/core/bounds.h"},{"location":"Files/bounds_8h/#namespaces","text":"Name dakku dakku namespace","title":"Namespaces"},{"location":"Files/bounds_8h/#classes","text":"Name class dakku::BoundsBase bounding box base","title":"Classes"},{"location":"Files/bounds_8h/#source-code","text":"#ifndef DAKKU_CORE_BOUNDS_H_ #define DAKKU_CORE_BOUNDS_H_ #include <core/vector.h> #include <iterator> #include <utility> namespace dakku { template < ArithmeticType T , size_t S > class BoundsBase { public : BoundsBase () = default ; Point < T , S > pMin { std :: numeric_limits < T >:: max ()}; Point < T , S > pMax { std :: numeric_limits < T >:: lowest ()}; }; } // namespace dakku #endif Updated on 2022-04-25 at 11:08:30 +0000","title":"Source code"},{"location":"Files/constants_8h/","text":"src/core/constants.h Namespaces Name dakku dakku namespace Source code #ifndef DAKKU_CORE_CONSTANTS_H_ #define DAKKU_CORE_CONSTANTS_H_ #include <core/fwd.h> namespace dakku {} #endif Updated on 2022-04-25 at 11:08:30 +0000","title":"src/core/constants.h"},{"location":"Files/constants_8h/#srccoreconstantsh","text":"","title":"src/core/constants.h"},{"location":"Files/constants_8h/#namespaces","text":"Name dakku dakku namespace","title":"Namespaces"},{"location":"Files/constants_8h/#source-code","text":"#ifndef DAKKU_CORE_CONSTANTS_H_ #define DAKKU_CORE_CONSTANTS_H_ #include <core/fwd.h> namespace dakku {} #endif Updated on 2022-04-25 at 11:08:30 +0000","title":"Source code"},{"location":"Files/dir_68267d1309a1af8e8297ef4c3efbcdba/","text":"src Directories Name src/core Files Name src/platform.h Updated on 2022-04-25 at 11:08:30 +0000","title":"src"},{"location":"Files/dir_68267d1309a1af8e8297ef4c3efbcdba/#src","text":"","title":"src"},{"location":"Files/dir_68267d1309a1af8e8297ef4c3efbcdba/#directories","text":"Name src/core","title":"Directories"},{"location":"Files/dir_68267d1309a1af8e8297ef4c3efbcdba/#files","text":"Name src/platform.h Updated on 2022-04-25 at 11:08:30 +0000","title":"Files"},{"location":"Files/dir_aebb8dcc11953d78e620bbef0b9e2183/","text":"src/core Files Name src/core/bounds.h src/core/constants.h src/core/fwd.h src/core/logger.h src/core/lua.h src/core/math_func.h src/core/vector.h src/core/vector_base.h Updated on 2022-04-25 at 11:08:30 +0000","title":"src/core"},{"location":"Files/dir_aebb8dcc11953d78e620bbef0b9e2183/#srccore","text":"","title":"src/core"},{"location":"Files/dir_aebb8dcc11953d78e620bbef0b9e2183/#files","text":"Name src/core/bounds.h src/core/constants.h src/core/fwd.h src/core/logger.h src/core/lua.h src/core/math_func.h src/core/vector.h src/core/vector_base.h Updated on 2022-04-25 at 11:08:30 +0000","title":"Files"},{"location":"Files/fwd_8h/","text":"src/core/fwd.h Namespaces Name dakku dakku namespace Defines Name DAKKU_EXPORT_CORE Macros Documentation define DAKKU_EXPORT_CORE #define DAKKU_EXPORT_CORE DAKKU_EXPORT Source code #ifndef DAKKU_CORE_FWD_H_ #define DAKKU_CORE_FWD_H_ #include <platform.h> #include <type_traits> namespace dakku { #if DAKKU_BUILD_MODULE != DAKKU_CORE_MODULE #define DAKKU_EXPORT_CORE DAKKU_IMPORT #else #define DAKKU_EXPORT_CORE DAKKU_EXPORT #endif template < typename T > concept ArithmeticType = std :: is_arithmetic_v < std :: decay_t < T >> ; } // namespace dakku #endif Updated on 2022-04-25 at 11:08:31 +0000","title":"src/core/fwd.h"},{"location":"Files/fwd_8h/#srccorefwdh","text":"","title":"src/core/fwd.h"},{"location":"Files/fwd_8h/#namespaces","text":"Name dakku dakku namespace","title":"Namespaces"},{"location":"Files/fwd_8h/#defines","text":"Name DAKKU_EXPORT_CORE","title":"Defines"},{"location":"Files/fwd_8h/#macros-documentation","text":"","title":"Macros Documentation"},{"location":"Files/fwd_8h/#define-dakku_export_core","text":"#define DAKKU_EXPORT_CORE DAKKU_EXPORT","title":"define DAKKU_EXPORT_CORE"},{"location":"Files/fwd_8h/#source-code","text":"#ifndef DAKKU_CORE_FWD_H_ #define DAKKU_CORE_FWD_H_ #include <platform.h> #include <type_traits> namespace dakku { #if DAKKU_BUILD_MODULE != DAKKU_CORE_MODULE #define DAKKU_EXPORT_CORE DAKKU_IMPORT #else #define DAKKU_EXPORT_CORE DAKKU_EXPORT #endif template < typename T > concept ArithmeticType = std :: is_arithmetic_v < std :: decay_t < T >> ; } // namespace dakku #endif Updated on 2022-04-25 at 11:08:31 +0000","title":"Source code"},{"location":"Files/logger_8h/","text":"src/core/logger.h Namespaces Name dakku dakku namespace Classes Name class dakku::Logger logger class Defines Name DAKKU_ERR (...) log error message DAKKU_INFO (...) log info message DAKKU_WARN (...) log warning message DAKKU_DEBUG (...) log debug message DAKKU_CHECK (...) check whether the condition val is true, if not log error messages Macros Documentation define DAKKU_ERR #define DAKKU_ERR( ... ) SPDLOG_LOGGER_CALL ( Logger :: get (). handle (), spdlog :: level :: err , __VA_ARGS__ ) log error message define DAKKU_INFO #define DAKKU_INFO( ... ) SPDLOG_LOGGER_CALL ( Logger :: get (). handle (), spdlog :: level :: info , __VA_ARGS__ ) log info message define DAKKU_WARN #define DAKKU_WARN( ... ) SPDLOG_LOGGER_CALL ( Logger :: get (). handle (), spdlog :: level :: warn , __VA_ARGS__ ) log warning message define DAKKU_DEBUG #define DAKKU_DEBUG( ... ) static_cast < void > ( 0 ) log debug message define DAKKU_CHECK #define DAKKU_CHECK( ... ) static_cast < void > ( 0 ) check whether the condition val is true, if not log error messages Source code #ifndef DAKKU_CORE_LOGGER_H_ #define DAKKU_CORE_LOGGER_H_ #include <core/fwd.h> #include <memory> #include <spdlog/spdlog.h> #include <spdlog/fmt/ostr.h> namespace dakku { class DAKKU_EXPORT_CORE Logger { public : static const Logger & get (); [[ nodiscard ]] spdlog :: logger * handle () const { return _logger . get (); } private : explicit Logger ( std :: shared_ptr < spdlog :: logger > _logger ); std :: shared_ptr < spdlog :: logger > _logger ; }; #define DAKKU_ERR(...) \\ SPDLOG_LOGGER_CALL(Logger::get().handle(), spdlog::level::err, __VA_ARGS__) #define DAKKU_INFO(...) \\ SPDLOG_LOGGER_CALL(Logger::get().handle(), spdlog::level::info, __VA_ARGS__) #define DAKKU_WARN(...) \\ SPDLOG_LOGGER_CALL(Logger::get().handle(), spdlog::level::warn, __VA_ARGS__) #ifdef DAKKU_BUILD_DEBUG #define DAKKU_DEBUG(...) \\ SPDLOG_LOGGER_CALL(Logger::get().handle(), spdlog::level::debug, __VA_ARGS__) #else #define DAKKU_DEBUG(...) static_cast<void>(0) #endif #ifdef DAKKU_BUILD_CHECK #define DAKKU_CHECK(val, ...) \\ do { \\ if (!(val)) { \\ DAKKU_ERR(__VA_ARGS__); \\ std::exit(-1); \\ } \\ } while (0) #else #define DAKKU_CHECK(...) static_cast<void>(0) #endif } // namespace dakku #endif Updated on 2022-04-25 at 11:08:31 +0000","title":"src/core/logger.h"},{"location":"Files/logger_8h/#srccoreloggerh","text":"","title":"src/core/logger.h"},{"location":"Files/logger_8h/#namespaces","text":"Name dakku dakku namespace","title":"Namespaces"},{"location":"Files/logger_8h/#classes","text":"Name class dakku::Logger logger class","title":"Classes"},{"location":"Files/logger_8h/#defines","text":"Name DAKKU_ERR (...) log error message DAKKU_INFO (...) log info message DAKKU_WARN (...) log warning message DAKKU_DEBUG (...) log debug message DAKKU_CHECK (...) check whether the condition val is true, if not log error messages","title":"Defines"},{"location":"Files/logger_8h/#macros-documentation","text":"","title":"Macros Documentation"},{"location":"Files/logger_8h/#define-dakku_err","text":"#define DAKKU_ERR( ... ) SPDLOG_LOGGER_CALL ( Logger :: get (). handle (), spdlog :: level :: err , __VA_ARGS__ ) log error message","title":"define DAKKU_ERR"},{"location":"Files/logger_8h/#define-dakku_info","text":"#define DAKKU_INFO( ... ) SPDLOG_LOGGER_CALL ( Logger :: get (). handle (), spdlog :: level :: info , __VA_ARGS__ ) log info message","title":"define DAKKU_INFO"},{"location":"Files/logger_8h/#define-dakku_warn","text":"#define DAKKU_WARN( ... ) SPDLOG_LOGGER_CALL ( Logger :: get (). handle (), spdlog :: level :: warn , __VA_ARGS__ ) log warning message","title":"define DAKKU_WARN"},{"location":"Files/logger_8h/#define-dakku_debug","text":"#define DAKKU_DEBUG( ... ) static_cast < void > ( 0 ) log debug message","title":"define DAKKU_DEBUG"},{"location":"Files/logger_8h/#define-dakku_check","text":"#define DAKKU_CHECK( ... ) static_cast < void > ( 0 ) check whether the condition val is true, if not log error messages","title":"define DAKKU_CHECK"},{"location":"Files/logger_8h/#source-code","text":"#ifndef DAKKU_CORE_LOGGER_H_ #define DAKKU_CORE_LOGGER_H_ #include <core/fwd.h> #include <memory> #include <spdlog/spdlog.h> #include <spdlog/fmt/ostr.h> namespace dakku { class DAKKU_EXPORT_CORE Logger { public : static const Logger & get (); [[ nodiscard ]] spdlog :: logger * handle () const { return _logger . get (); } private : explicit Logger ( std :: shared_ptr < spdlog :: logger > _logger ); std :: shared_ptr < spdlog :: logger > _logger ; }; #define DAKKU_ERR(...) \\ SPDLOG_LOGGER_CALL(Logger::get().handle(), spdlog::level::err, __VA_ARGS__) #define DAKKU_INFO(...) \\ SPDLOG_LOGGER_CALL(Logger::get().handle(), spdlog::level::info, __VA_ARGS__) #define DAKKU_WARN(...) \\ SPDLOG_LOGGER_CALL(Logger::get().handle(), spdlog::level::warn, __VA_ARGS__) #ifdef DAKKU_BUILD_DEBUG #define DAKKU_DEBUG(...) \\ SPDLOG_LOGGER_CALL(Logger::get().handle(), spdlog::level::debug, __VA_ARGS__) #else #define DAKKU_DEBUG(...) static_cast<void>(0) #endif #ifdef DAKKU_BUILD_CHECK #define DAKKU_CHECK(val, ...) \\ do { \\ if (!(val)) { \\ DAKKU_ERR(__VA_ARGS__); \\ std::exit(-1); \\ } \\ } while (0) #else #define DAKKU_CHECK(...) static_cast<void>(0) #endif } // namespace dakku #endif Updated on 2022-04-25 at 11:08:31 +0000","title":"Source code"},{"location":"Files/lua_8h/","text":"src/core/lua.h Namespaces Name dakku dakku namespace Classes Name class dakku::Lua dakku lua state Defines Name SOL_ALL_SAFETIES_ON DAKKU_DECLARE_LUA_OBJECT (name) DAKKU_IMPLEMENT_LUA_OBJECT (name, func) Macros Documentation define SOL_ALL_SAFETIES_ON #define SOL_ALL_SAFETIES_ON 1 define DAKKU_DECLARE_LUA_OBJECT #define DAKKU_DECLARE_LUA_OBJECT( name ) struct _ ## name ## _lua_bind_wrapper { \\ static int _ ## name ## _bind_lua ; \\ } define DAKKU_IMPLEMENT_LUA_OBJECT #define DAKKU_IMPLEMENT_LUA_OBJECT( name , func ) int _ ## name ## _lua_bind_wrapper :: _ ## name ## _bind_lua = ( func )() Source code #ifndef DAKKU_CORE_LUA_H_ #define DAKKU_CORE_LUA_H_ #include <core/fwd.h> #if !defined(SOL_ALL_SAFETIES_ON) #define SOL_ALL_SAFETIES_ON 1 #endif #include <sol/sol.hpp> namespace dakku { class DAKKU_EXPORT_CORE Lua { public : static Lua & instance (); sol :: state & get_state (); private : sol :: state state ; }; #define DAKKU_DECLARE_LUA_OBJECT(name) \\ struct _##name##_lua_bind_wrapper { \\ static int _##name##_bind_lua; \\ } #define DAKKU_IMPLEMENT_LUA_OBJECT(name, func) \\ int _##name##_lua_bind_wrapper::_##name##_bind_lua = (func)() } // namespace dakku #endif Updated on 2022-04-25 at 11:08:31 +0000","title":"src/core/lua.h"},{"location":"Files/lua_8h/#srccoreluah","text":"","title":"src/core/lua.h"},{"location":"Files/lua_8h/#namespaces","text":"Name dakku dakku namespace","title":"Namespaces"},{"location":"Files/lua_8h/#classes","text":"Name class dakku::Lua dakku lua state","title":"Classes"},{"location":"Files/lua_8h/#defines","text":"Name SOL_ALL_SAFETIES_ON DAKKU_DECLARE_LUA_OBJECT (name) DAKKU_IMPLEMENT_LUA_OBJECT (name, func)","title":"Defines"},{"location":"Files/lua_8h/#macros-documentation","text":"","title":"Macros Documentation"},{"location":"Files/lua_8h/#define-sol_all_safeties_on","text":"#define SOL_ALL_SAFETIES_ON 1","title":"define SOL_ALL_SAFETIES_ON"},{"location":"Files/lua_8h/#define-dakku_declare_lua_object","text":"#define DAKKU_DECLARE_LUA_OBJECT( name ) struct _ ## name ## _lua_bind_wrapper { \\ static int _ ## name ## _bind_lua ; \\ }","title":"define DAKKU_DECLARE_LUA_OBJECT"},{"location":"Files/lua_8h/#define-dakku_implement_lua_object","text":"#define DAKKU_IMPLEMENT_LUA_OBJECT( name , func ) int _ ## name ## _lua_bind_wrapper :: _ ## name ## _bind_lua = ( func )()","title":"define DAKKU_IMPLEMENT_LUA_OBJECT"},{"location":"Files/lua_8h/#source-code","text":"#ifndef DAKKU_CORE_LUA_H_ #define DAKKU_CORE_LUA_H_ #include <core/fwd.h> #if !defined(SOL_ALL_SAFETIES_ON) #define SOL_ALL_SAFETIES_ON 1 #endif #include <sol/sol.hpp> namespace dakku { class DAKKU_EXPORT_CORE Lua { public : static Lua & instance (); sol :: state & get_state (); private : sol :: state state ; }; #define DAKKU_DECLARE_LUA_OBJECT(name) \\ struct _##name##_lua_bind_wrapper { \\ static int _##name##_bind_lua; \\ } #define DAKKU_IMPLEMENT_LUA_OBJECT(name, func) \\ int _##name##_lua_bind_wrapper::_##name##_bind_lua = (func)() } // namespace dakku #endif Updated on 2022-04-25 at 11:08:31 +0000","title":"Source code"},{"location":"Files/math__func_8h/","text":"src/core/math_func.h Namespaces Name dakku dakku namespace Source code #ifndef DAKKU_CORE_MATH_FUNC_H_ #define DAKKU_CORE_MATH_FUNC_H_ #include <core/fwd.h> #include <cmath> namespace dakku { template < typename T > requires std :: is_floating_point_v < T > DAKKU_INLINE bool isnan ( T x ) { return std :: isnan ( x ); } template < typename T > requires std :: is_integral_v < T > DAKKU_INLINE bool isnan ( T ) { return false ; } } // namespace dakku #endif Updated on 2022-04-25 at 11:08:31 +0000","title":"src/core/math_func.h"},{"location":"Files/math__func_8h/#srccoremath_funch","text":"","title":"src/core/math_func.h"},{"location":"Files/math__func_8h/#namespaces","text":"Name dakku dakku namespace","title":"Namespaces"},{"location":"Files/math__func_8h/#source-code","text":"#ifndef DAKKU_CORE_MATH_FUNC_H_ #define DAKKU_CORE_MATH_FUNC_H_ #include <core/fwd.h> #include <cmath> namespace dakku { template < typename T > requires std :: is_floating_point_v < T > DAKKU_INLINE bool isnan ( T x ) { return std :: isnan ( x ); } template < typename T > requires std :: is_integral_v < T > DAKKU_INLINE bool isnan ( T ) { return false ; } } // namespace dakku #endif Updated on 2022-04-25 at 11:08:31 +0000","title":"Source code"},{"location":"Files/platform_8h/","text":"src/platform.h Namespaces Name dakku dakku namespace Defines Name DAKKU_INLINE DAKKU_EXPORT DAKKU_IMPORT DAKKU_CORE_MODULE dakku core module DAKKU_MAIN_MODULE dakku main module Macros Documentation define DAKKU_INLINE #define DAKKU_INLINE __attribute__((always_inline)) inline define DAKKU_EXPORT #define DAKKU_EXPORT __attribute__((visibility(\"default\"))) define DAKKU_IMPORT #define DAKKU_IMPORT define DAKKU_CORE_MODULE #define DAKKU_CORE_MODULE 1 dakku core module define DAKKU_MAIN_MODULE #define DAKKU_MAIN_MODULE 10 dakku main module Source code #ifndef DAKKU_PLATFORM_H_ #define DAKKU_PLATFORM_H_ #if defined(_MSC_VER) #if !defined(_USE_MATH_DEFINES) && !defined(M_PI) #define _USE_MATH_DEFINES #endif #endif namespace dakku { #if defined(_MSC_VER) #define DAKKU_INLINE __forceinline #define DAKKU_EXPORT __declspec(dllexport) #define DAKKU_IMPORT __declspec(dllimport) #else #define DAKKU_INLINE __attribute__((always_inline)) inline #define DAKKU_EXPORT __attribute__((visibility(\"default\"))) #define DAKKU_IMPORT #endif #define DAKKU_CORE_MODULE 1 #define DAKKU_MAIN_MODULE 10 #if defined(_MSC_VER) #pragma warning(disable : 4251) #endif } // namespace dakku #endif Updated on 2022-04-25 at 11:08:31 +0000","title":"src/platform.h"},{"location":"Files/platform_8h/#srcplatformh","text":"","title":"src/platform.h"},{"location":"Files/platform_8h/#namespaces","text":"Name dakku dakku namespace","title":"Namespaces"},{"location":"Files/platform_8h/#defines","text":"Name DAKKU_INLINE DAKKU_EXPORT DAKKU_IMPORT DAKKU_CORE_MODULE dakku core module DAKKU_MAIN_MODULE dakku main module","title":"Defines"},{"location":"Files/platform_8h/#macros-documentation","text":"","title":"Macros Documentation"},{"location":"Files/platform_8h/#define-dakku_inline","text":"#define DAKKU_INLINE __attribute__((always_inline)) inline","title":"define DAKKU_INLINE"},{"location":"Files/platform_8h/#define-dakku_export","text":"#define DAKKU_EXPORT __attribute__((visibility(\"default\")))","title":"define DAKKU_EXPORT"},{"location":"Files/platform_8h/#define-dakku_import","text":"#define DAKKU_IMPORT","title":"define DAKKU_IMPORT"},{"location":"Files/platform_8h/#define-dakku_core_module","text":"#define DAKKU_CORE_MODULE 1 dakku core module","title":"define DAKKU_CORE_MODULE"},{"location":"Files/platform_8h/#define-dakku_main_module","text":"#define DAKKU_MAIN_MODULE 10 dakku main module","title":"define DAKKU_MAIN_MODULE"},{"location":"Files/platform_8h/#source-code","text":"#ifndef DAKKU_PLATFORM_H_ #define DAKKU_PLATFORM_H_ #if defined(_MSC_VER) #if !defined(_USE_MATH_DEFINES) && !defined(M_PI) #define _USE_MATH_DEFINES #endif #endif namespace dakku { #if defined(_MSC_VER) #define DAKKU_INLINE __forceinline #define DAKKU_EXPORT __declspec(dllexport) #define DAKKU_IMPORT __declspec(dllimport) #else #define DAKKU_INLINE __attribute__((always_inline)) inline #define DAKKU_EXPORT __attribute__((visibility(\"default\"))) #define DAKKU_IMPORT #endif #define DAKKU_CORE_MODULE 1 #define DAKKU_MAIN_MODULE 10 #if defined(_MSC_VER) #pragma warning(disable : 4251) #endif } // namespace dakku #endif Updated on 2022-04-25 at 11:08:31 +0000","title":"Source code"},{"location":"Files/vector_8h/","text":"src/core/vector.h Namespaces Name dakku dakku namespace Classes Name class dakku::Vector vector class dakku::Point point class dakku::Normal normal Source code #ifndef DAKKU_CORE_VECTOR_H_ #define DAKKU_CORE_VECTOR_H_ #include <core/vector_base.h> #include <core/lua.h> namespace dakku { template < typename T , size_t S > class DAKKU_EXPORT_CORE Vector : public VectorBase < T , S , Vector < T , S >> { public : using VectorBase < T , S , Vector < T , S >>:: VectorBase ; Vector operator - () const { Vector ret = * this ; for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = - ret [ i ]; return ret ; } Vector operator - ( const Vector & rhs ) const { Vector ret = * this ; ret -= rhs ; return ret ; } template < ArithmeticType V > Vector operator - ( V rhs ) const { Vector ret = * this ; ret -= rhs ; return ret ; } }; using Vector2i = Vector < int , 2 > ; using Vector2f = Vector < float , 2 > ; using Vector3i = Vector < int , 3 > ; using Vector3f = Vector < float , 3 > ; DAKKU_DECLARE_LUA_OBJECT ( Vector2i ); DAKKU_DECLARE_LUA_OBJECT ( Vector2f ); DAKKU_DECLARE_LUA_OBJECT ( Vector3i ); DAKKU_DECLARE_LUA_OBJECT ( Vector3f ); template < typename T , size_t S > class DAKKU_EXPORT_CORE Point : public VectorBase < T , S , Point < T , S >> { public : using VectorBase < T , S , Point < T , S >>:: VectorBase ; Point operator - () const { Point ret = * this ; for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = - ret [ i ]; return ret ; } template < ArithmeticType V > Point operator - ( V rhs ) const { Point ret = * this ; ret -= rhs ; return ret ; } Vector < T , S > operator - ( const Point & rhs ) const { Point ret = * this ; ret -= rhs ; return Vector < T , S > { ret }; } Point operator - ( const Vector < T , S > & rhs ) const { Point ret = * this ; ret -= Point ( rhs ); return ret ; } }; using Point3f = Point < float , 3 > ; using Point3i = Point < int , 3 > ; using Point2f = Point < float , 2 > ; using Point2i = Point < int , 2 > ; DAKKU_DECLARE_LUA_OBJECT ( Point3f ); DAKKU_DECLARE_LUA_OBJECT ( Point3i ); DAKKU_DECLARE_LUA_OBJECT ( Point2f ); DAKKU_DECLARE_LUA_OBJECT ( Point2i ); template < typename T , size_t S > class DAKKU_EXPORT_CORE Normal : public VectorBase < T , S , Normal < T , S >> { public : using VectorBase < T , S , Normal < T , S >>:: VectorBase ; Normal operator - () const { Normal ret = * this ; for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = - ret [ i ]; return ret ; } Normal operator - ( const Normal & rhs ) const { Normal ret = * this ; ret -= rhs ; return ret ; } template < ArithmeticType V > Normal operator - ( V rhs ) const { Normal ret = * this ; ret -= rhs ; return ret ; } }; using Normal3f = Normal < float , 3 > ; DAKKU_DECLARE_LUA_OBJECT ( Normal3f ); } // namespace dakku #endif Updated on 2022-04-25 at 11:08:31 +0000","title":"src/core/vector.h"},{"location":"Files/vector_8h/#srccorevectorh","text":"","title":"src/core/vector.h"},{"location":"Files/vector_8h/#namespaces","text":"Name dakku dakku namespace","title":"Namespaces"},{"location":"Files/vector_8h/#classes","text":"Name class dakku::Vector vector class dakku::Point point class dakku::Normal normal","title":"Classes"},{"location":"Files/vector_8h/#source-code","text":"#ifndef DAKKU_CORE_VECTOR_H_ #define DAKKU_CORE_VECTOR_H_ #include <core/vector_base.h> #include <core/lua.h> namespace dakku { template < typename T , size_t S > class DAKKU_EXPORT_CORE Vector : public VectorBase < T , S , Vector < T , S >> { public : using VectorBase < T , S , Vector < T , S >>:: VectorBase ; Vector operator - () const { Vector ret = * this ; for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = - ret [ i ]; return ret ; } Vector operator - ( const Vector & rhs ) const { Vector ret = * this ; ret -= rhs ; return ret ; } template < ArithmeticType V > Vector operator - ( V rhs ) const { Vector ret = * this ; ret -= rhs ; return ret ; } }; using Vector2i = Vector < int , 2 > ; using Vector2f = Vector < float , 2 > ; using Vector3i = Vector < int , 3 > ; using Vector3f = Vector < float , 3 > ; DAKKU_DECLARE_LUA_OBJECT ( Vector2i ); DAKKU_DECLARE_LUA_OBJECT ( Vector2f ); DAKKU_DECLARE_LUA_OBJECT ( Vector3i ); DAKKU_DECLARE_LUA_OBJECT ( Vector3f ); template < typename T , size_t S > class DAKKU_EXPORT_CORE Point : public VectorBase < T , S , Point < T , S >> { public : using VectorBase < T , S , Point < T , S >>:: VectorBase ; Point operator - () const { Point ret = * this ; for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = - ret [ i ]; return ret ; } template < ArithmeticType V > Point operator - ( V rhs ) const { Point ret = * this ; ret -= rhs ; return ret ; } Vector < T , S > operator - ( const Point & rhs ) const { Point ret = * this ; ret -= rhs ; return Vector < T , S > { ret }; } Point operator - ( const Vector < T , S > & rhs ) const { Point ret = * this ; ret -= Point ( rhs ); return ret ; } }; using Point3f = Point < float , 3 > ; using Point3i = Point < int , 3 > ; using Point2f = Point < float , 2 > ; using Point2i = Point < int , 2 > ; DAKKU_DECLARE_LUA_OBJECT ( Point3f ); DAKKU_DECLARE_LUA_OBJECT ( Point3i ); DAKKU_DECLARE_LUA_OBJECT ( Point2f ); DAKKU_DECLARE_LUA_OBJECT ( Point2i ); template < typename T , size_t S > class DAKKU_EXPORT_CORE Normal : public VectorBase < T , S , Normal < T , S >> { public : using VectorBase < T , S , Normal < T , S >>:: VectorBase ; Normal operator - () const { Normal ret = * this ; for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = - ret [ i ]; return ret ; } Normal operator - ( const Normal & rhs ) const { Normal ret = * this ; ret -= rhs ; return ret ; } template < ArithmeticType V > Normal operator - ( V rhs ) const { Normal ret = * this ; ret -= rhs ; return ret ; } }; using Normal3f = Normal < float , 3 > ; DAKKU_DECLARE_LUA_OBJECT ( Normal3f ); } // namespace dakku #endif Updated on 2022-04-25 at 11:08:31 +0000","title":"Source code"},{"location":"Files/vector__base_8h/","text":"src/core/vector_base.h Namespaces Name dakku dakku namespace Classes Name class dakku::VectorBase vector base Source code #ifndef DAKKU_CORE_VECTOR_BASE_H_ #define DAKKU_CORE_VECTOR_BASE_H_ #include <core/logger.h> #include <core/lua.h> #include <array> #include <numeric> #include <span> namespace dakku { template < ArithmeticType T , size_t S , typename D > class DAKKU_EXPORT_CORE VectorBase { public : VectorBase () : _data () {} template < ArithmeticType Arg > VectorBase ( Arg value ) { set ( value ); DAKKU_CHECK ( ! has_nans (), \"has nan\" ); } VectorBase ( const sol :: table & table ) { for ( size_t i = 0 ; i < S ; ++ i ) _data [ i ] = table . get_or ( i + 1 , T { 0 }); DAKKU_CHECK ( ! has_nans (), \"has nan\" ); } template < ArithmeticType ... Args > requires ( sizeof ...( Args ) == S ) VectorBase ( Args && ... args ) { set ( std :: forward < Args > ( args )...); } template < ArithmeticType Other , typename OtherDerived > explicit VectorBase ( const VectorBase < Other , S , OtherDerived > & other ) { set ( other ); DAKKU_CHECK ( ! has_nans (), \"has nan\" ); } VectorBase ( const VectorBase & other ) : _data ( other . _data ) { DAKKU_CHECK ( ! has_nans (), \"has nan\" ); } VectorBase ( VectorBase && other ) noexcept : _data ( std :: move ( other . _data )) { DAKKU_CHECK ( ! has_nans (), \"has nan\" ); } VectorBase & operator = ( const VectorBase & other ) { if ( this == & other ) return * this ; _data = other . _data ; DAKKU_CHECK ( ! has_nans (), \"has nan\" ); return * this ; } VectorBase & operator = ( VectorBase && other ) noexcept { if ( this == & other ) return * this ; _data = std :: move ( other . _data ); DAKKU_CHECK ( ! has_nans (), \"has nan\" ); return * this ; } const D & derived () const { return static_cast < const D &> ( * this ); } D & derived () { return const_cast < D &> ( static_cast < const VectorBase &> ( * this ). derived ()); } template < ArithmeticType Arg > void set ( Arg value ) { _data . fill ( static_cast < T > ( value )); } template < ArithmeticType Arg > void set_by_index ( size_t index , Arg value ) { DAKKU_CHECK ( 0 <= index && index < S , \"index out of range: {} >= {}\" , index , S ); _data [ index ] = static_cast < T > ( value ); } template < ArithmeticType ... Args , size_t ... Is > requires ( sizeof ...( Args ) == S ) void set ( std :: index_sequence < Is ... > , Args && ... args ) { ( set_by_index ( Is , std :: forward < Args > ( args )), ...); } template < ArithmeticType ... Args > requires ( sizeof ...( Args ) == S ) void set ( Args && ... args ) { set ( std :: index_sequence_for < Args ... > {}, std :: forward < Args > ( args )...); } template < ArithmeticType Other , typename OtherDerived > void set ( const VectorBase < Other , S , OtherDerived > & rhs ) { for ( size_t i = 0 ; i < S ; ++ i ) _data [ i ] = static_cast < T > ( rhs [ i ]); } const T & get ( size_t i ) const { DAKKU_CHECK ( 0 <= i && i < S , \"index out of range {} >= {}\" , i , S ); return _data [ i ]; } [[ nodiscard ]] size_t size () const { return S ; } [[ nodiscard ]] std :: string to_string () const { std :: string ret { \"[\" }; for ( size_t i = 0 ; i < _data . size (); ++ i ) { ret += std :: to_string ( _data [ i ]); if ( i + 1 != _data . size ()) ret += \", \" ; } return ret + \"]\" ; } [[ nodiscard ]] bool has_nans () const { return std :: any_of ( std :: begin ( _data ), std :: end ( _data ), []( T x ) { return isnan ( x ); }); } D clone () const { return D { derived ()}; } const T & operator []( size_t i ) const { return _data [ i ]; } T & operator []( size_t i ) { return const_cast < T &> ( static_cast < const VectorBase &> ( * this )[ i ]); } D & operator += ( const D & rhs ) { for ( size_t i = 0 ; i < S ; ++ i ) _data [ i ] += rhs [ i ]; return derived (); } template < ArithmeticType V > D & operator += ( V rhs ) { for ( size_t i = 0 ; i < S ; ++ i ) _data [ i ] += rhs ; return derived (); } D operator + ( const D & rhs ) const { D ret = derived (); ret += rhs ; return ret ; } template < ArithmeticType V > D operator + ( V rhs ) const { D ret = derived (); ret += rhs ; return ret ; } template < ArithmeticType U > friend D operator + ( U a , const D & b ) { return b + a ; } D & operator -= ( const D & rhs ) { for ( size_t i = 0 ; i < S ; ++ i ) _data [ i ] -= rhs [ i ]; return derived (); } template < ArithmeticType V > D & operator -= ( V rhs ) { for ( size_t i = 0 ; i < S ; ++ i ) _data [ i ] -= rhs ; return derived (); } template < ArithmeticType U > friend D operator - ( U a , const D & b ) { D ret = - b ; ret += a ; return ret ; } D & operator *= ( const D & rhs ) { for ( size_t i = 0 ; i < S ; ++ i ) _data [ i ] *= rhs [ i ]; return derived (); } template < ArithmeticType V > D & operator *= ( V rhs ) { for ( size_t i = 0 ; i < S ; ++ i ) _data [ i ] *= rhs ; return derived (); } D operator * ( const D & rhs ) const { D ret = derived (); ret *= rhs ; return ret ; } template < ArithmeticType V > D operator * ( V rhs ) const { D ret = derived (); ret *= rhs ; return ret ; } template < ArithmeticType U > friend D operator * ( U a , const D & b ) { return b * a ; } D & operator /= ( const D & rhs ) { for ( size_t i = 0 ; i < S ; ++ i ) _data [ i ] /= rhs [ i ]; return derived (); } template < ArithmeticType V > D & operator /= ( V rhs ) { return derived () *= static_cast < T > ( T { 1 } / rhs ); } D operator / ( const D & rhs ) const { D ret = derived (); ret /= rhs ; return ret ; } template < ArithmeticType U > D operator / ( U rhs ) const { D ret = derived (); ret /= rhs ; return ret ; } template < ArithmeticType U > friend D operator / ( U a , const D & b ) { return D ( a ) / b ; } friend std :: ostream & operator << ( std :: ostream & os , const VectorBase & vec ) { return os << vec . to_string (); } bool operator == ( const VectorBase & rhs ) const { return _data == rhs . _data ; } bool operator != ( const VectorBase & rhs ) const { return _data != rhs . _data ; } decltype ( auto ) x () const { static_assert ( S >= 1 , \"not enough size to get x\" ); return _data [ 0 ]; } decltype ( auto ) x () { static_assert ( S >= 1 , \"not enough size to get x\" ); return _data [ 0 ]; } decltype ( auto ) y () const { static_assert ( S >= 2 , \"not enough size to get y\" ); return _data [ 1 ]; } decltype ( auto ) y () { static_assert ( S >= 2 , \"not enough size to get y\" ); return _data [ 1 ]; } decltype ( auto ) z () const { static_assert ( S >= 3 , \"not enough size to get z\" ); return _data [ 2 ]; } decltype ( auto ) z () { static_assert ( S >= 3 , \"not enough size to get w\" ); return _data [ 2 ]; } decltype ( auto ) w () const { static_assert ( S >= 4 , \"not enough size to get w\" ); return _data [ 3 ]; } decltype ( auto ) w () { static_assert ( S >= 4 , \"not enough size to get z\" ); return _data [ 3 ]; } [[ nodiscard ]] size_t max_element_index () const { return std :: distance ( _data . begin (), std :: max_element ( _data . begin (), _data . end ())); } decltype ( auto ) max_element () const { return _data [ max_element_index ()]; } friend D max ( const D & v1 , const D & v2 ) { D ret = v1 ; for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = std :: max ( ret [ i ], v2 [ i ]); return ret ; } D max ( const D & rhs ) const { return max ( derived (), rhs ); } friend D min ( const D & v1 , const D & v2 ) { D ret = v1 ; for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = std :: min ( ret [ i ], v2 [ i ]); return ret ; } D min ( const D & rhs ) const { return min ( derived (), rhs ); } template < typename OtherDerived > decltype ( auto ) dot ( const VectorBase < T , S , OtherDerived > & rhs ) const { return std :: inner_product ( _data . begin (), _data . end (), rhs . _data . begin (), T {}); } decltype ( auto ) squaredNorm () const { return this -> dot ( * this ); } decltype ( auto ) norm () const { return std :: sqrt ( squaredNorm ()); } decltype ( auto ) length () const { return norm (); } friend decltype ( auto ) distance ( const D & a , const D & b ) { return ( a - b ). length (); } decltype ( auto ) distance ( const D & rhs ) const { return distance ( derived (), rhs ); } friend D abs ( const D & v ) { D ret = v ; for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = std :: abs ( ret [ i ]); return ret ; } D abs () const { return abs ( derived ()); } D cross ( const D & rhs ) const { static_assert ( S == 3 , \"only 3d vector support cross product\" ); return D {( y () * rhs . z ()) - ( z () * rhs . y ()), ( z () * rhs . x ()) - ( x () * rhs . z ()), ( x () * rhs . y ()) - ( y () * rhs . x ())}; } [[ nodiscard ]] bool is_zero () const { return std :: all_of ( _data . begin (), _data . end (), []( const T & v ) { return v == 0 ; }); } friend D sqrt ( const D & v ) { D ret = v ; for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = static_cast < T > ( std :: sqrt ( ret [ i ])); return ret ; } D sqrt () const { return sqrt ( derived ()); } template < ArithmeticType E > friend D pow ( const D & v , E e ) { D ret = v ; for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = static_cast < T > ( std :: pow ( ret [ i ], e )); return ret ; } template < ArithmeticType E > D pow ( E e ) const { return pow ( derived (), e ); } friend D exp ( const D & v ) { D ret = v ; for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = static_cast < T > ( std :: exp ( ret [ i ])); return ret ; } D exp () const { return exp ( derived ()); } friend D floor ( const D & v ) { D ret = v ; for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = std :: floor ( ret [ i ]); return ret ; } D floor () const { return floor ( derived ()); } friend D ceil ( const D & v ) { D ret = v ; for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = std :: ceil ( ret [ i ]); return ret ; } D ceil () const { return ceil ( derived ()); } friend D lerp ( const D & a , const D & b , T t ) { D ret ; for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = std :: lerp ( a [ i ], b [ i ], t ); return ret ; } D lerp ( const D & b , T t ) const { return lerp ( derived (), b , t ); } operator std :: span < T , S > () { return std :: span { _data }; } operator std :: span < const T , S > () const { return std :: span { _data }; } private : std :: array < T , S > _data ; }; } // namespace dakku #endif Updated on 2022-04-25 at 11:08:31 +0000","title":"src/core/vector_base.h"},{"location":"Files/vector__base_8h/#srccorevector_baseh","text":"","title":"src/core/vector_base.h"},{"location":"Files/vector__base_8h/#namespaces","text":"Name dakku dakku namespace","title":"Namespaces"},{"location":"Files/vector__base_8h/#classes","text":"Name class dakku::VectorBase vector base","title":"Classes"},{"location":"Files/vector__base_8h/#source-code","text":"#ifndef DAKKU_CORE_VECTOR_BASE_H_ #define DAKKU_CORE_VECTOR_BASE_H_ #include <core/logger.h> #include <core/lua.h> #include <array> #include <numeric> #include <span> namespace dakku { template < ArithmeticType T , size_t S , typename D > class DAKKU_EXPORT_CORE VectorBase { public : VectorBase () : _data () {} template < ArithmeticType Arg > VectorBase ( Arg value ) { set ( value ); DAKKU_CHECK ( ! has_nans (), \"has nan\" ); } VectorBase ( const sol :: table & table ) { for ( size_t i = 0 ; i < S ; ++ i ) _data [ i ] = table . get_or ( i + 1 , T { 0 }); DAKKU_CHECK ( ! has_nans (), \"has nan\" ); } template < ArithmeticType ... Args > requires ( sizeof ...( Args ) == S ) VectorBase ( Args && ... args ) { set ( std :: forward < Args > ( args )...); } template < ArithmeticType Other , typename OtherDerived > explicit VectorBase ( const VectorBase < Other , S , OtherDerived > & other ) { set ( other ); DAKKU_CHECK ( ! has_nans (), \"has nan\" ); } VectorBase ( const VectorBase & other ) : _data ( other . _data ) { DAKKU_CHECK ( ! has_nans (), \"has nan\" ); } VectorBase ( VectorBase && other ) noexcept : _data ( std :: move ( other . _data )) { DAKKU_CHECK ( ! has_nans (), \"has nan\" ); } VectorBase & operator = ( const VectorBase & other ) { if ( this == & other ) return * this ; _data = other . _data ; DAKKU_CHECK ( ! has_nans (), \"has nan\" ); return * this ; } VectorBase & operator = ( VectorBase && other ) noexcept { if ( this == & other ) return * this ; _data = std :: move ( other . _data ); DAKKU_CHECK ( ! has_nans (), \"has nan\" ); return * this ; } const D & derived () const { return static_cast < const D &> ( * this ); } D & derived () { return const_cast < D &> ( static_cast < const VectorBase &> ( * this ). derived ()); } template < ArithmeticType Arg > void set ( Arg value ) { _data . fill ( static_cast < T > ( value )); } template < ArithmeticType Arg > void set_by_index ( size_t index , Arg value ) { DAKKU_CHECK ( 0 <= index && index < S , \"index out of range: {} >= {}\" , index , S ); _data [ index ] = static_cast < T > ( value ); } template < ArithmeticType ... Args , size_t ... Is > requires ( sizeof ...( Args ) == S ) void set ( std :: index_sequence < Is ... > , Args && ... args ) { ( set_by_index ( Is , std :: forward < Args > ( args )), ...); } template < ArithmeticType ... Args > requires ( sizeof ...( Args ) == S ) void set ( Args && ... args ) { set ( std :: index_sequence_for < Args ... > {}, std :: forward < Args > ( args )...); } template < ArithmeticType Other , typename OtherDerived > void set ( const VectorBase < Other , S , OtherDerived > & rhs ) { for ( size_t i = 0 ; i < S ; ++ i ) _data [ i ] = static_cast < T > ( rhs [ i ]); } const T & get ( size_t i ) const { DAKKU_CHECK ( 0 <= i && i < S , \"index out of range {} >= {}\" , i , S ); return _data [ i ]; } [[ nodiscard ]] size_t size () const { return S ; } [[ nodiscard ]] std :: string to_string () const { std :: string ret { \"[\" }; for ( size_t i = 0 ; i < _data . size (); ++ i ) { ret += std :: to_string ( _data [ i ]); if ( i + 1 != _data . size ()) ret += \", \" ; } return ret + \"]\" ; } [[ nodiscard ]] bool has_nans () const { return std :: any_of ( std :: begin ( _data ), std :: end ( _data ), []( T x ) { return isnan ( x ); }); } D clone () const { return D { derived ()}; } const T & operator []( size_t i ) const { return _data [ i ]; } T & operator []( size_t i ) { return const_cast < T &> ( static_cast < const VectorBase &> ( * this )[ i ]); } D & operator += ( const D & rhs ) { for ( size_t i = 0 ; i < S ; ++ i ) _data [ i ] += rhs [ i ]; return derived (); } template < ArithmeticType V > D & operator += ( V rhs ) { for ( size_t i = 0 ; i < S ; ++ i ) _data [ i ] += rhs ; return derived (); } D operator + ( const D & rhs ) const { D ret = derived (); ret += rhs ; return ret ; } template < ArithmeticType V > D operator + ( V rhs ) const { D ret = derived (); ret += rhs ; return ret ; } template < ArithmeticType U > friend D operator + ( U a , const D & b ) { return b + a ; } D & operator -= ( const D & rhs ) { for ( size_t i = 0 ; i < S ; ++ i ) _data [ i ] -= rhs [ i ]; return derived (); } template < ArithmeticType V > D & operator -= ( V rhs ) { for ( size_t i = 0 ; i < S ; ++ i ) _data [ i ] -= rhs ; return derived (); } template < ArithmeticType U > friend D operator - ( U a , const D & b ) { D ret = - b ; ret += a ; return ret ; } D & operator *= ( const D & rhs ) { for ( size_t i = 0 ; i < S ; ++ i ) _data [ i ] *= rhs [ i ]; return derived (); } template < ArithmeticType V > D & operator *= ( V rhs ) { for ( size_t i = 0 ; i < S ; ++ i ) _data [ i ] *= rhs ; return derived (); } D operator * ( const D & rhs ) const { D ret = derived (); ret *= rhs ; return ret ; } template < ArithmeticType V > D operator * ( V rhs ) const { D ret = derived (); ret *= rhs ; return ret ; } template < ArithmeticType U > friend D operator * ( U a , const D & b ) { return b * a ; } D & operator /= ( const D & rhs ) { for ( size_t i = 0 ; i < S ; ++ i ) _data [ i ] /= rhs [ i ]; return derived (); } template < ArithmeticType V > D & operator /= ( V rhs ) { return derived () *= static_cast < T > ( T { 1 } / rhs ); } D operator / ( const D & rhs ) const { D ret = derived (); ret /= rhs ; return ret ; } template < ArithmeticType U > D operator / ( U rhs ) const { D ret = derived (); ret /= rhs ; return ret ; } template < ArithmeticType U > friend D operator / ( U a , const D & b ) { return D ( a ) / b ; } friend std :: ostream & operator << ( std :: ostream & os , const VectorBase & vec ) { return os << vec . to_string (); } bool operator == ( const VectorBase & rhs ) const { return _data == rhs . _data ; } bool operator != ( const VectorBase & rhs ) const { return _data != rhs . _data ; } decltype ( auto ) x () const { static_assert ( S >= 1 , \"not enough size to get x\" ); return _data [ 0 ]; } decltype ( auto ) x () { static_assert ( S >= 1 , \"not enough size to get x\" ); return _data [ 0 ]; } decltype ( auto ) y () const { static_assert ( S >= 2 , \"not enough size to get y\" ); return _data [ 1 ]; } decltype ( auto ) y () { static_assert ( S >= 2 , \"not enough size to get y\" ); return _data [ 1 ]; } decltype ( auto ) z () const { static_assert ( S >= 3 , \"not enough size to get z\" ); return _data [ 2 ]; } decltype ( auto ) z () { static_assert ( S >= 3 , \"not enough size to get w\" ); return _data [ 2 ]; } decltype ( auto ) w () const { static_assert ( S >= 4 , \"not enough size to get w\" ); return _data [ 3 ]; } decltype ( auto ) w () { static_assert ( S >= 4 , \"not enough size to get z\" ); return _data [ 3 ]; } [[ nodiscard ]] size_t max_element_index () const { return std :: distance ( _data . begin (), std :: max_element ( _data . begin (), _data . end ())); } decltype ( auto ) max_element () const { return _data [ max_element_index ()]; } friend D max ( const D & v1 , const D & v2 ) { D ret = v1 ; for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = std :: max ( ret [ i ], v2 [ i ]); return ret ; } D max ( const D & rhs ) const { return max ( derived (), rhs ); } friend D min ( const D & v1 , const D & v2 ) { D ret = v1 ; for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = std :: min ( ret [ i ], v2 [ i ]); return ret ; } D min ( const D & rhs ) const { return min ( derived (), rhs ); } template < typename OtherDerived > decltype ( auto ) dot ( const VectorBase < T , S , OtherDerived > & rhs ) const { return std :: inner_product ( _data . begin (), _data . end (), rhs . _data . begin (), T {}); } decltype ( auto ) squaredNorm () const { return this -> dot ( * this ); } decltype ( auto ) norm () const { return std :: sqrt ( squaredNorm ()); } decltype ( auto ) length () const { return norm (); } friend decltype ( auto ) distance ( const D & a , const D & b ) { return ( a - b ). length (); } decltype ( auto ) distance ( const D & rhs ) const { return distance ( derived (), rhs ); } friend D abs ( const D & v ) { D ret = v ; for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = std :: abs ( ret [ i ]); return ret ; } D abs () const { return abs ( derived ()); } D cross ( const D & rhs ) const { static_assert ( S == 3 , \"only 3d vector support cross product\" ); return D {( y () * rhs . z ()) - ( z () * rhs . y ()), ( z () * rhs . x ()) - ( x () * rhs . z ()), ( x () * rhs . y ()) - ( y () * rhs . x ())}; } [[ nodiscard ]] bool is_zero () const { return std :: all_of ( _data . begin (), _data . end (), []( const T & v ) { return v == 0 ; }); } friend D sqrt ( const D & v ) { D ret = v ; for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = static_cast < T > ( std :: sqrt ( ret [ i ])); return ret ; } D sqrt () const { return sqrt ( derived ()); } template < ArithmeticType E > friend D pow ( const D & v , E e ) { D ret = v ; for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = static_cast < T > ( std :: pow ( ret [ i ], e )); return ret ; } template < ArithmeticType E > D pow ( E e ) const { return pow ( derived (), e ); } friend D exp ( const D & v ) { D ret = v ; for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = static_cast < T > ( std :: exp ( ret [ i ])); return ret ; } D exp () const { return exp ( derived ()); } friend D floor ( const D & v ) { D ret = v ; for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = std :: floor ( ret [ i ]); return ret ; } D floor () const { return floor ( derived ()); } friend D ceil ( const D & v ) { D ret = v ; for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = std :: ceil ( ret [ i ]); return ret ; } D ceil () const { return ceil ( derived ()); } friend D lerp ( const D & a , const D & b , T t ) { D ret ; for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = std :: lerp ( a [ i ], b [ i ], t ); return ret ; } D lerp ( const D & b , T t ) const { return lerp ( derived (), b , t ); } operator std :: span < T , S > () { return std :: span { _data }; } operator std :: span < const T , S > () const { return std :: span { _data }; } private : std :: array < T , S > _data ; }; } // namespace dakku #endif Updated on 2022-04-25 at 11:08:31 +0000","title":"Source code"},{"location":"Modules/","text":"Modules Updated on 2022-04-25 at 11:08:31 +0000","title":"Modules"},{"location":"Modules/#modules","text":"Updated on 2022-04-25 at 11:08:31 +0000","title":"Modules"},{"location":"Namespaces/","text":"Namespaces namespace dakku dakku namespace Updated on 2022-04-25 at 11:08:31 +0000","title":"Namespaces"},{"location":"Namespaces/#namespaces","text":"namespace dakku dakku namespace Updated on 2022-04-25 at 11:08:31 +0000","title":"Namespaces"},{"location":"Namespaces/namespacedakku/","text":"dakku dakku namespace Classes Name class dakku::BoundsBase bounding box base class dakku::Logger logger class class dakku::Lua dakku lua state class dakku::Normal normal class dakku::Point point class dakku::Vector vector class dakku::VectorBase vector base Types Name using Vector < int, 2 > Vector2i using Vector < float, 2 > Vector2f using Vector < int, 3 > Vector3i using Vector < float, 3 > Vector3f using Point < float, 3 > Point3f using Point < int, 3 > Point3i using Point < float, 2 > Point2f using Point < int, 2 > Point2i using Normal < float, 3 > Normal3f Functions Name template <typename T > DAKKU_INLINE bool isnan (T x) check whether x is not a number template <typename T > DAKKU_INLINE bool isnan (T ) check whether x is not a number DAKKU_DECLARE_LUA_OBJECT ( Vector2i ) DAKKU_DECLARE_LUA_OBJECT ( Vector2f ) DAKKU_DECLARE_LUA_OBJECT ( Vector3i ) DAKKU_DECLARE_LUA_OBJECT ( Vector3f ) DAKKU_DECLARE_LUA_OBJECT ( Point3f ) DAKKU_DECLARE_LUA_OBJECT ( Point3i ) DAKKU_DECLARE_LUA_OBJECT ( Point2f ) DAKKU_DECLARE_LUA_OBJECT ( Point2i ) DAKKU_DECLARE_LUA_OBJECT ( Normal3f ) Types Documentation using Vector2i using dakku :: Vector2i = typedef Vector < int , 2 > ; using Vector2f using dakku :: Vector2f = typedef Vector < float , 2 > ; using Vector3i using dakku :: Vector3i = typedef Vector < int , 3 > ; using Vector3f using dakku :: Vector3f = typedef Vector < float , 3 > ; using Point3f using dakku :: Point3f = typedef Point < float , 3 > ; using Point3i using dakku :: Point3i = typedef Point < int , 3 > ; using Point2f using dakku :: Point2f = typedef Point < float , 2 > ; using Point2i using dakku :: Point2i = typedef Point < int , 2 > ; using Normal3f using dakku :: Normal3f = typedef Normal < float , 3 > ; Functions Documentation function isnan template < typename T > DAKKU_INLINE bool isnan ( T x ) check whether x is not a number Parameters : x given value Template Parameters : T type (floating point) Return : whether x is nan function isnan template < typename T > DAKKU_INLINE bool isnan ( T ) check whether x is not a number Template Parameters : T type (integer) Return : false (all integers are not nans) function DAKKU_DECLARE_LUA_OBJECT DAKKU_DECLARE_LUA_OBJECT ( Vector2i ) function DAKKU_DECLARE_LUA_OBJECT DAKKU_DECLARE_LUA_OBJECT ( Vector2f ) function DAKKU_DECLARE_LUA_OBJECT DAKKU_DECLARE_LUA_OBJECT ( Vector3i ) function DAKKU_DECLARE_LUA_OBJECT DAKKU_DECLARE_LUA_OBJECT ( Vector3f ) function DAKKU_DECLARE_LUA_OBJECT DAKKU_DECLARE_LUA_OBJECT ( Point3f ) function DAKKU_DECLARE_LUA_OBJECT DAKKU_DECLARE_LUA_OBJECT ( Point3i ) function DAKKU_DECLARE_LUA_OBJECT DAKKU_DECLARE_LUA_OBJECT ( Point2f ) function DAKKU_DECLARE_LUA_OBJECT DAKKU_DECLARE_LUA_OBJECT ( Point2i ) function DAKKU_DECLARE_LUA_OBJECT DAKKU_DECLARE_LUA_OBJECT ( Normal3f ) Updated on 2022-04-25 at 11:08:30 +0000","title":"dakku"},{"location":"Namespaces/namespacedakku/#dakku","text":"dakku namespace","title":"dakku"},{"location":"Namespaces/namespacedakku/#classes","text":"Name class dakku::BoundsBase bounding box base class dakku::Logger logger class class dakku::Lua dakku lua state class dakku::Normal normal class dakku::Point point class dakku::Vector vector class dakku::VectorBase vector base","title":"Classes"},{"location":"Namespaces/namespacedakku/#types","text":"Name using Vector < int, 2 > Vector2i using Vector < float, 2 > Vector2f using Vector < int, 3 > Vector3i using Vector < float, 3 > Vector3f using Point < float, 3 > Point3f using Point < int, 3 > Point3i using Point < float, 2 > Point2f using Point < int, 2 > Point2i using Normal < float, 3 > Normal3f","title":"Types"},{"location":"Namespaces/namespacedakku/#functions","text":"Name template <typename T > DAKKU_INLINE bool isnan (T x) check whether x is not a number template <typename T > DAKKU_INLINE bool isnan (T ) check whether x is not a number DAKKU_DECLARE_LUA_OBJECT ( Vector2i ) DAKKU_DECLARE_LUA_OBJECT ( Vector2f ) DAKKU_DECLARE_LUA_OBJECT ( Vector3i ) DAKKU_DECLARE_LUA_OBJECT ( Vector3f ) DAKKU_DECLARE_LUA_OBJECT ( Point3f ) DAKKU_DECLARE_LUA_OBJECT ( Point3i ) DAKKU_DECLARE_LUA_OBJECT ( Point2f ) DAKKU_DECLARE_LUA_OBJECT ( Point2i ) DAKKU_DECLARE_LUA_OBJECT ( Normal3f )","title":"Functions"},{"location":"Namespaces/namespacedakku/#types-documentation","text":"","title":"Types Documentation"},{"location":"Namespaces/namespacedakku/#using-vector2i","text":"using dakku :: Vector2i = typedef Vector < int , 2 > ;","title":"using Vector2i"},{"location":"Namespaces/namespacedakku/#using-vector2f","text":"using dakku :: Vector2f = typedef Vector < float , 2 > ;","title":"using Vector2f"},{"location":"Namespaces/namespacedakku/#using-vector3i","text":"using dakku :: Vector3i = typedef Vector < int , 3 > ;","title":"using Vector3i"},{"location":"Namespaces/namespacedakku/#using-vector3f","text":"using dakku :: Vector3f = typedef Vector < float , 3 > ;","title":"using Vector3f"},{"location":"Namespaces/namespacedakku/#using-point3f","text":"using dakku :: Point3f = typedef Point < float , 3 > ;","title":"using Point3f"},{"location":"Namespaces/namespacedakku/#using-point3i","text":"using dakku :: Point3i = typedef Point < int , 3 > ;","title":"using Point3i"},{"location":"Namespaces/namespacedakku/#using-point2f","text":"using dakku :: Point2f = typedef Point < float , 2 > ;","title":"using Point2f"},{"location":"Namespaces/namespacedakku/#using-point2i","text":"using dakku :: Point2i = typedef Point < int , 2 > ;","title":"using Point2i"},{"location":"Namespaces/namespacedakku/#using-normal3f","text":"using dakku :: Normal3f = typedef Normal < float , 3 > ;","title":"using Normal3f"},{"location":"Namespaces/namespacedakku/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Namespaces/namespacedakku/#function-isnan","text":"template < typename T > DAKKU_INLINE bool isnan ( T x ) check whether x is not a number Parameters : x given value Template Parameters : T type (floating point) Return : whether x is nan","title":"function isnan"},{"location":"Namespaces/namespacedakku/#function-isnan_1","text":"template < typename T > DAKKU_INLINE bool isnan ( T ) check whether x is not a number Template Parameters : T type (integer) Return : false (all integers are not nans)","title":"function isnan"},{"location":"Namespaces/namespacedakku/#function-dakku_declare_lua_object","text":"DAKKU_DECLARE_LUA_OBJECT ( Vector2i )","title":"function DAKKU_DECLARE_LUA_OBJECT"},{"location":"Namespaces/namespacedakku/#function-dakku_declare_lua_object_1","text":"DAKKU_DECLARE_LUA_OBJECT ( Vector2f )","title":"function DAKKU_DECLARE_LUA_OBJECT"},{"location":"Namespaces/namespacedakku/#function-dakku_declare_lua_object_2","text":"DAKKU_DECLARE_LUA_OBJECT ( Vector3i )","title":"function DAKKU_DECLARE_LUA_OBJECT"},{"location":"Namespaces/namespacedakku/#function-dakku_declare_lua_object_3","text":"DAKKU_DECLARE_LUA_OBJECT ( Vector3f )","title":"function DAKKU_DECLARE_LUA_OBJECT"},{"location":"Namespaces/namespacedakku/#function-dakku_declare_lua_object_4","text":"DAKKU_DECLARE_LUA_OBJECT ( Point3f )","title":"function DAKKU_DECLARE_LUA_OBJECT"},{"location":"Namespaces/namespacedakku/#function-dakku_declare_lua_object_5","text":"DAKKU_DECLARE_LUA_OBJECT ( Point3i )","title":"function DAKKU_DECLARE_LUA_OBJECT"},{"location":"Namespaces/namespacedakku/#function-dakku_declare_lua_object_6","text":"DAKKU_DECLARE_LUA_OBJECT ( Point2f )","title":"function DAKKU_DECLARE_LUA_OBJECT"},{"location":"Namespaces/namespacedakku/#function-dakku_declare_lua_object_7","text":"DAKKU_DECLARE_LUA_OBJECT ( Point2i )","title":"function DAKKU_DECLARE_LUA_OBJECT"},{"location":"Namespaces/namespacedakku/#function-dakku_declare_lua_object_8","text":"DAKKU_DECLARE_LUA_OBJECT ( Normal3f ) Updated on 2022-04-25 at 11:08:30 +0000","title":"function DAKKU_DECLARE_LUA_OBJECT"},{"location":"Pages/","text":"Pages page dakku documentation Updated on 2022-04-25 at 11:08:31 +0000","title":"Pages"},{"location":"Pages/#pages","text":"page dakku documentation Updated on 2022-04-25 at 11:08:31 +0000","title":"Pages"}]}