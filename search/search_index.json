{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"dakku documentation This is the documentation of dakku renderer. Vector Base Updated on 2022-04-11 at 15:27:24 +0000","title":"dakku documentation"},{"location":"#dakku-documentation","text":"This is the documentation of dakku renderer. Vector Base Updated on 2022-04-11 at 15:27:24 +0000","title":"dakku documentation"},{"location":"Classes/","text":"Classes namespace dakku dakku namespace class BlockedArray blocked array \\(s \\times s\\) elements are layout together (linear), where \\(s\\) is the block size, then block by block linear layout block size \\(s\\) is power of \\(2\\) This improves the performance for looking up nearby elements (for texture) class Bounds2 2d bounding box class Bounds2iIterator 2d integer bounds iterator, iterate all pixels inside class Bounds3 3d bounding box class BoundsBase bounding box base class BoxFilter box filter the box filter is simple, just return \\(1\\) for all values class Class RTTI support. struct Metadata class CoefficientSpectrum coefficient spectrum class ConstantTexture class FileInputStream file input stream class FileOutputStream file output stream class Film film class struct Pixel pixel struct class FilmImageProvider class FilmTile film tile struct FilmTilePixel film tile pixel class Filter filter class all filters are centered at origin \\((0, 0)\\) and defined a radius beyond which they have a value of \\(0\\) this width may be different in the \\(x\\) and \\(y\\) directions class GuiEngine class ImageTexture class InputStream input stream struct Interaction interaction class L1CacheLineAlignedResource memory resource that at least aligned with L1 cache line size class Logger logger class struct Matrix4x4 4x4 matrix class MemoryArena memory arena class MipMap mipmap class class Normal normal class Object Object class, RTTI support. class OutputStream output stream class Point point class Property property class, containing many data types, similar to json class Ray ray class RayDifferential differential ray class RelativeRoot utility to retrieve relative path (used for scene loading and saving) struct ResampleWeight resample weight of the four nearby (continuous) texels class RgbSpectrum spectrum that only use r, g, b class SerializableObject serializable object class Shape class SurfaceInteraction surface interaction class Texture class TextureMapping2D 2d texture mapping class Transform class TriangleFilter triangle filter the weight falls off linearly from the filter center over the square extent of the filter class UvMapping2D class Vector vector class VectorBase vector base class namespace std namespace pmr Updated on 2022-04-11 at 15:27:24 +0000","title":"Classes"},{"location":"Classes/#classes","text":"namespace dakku dakku namespace class BlockedArray blocked array \\(s \\times s\\) elements are layout together (linear), where \\(s\\) is the block size, then block by block linear layout block size \\(s\\) is power of \\(2\\) This improves the performance for looking up nearby elements (for texture) class Bounds2 2d bounding box class Bounds2iIterator 2d integer bounds iterator, iterate all pixels inside class Bounds3 3d bounding box class BoundsBase bounding box base class BoxFilter box filter the box filter is simple, just return \\(1\\) for all values class Class RTTI support. struct Metadata class CoefficientSpectrum coefficient spectrum class ConstantTexture class FileInputStream file input stream class FileOutputStream file output stream class Film film class struct Pixel pixel struct class FilmImageProvider class FilmTile film tile struct FilmTilePixel film tile pixel class Filter filter class all filters are centered at origin \\((0, 0)\\) and defined a radius beyond which they have a value of \\(0\\) this width may be different in the \\(x\\) and \\(y\\) directions class GuiEngine class ImageTexture class InputStream input stream struct Interaction interaction class L1CacheLineAlignedResource memory resource that at least aligned with L1 cache line size class Logger logger class struct Matrix4x4 4x4 matrix class MemoryArena memory arena class MipMap mipmap class class Normal normal class Object Object class, RTTI support. class OutputStream output stream class Point point class Property property class, containing many data types, similar to json class Ray ray class RayDifferential differential ray class RelativeRoot utility to retrieve relative path (used for scene loading and saving) struct ResampleWeight resample weight of the four nearby (continuous) texels class RgbSpectrum spectrum that only use r, g, b class SerializableObject serializable object class Shape class SurfaceInteraction surface interaction class Texture class TextureMapping2D 2d texture mapping class Transform class TriangleFilter triangle filter the weight falls off linearly from the filter center over the square extent of the filter class UvMapping2D class Vector vector class VectorBase vector base class namespace std namespace pmr Updated on 2022-04-11 at 15:27:24 +0000","title":"Classes"},{"location":"Classes/classdakku_1_1BlockedArray/","text":"dakku::BlockedArray blocked array \\(s \\times s\\) elements are layout together (linear), where \\(s\\) is the block size, then block by block linear layout block size \\(s\\) is power of \\(2\\) This improves the performance for looking up nearby elements (for texture) More... #include <blocked_array.h> Public Functions Name BlockedArray (int uRes, int vRes, std::span< const T > d ={}) Construct a new Blocked Array object. ~BlockedArray () int blockIdx (int i) const get block idx for a index int offset (int i) const get the offset within a block for a lookup index constexpr int blockSize () const get block size int roundUp (int x) const the round up size, the smallest multiples of block size >= x int uSize () const int vSize () const const T & operator() (int u, int v) const lookup data T & operator() (int u, int v) lookup data void toLinearArray (std::span< T > a) to linear array Detailed Description template < typename T , int logBlockSize = 2 > class dakku :: BlockedArray ; blocked array \\(s \\times s\\) elements are layout together (linear), where \\(s\\) is the block size, then block by block linear layout block size \\(s\\) is power of \\(2\\) This improves the performance for looking up nearby elements (for texture) Template Parameters : T data type logBlockSize \\(\\log s\\) where \\(s\\) is the block size Public Functions Documentation function BlockedArray inline explicit BlockedArray ( int uRes , int vRes , std :: span < const T > d = {} ) Construct a new Blocked Array object. Parameters : uRes u resolution (width) vRes v resolution (height) d data function ~BlockedArray inline ~ BlockedArray () function blockIdx inline int blockIdx ( int i ) const get block idx for a index Parameters : i the lookup index Return : (i / block size) function offset inline int offset ( int i ) const get the offset within a block for a lookup index Parameters : i the lookup index Return : (i % block size) function blockSize inline constexpr int blockSize () const get block size function roundUp inline int roundUp ( int x ) const the round up size, the smallest multiples of block size >= x Parameters : x the requested size Return : the round up size function uSize inline int uSize () const function vSize inline int vSize () const function operator() inline const T & operator ()( int u , int v ) const lookup data function operator() inline T & operator ()( int u , int v ) lookup data function toLinearArray inline void toLinearArray ( std :: span < T > a ) to linear array Updated on 2022-04-11 at 15:27:23 +0000","title":"dakku::BlockedArray"},{"location":"Classes/classdakku_1_1BlockedArray/#dakkublockedarray","text":"blocked array \\(s \\times s\\) elements are layout together (linear), where \\(s\\) is the block size, then block by block linear layout block size \\(s\\) is power of \\(2\\) This improves the performance for looking up nearby elements (for texture) More... #include <blocked_array.h>","title":"dakku::BlockedArray"},{"location":"Classes/classdakku_1_1BlockedArray/#public-functions","text":"Name BlockedArray (int uRes, int vRes, std::span< const T > d ={}) Construct a new Blocked Array object. ~BlockedArray () int blockIdx (int i) const get block idx for a index int offset (int i) const get the offset within a block for a lookup index constexpr int blockSize () const get block size int roundUp (int x) const the round up size, the smallest multiples of block size >= x int uSize () const int vSize () const const T & operator() (int u, int v) const lookup data T & operator() (int u, int v) lookup data void toLinearArray (std::span< T > a) to linear array","title":"Public Functions"},{"location":"Classes/classdakku_1_1BlockedArray/#detailed-description","text":"template < typename T , int logBlockSize = 2 > class dakku :: BlockedArray ; blocked array \\(s \\times s\\) elements are layout together (linear), where \\(s\\) is the block size, then block by block linear layout block size \\(s\\) is power of \\(2\\) This improves the performance for looking up nearby elements (for texture) Template Parameters : T data type logBlockSize \\(\\log s\\) where \\(s\\) is the block size","title":"Detailed Description"},{"location":"Classes/classdakku_1_1BlockedArray/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Classes/classdakku_1_1BlockedArray/#function-blockedarray","text":"inline explicit BlockedArray ( int uRes , int vRes , std :: span < const T > d = {} ) Construct a new Blocked Array object. Parameters : uRes u resolution (width) vRes v resolution (height) d data","title":"function BlockedArray"},{"location":"Classes/classdakku_1_1BlockedArray/#function-blockedarray_1","text":"inline ~ BlockedArray ()","title":"function ~BlockedArray"},{"location":"Classes/classdakku_1_1BlockedArray/#function-blockidx","text":"inline int blockIdx ( int i ) const get block idx for a index Parameters : i the lookup index Return : (i / block size)","title":"function blockIdx"},{"location":"Classes/classdakku_1_1BlockedArray/#function-offset","text":"inline int offset ( int i ) const get the offset within a block for a lookup index Parameters : i the lookup index Return : (i % block size)","title":"function offset"},{"location":"Classes/classdakku_1_1BlockedArray/#function-blocksize","text":"inline constexpr int blockSize () const get block size","title":"function blockSize"},{"location":"Classes/classdakku_1_1BlockedArray/#function-roundup","text":"inline int roundUp ( int x ) const the round up size, the smallest multiples of block size >= x Parameters : x the requested size Return : the round up size","title":"function roundUp"},{"location":"Classes/classdakku_1_1BlockedArray/#function-usize","text":"inline int uSize () const","title":"function uSize"},{"location":"Classes/classdakku_1_1BlockedArray/#function-vsize","text":"inline int vSize () const","title":"function vSize"},{"location":"Classes/classdakku_1_1BlockedArray/#function-operator","text":"inline const T & operator ()( int u , int v ) const lookup data","title":"function operator()"},{"location":"Classes/classdakku_1_1BlockedArray/#function-operator_1","text":"inline T & operator ()( int u , int v ) lookup data","title":"function operator()"},{"location":"Classes/classdakku_1_1BlockedArray/#function-tolineararray","text":"inline void toLinearArray ( std :: span < T > a ) to linear array Updated on 2022-04-11 at 15:27:23 +0000","title":"function toLinearArray"},{"location":"Classes/classdakku_1_1Bounds2/","text":"dakku::Bounds2 2d bounding box More... #include <bounds.h> Inherits from dakku::BoundsBase< T, 2 > Public Functions Name Bounds2 (const BoundsBase < T, 2 > & base) decltype(auto) area () const get the area of bounds Additional inherited members Public Functions inherited from dakku::BoundsBase< T, 2 > Name BoundsBase () =default default constructor BoundsBase (const Point < T, S > & p) Construct a new Bounds2 with a point. template <ArithmeticType U> BoundsBase (const BoundsBase < U, S > & b) type conversion BoundsBase (const Point < T, S > & p1, const Point < T, S > & p2) Construct a new Bounds Base object with two points (take min/max of them to pMin and pMax) Vector < T, S > diagonal () const get the diagonal of the bounding box size_t maxExtent () const get the dimension who has the maximum extent bool operator== (const BoundsBase & rhs) const bool operator!= (const BoundsBase & rhs) const Point < T, S > lerp (const Point < float, S > & t) const linera interpolation between pMin and pMax Vector < T, S > offset (const Point < T, S > & p) const get the offset \\(v\\) of a point, p = o + v * d void boundingSphere ( Point < T, S > & center, float & rad) get the bounding sphere of the bounds std::string toString () const Public Attributes inherited from dakku::BoundsBase< T, 2 > Name Point < T, S > pMin left bottom corner of the bounds Point < T, S > pMax right top corner of the bounds Friends inherited from dakku::BoundsBase< T, 2 > Name bool overlaps (const BoundsBase & a, const BoundsBase & b) check whether two bounds overlaps bool inside (const Point < T, S > & p, const BoundsBase & b) check whether point is inside the bounds (exclusive) bool insideExclusive (const Point < T, S > & p, const BoundsBase & b) check whether point is inside the bounds (inclusive) decltype(auto) distanceSquared (const Point < T, S > & p, const BoundsBase & b) minimum squared distance between point and bounds, if inside return 0 decltype(auto) distance (const Point < T, S > & p, const BoundsBase & b) minimum distance between point and bounds, if inside return 0 BoundsBase **[operator BoundsBase **[operator BoundsBase operator& (const BoundsBase & a, const BoundsBase & b) take the intersect between two bounds std::ostream & operator<< (std::ostream & os, const BoundsBase & b) Detailed Description template < ArithmeticType T > class dakku :: Bounds2 ; 2d bounding box Public Functions Documentation function Bounds2 inline Bounds2 ( const BoundsBase < T , 2 > & base ) function area inline decltype ( auto ) area () const get the area of bounds Return : the area Updated on 2022-04-11 at 15:27:23 +0000","title":"dakku::Bounds2"},{"location":"Classes/classdakku_1_1Bounds2/#dakkubounds2","text":"2d bounding box More... #include <bounds.h> Inherits from dakku::BoundsBase< T, 2 >","title":"dakku::Bounds2"},{"location":"Classes/classdakku_1_1Bounds2/#public-functions","text":"Name Bounds2 (const BoundsBase < T, 2 > & base) decltype(auto) area () const get the area of bounds","title":"Public Functions"},{"location":"Classes/classdakku_1_1Bounds2/#additional-inherited-members","text":"Public Functions inherited from dakku::BoundsBase< T, 2 > Name BoundsBase () =default default constructor BoundsBase (const Point < T, S > & p) Construct a new Bounds2 with a point. template <ArithmeticType U> BoundsBase (const BoundsBase < U, S > & b) type conversion BoundsBase (const Point < T, S > & p1, const Point < T, S > & p2) Construct a new Bounds Base object with two points (take min/max of them to pMin and pMax) Vector < T, S > diagonal () const get the diagonal of the bounding box size_t maxExtent () const get the dimension who has the maximum extent bool operator== (const BoundsBase & rhs) const bool operator!= (const BoundsBase & rhs) const Point < T, S > lerp (const Point < float, S > & t) const linera interpolation between pMin and pMax Vector < T, S > offset (const Point < T, S > & p) const get the offset \\(v\\) of a point, p = o + v * d void boundingSphere ( Point < T, S > & center, float & rad) get the bounding sphere of the bounds std::string toString () const Public Attributes inherited from dakku::BoundsBase< T, 2 > Name Point < T, S > pMin left bottom corner of the bounds Point < T, S > pMax right top corner of the bounds Friends inherited from dakku::BoundsBase< T, 2 > Name bool overlaps (const BoundsBase & a, const BoundsBase & b) check whether two bounds overlaps bool inside (const Point < T, S > & p, const BoundsBase & b) check whether point is inside the bounds (exclusive) bool insideExclusive (const Point < T, S > & p, const BoundsBase & b) check whether point is inside the bounds (inclusive) decltype(auto) distanceSquared (const Point < T, S > & p, const BoundsBase & b) minimum squared distance between point and bounds, if inside return 0 decltype(auto) distance (const Point < T, S > & p, const BoundsBase & b) minimum distance between point and bounds, if inside return 0 BoundsBase **[operator BoundsBase **[operator BoundsBase operator& (const BoundsBase & a, const BoundsBase & b) take the intersect between two bounds std::ostream & operator<< (std::ostream & os, const BoundsBase & b)","title":"Additional inherited members"},{"location":"Classes/classdakku_1_1Bounds2/#detailed-description","text":"template < ArithmeticType T > class dakku :: Bounds2 ; 2d bounding box","title":"Detailed Description"},{"location":"Classes/classdakku_1_1Bounds2/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Classes/classdakku_1_1Bounds2/#function-bounds2","text":"inline Bounds2 ( const BoundsBase < T , 2 > & base )","title":"function Bounds2"},{"location":"Classes/classdakku_1_1Bounds2/#function-area","text":"inline decltype ( auto ) area () const get the area of bounds Return : the area Updated on 2022-04-11 at 15:27:23 +0000","title":"function area"},{"location":"Classes/classdakku_1_1Bounds2iIterator/","text":"dakku::Bounds2iIterator 2d integer bounds iterator, iterate all pixels inside #include <bounds.h> Inherits from std::forward_iterator_tag Public Functions Name Bounds2iIterator (const Bounds2i & b, Point2i p) Bounds2iIterator operator++ () Bounds2iIterator operator++ (int ) bool operator== (const Bounds2iIterator & rhs) const bool operator!= (const Bounds2iIterator & rhs) const Point2i operator* () const Public Functions Documentation function Bounds2iIterator inline explicit Bounds2iIterator ( const Bounds2i & b , Point2i p ) function operator++ inline Bounds2iIterator operator ++ () function operator++ inline Bounds2iIterator operator ++ ( int ) function operator== inline bool operator == ( const Bounds2iIterator & rhs ) const function operator!= inline bool operator != ( const Bounds2iIterator & rhs ) const function operator* inline Point2i operator * () const Updated on 2022-04-11 at 15:27:23 +0000","title":"dakku::Bounds2iIterator"},{"location":"Classes/classdakku_1_1Bounds2iIterator/#dakkubounds2iiterator","text":"2d integer bounds iterator, iterate all pixels inside #include <bounds.h> Inherits from std::forward_iterator_tag","title":"dakku::Bounds2iIterator"},{"location":"Classes/classdakku_1_1Bounds2iIterator/#public-functions","text":"Name Bounds2iIterator (const Bounds2i & b, Point2i p) Bounds2iIterator operator++ () Bounds2iIterator operator++ (int ) bool operator== (const Bounds2iIterator & rhs) const bool operator!= (const Bounds2iIterator & rhs) const Point2i operator* () const","title":"Public Functions"},{"location":"Classes/classdakku_1_1Bounds2iIterator/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Classes/classdakku_1_1Bounds2iIterator/#function-bounds2iiterator","text":"inline explicit Bounds2iIterator ( const Bounds2i & b , Point2i p )","title":"function Bounds2iIterator"},{"location":"Classes/classdakku_1_1Bounds2iIterator/#function-operator","text":"inline Bounds2iIterator operator ++ ()","title":"function operator++"},{"location":"Classes/classdakku_1_1Bounds2iIterator/#function-operator_1","text":"inline Bounds2iIterator operator ++ ( int )","title":"function operator++"},{"location":"Classes/classdakku_1_1Bounds2iIterator/#function-operator_2","text":"inline bool operator == ( const Bounds2iIterator & rhs ) const","title":"function operator=="},{"location":"Classes/classdakku_1_1Bounds2iIterator/#function-operator_3","text":"inline bool operator != ( const Bounds2iIterator & rhs ) const","title":"function operator!="},{"location":"Classes/classdakku_1_1Bounds2iIterator/#function-operator_4","text":"inline Point2i operator * () const Updated on 2022-04-11 at 15:27:23 +0000","title":"function operator*"},{"location":"Classes/classdakku_1_1Bounds3/","text":"dakku::Bounds3 3d bounding box More... #include <bounds.h> Inherits from dakku::BoundsBase< T, 3 > Public Functions Name Bounds3 (const BoundsBase < T, 3 > & base) Additional inherited members Public Functions inherited from dakku::BoundsBase< T, 3 > Name BoundsBase () =default default constructor BoundsBase (const Point < T, S > & p) Construct a new Bounds2 with a point. template <ArithmeticType U> BoundsBase (const BoundsBase < U, S > & b) type conversion BoundsBase (const Point < T, S > & p1, const Point < T, S > & p2) Construct a new Bounds Base object with two points (take min/max of them to pMin and pMax) Vector < T, S > diagonal () const get the diagonal of the bounding box size_t maxExtent () const get the dimension who has the maximum extent bool operator== (const BoundsBase & rhs) const bool operator!= (const BoundsBase & rhs) const Point < T, S > lerp (const Point < float, S > & t) const linera interpolation between pMin and pMax Vector < T, S > offset (const Point < T, S > & p) const get the offset \\(v\\) of a point, p = o + v * d void boundingSphere ( Point < T, S > & center, float & rad) get the bounding sphere of the bounds std::string toString () const Public Attributes inherited from dakku::BoundsBase< T, 3 > Name Point < T, S > pMin left bottom corner of the bounds Point < T, S > pMax right top corner of the bounds Friends inherited from dakku::BoundsBase< T, 3 > Name bool overlaps (const BoundsBase & a, const BoundsBase & b) check whether two bounds overlaps bool inside (const Point < T, S > & p, const BoundsBase & b) check whether point is inside the bounds (exclusive) bool insideExclusive (const Point < T, S > & p, const BoundsBase & b) check whether point is inside the bounds (inclusive) decltype(auto) distanceSquared (const Point < T, S > & p, const BoundsBase & b) minimum squared distance between point and bounds, if inside return 0 decltype(auto) distance (const Point < T, S > & p, const BoundsBase & b) minimum distance between point and bounds, if inside return 0 BoundsBase **[operator BoundsBase **[operator BoundsBase operator& (const BoundsBase & a, const BoundsBase & b) take the intersect between two bounds std::ostream & operator<< (std::ostream & os, const BoundsBase & b) Detailed Description template < ArithmeticType T > class dakku :: Bounds3 ; 3d bounding box Public Functions Documentation function Bounds3 inline Bounds3 ( const BoundsBase < T , 3 > & base ) Updated on 2022-04-11 at 15:27:23 +0000","title":"dakku::Bounds3"},{"location":"Classes/classdakku_1_1Bounds3/#dakkubounds3","text":"3d bounding box More... #include <bounds.h> Inherits from dakku::BoundsBase< T, 3 >","title":"dakku::Bounds3"},{"location":"Classes/classdakku_1_1Bounds3/#public-functions","text":"Name Bounds3 (const BoundsBase < T, 3 > & base)","title":"Public Functions"},{"location":"Classes/classdakku_1_1Bounds3/#additional-inherited-members","text":"Public Functions inherited from dakku::BoundsBase< T, 3 > Name BoundsBase () =default default constructor BoundsBase (const Point < T, S > & p) Construct a new Bounds2 with a point. template <ArithmeticType U> BoundsBase (const BoundsBase < U, S > & b) type conversion BoundsBase (const Point < T, S > & p1, const Point < T, S > & p2) Construct a new Bounds Base object with two points (take min/max of them to pMin and pMax) Vector < T, S > diagonal () const get the diagonal of the bounding box size_t maxExtent () const get the dimension who has the maximum extent bool operator== (const BoundsBase & rhs) const bool operator!= (const BoundsBase & rhs) const Point < T, S > lerp (const Point < float, S > & t) const linera interpolation between pMin and pMax Vector < T, S > offset (const Point < T, S > & p) const get the offset \\(v\\) of a point, p = o + v * d void boundingSphere ( Point < T, S > & center, float & rad) get the bounding sphere of the bounds std::string toString () const Public Attributes inherited from dakku::BoundsBase< T, 3 > Name Point < T, S > pMin left bottom corner of the bounds Point < T, S > pMax right top corner of the bounds Friends inherited from dakku::BoundsBase< T, 3 > Name bool overlaps (const BoundsBase & a, const BoundsBase & b) check whether two bounds overlaps bool inside (const Point < T, S > & p, const BoundsBase & b) check whether point is inside the bounds (exclusive) bool insideExclusive (const Point < T, S > & p, const BoundsBase & b) check whether point is inside the bounds (inclusive) decltype(auto) distanceSquared (const Point < T, S > & p, const BoundsBase & b) minimum squared distance between point and bounds, if inside return 0 decltype(auto) distance (const Point < T, S > & p, const BoundsBase & b) minimum distance between point and bounds, if inside return 0 BoundsBase **[operator BoundsBase **[operator BoundsBase operator& (const BoundsBase & a, const BoundsBase & b) take the intersect between two bounds std::ostream & operator<< (std::ostream & os, const BoundsBase & b)","title":"Additional inherited members"},{"location":"Classes/classdakku_1_1Bounds3/#detailed-description","text":"template < ArithmeticType T > class dakku :: Bounds3 ; 3d bounding box","title":"Detailed Description"},{"location":"Classes/classdakku_1_1Bounds3/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Classes/classdakku_1_1Bounds3/#function-bounds3","text":"inline Bounds3 ( const BoundsBase < T , 3 > & base ) Updated on 2022-04-11 at 15:27:23 +0000","title":"function Bounds3"},{"location":"Classes/classdakku_1_1BoundsBase/","text":"dakku::BoundsBase bounding box base More... #include <bounds.h> Public Functions Name BoundsBase () =default default constructor BoundsBase (const Point < T, S > & p) Construct a new Bounds2 with a point. template <ArithmeticType U> BoundsBase (const BoundsBase < U, S > & b) type conversion BoundsBase (const Point < T, S > & p1, const Point < T, S > & p2) Construct a new Bounds Base object with two points (take min/max of them to pMin and pMax) Vector < T, S > diagonal () const get the diagonal of the bounding box size_t maxExtent () const get the dimension who has the maximum extent bool operator== (const BoundsBase & rhs) const bool operator!= (const BoundsBase & rhs) const Point < T, S > lerp (const Point < float, S > & t) const linera interpolation between pMin and pMax Vector < T, S > offset (const Point < T, S > & p) const get the offset \\(v\\) of a point, p = o + v * d void boundingSphere ( Point < T, S > & center, float & rad) get the bounding sphere of the bounds std::string toString () const Public Attributes Name Point < T, S > pMin left bottom corner of the bounds Point < T, S > pMax right top corner of the bounds Friends Name bool overlaps (const BoundsBase & a, const BoundsBase & b) check whether two bounds overlaps bool inside (const Point < T, S > & p, const BoundsBase & b) check whether point is inside the bounds (exclusive) bool insideExclusive (const Point < T, S > & p, const BoundsBase & b) check whether point is inside the bounds (inclusive) decltype(auto) distanceSquared (const Point < T, S > & p, const BoundsBase & b) minimum squared distance between point and bounds, if inside return 0 decltype(auto) distance (const Point < T, S > & p, const BoundsBase & b) minimum distance between point and bounds, if inside return 0 BoundsBase **[operator BoundsBase **[operator BoundsBase operator& (const BoundsBase & a, const BoundsBase & b) take the intersect between two bounds std::ostream & operator<< (std::ostream & os, const BoundsBase & b) Detailed Description template < ArithmeticType T , size_t S > class dakku :: BoundsBase ; bounding box base Template Parameters : T data type S dimension Public Functions Documentation function BoundsBase BoundsBase () = default default constructor function BoundsBase inline explicit BoundsBase ( const Point < T , S > & p ) Construct a new Bounds2 with a point. Parameters : p the given point function BoundsBase template < ArithmeticType U > inline explicit BoundsBase ( const BoundsBase < U , S > & b ) type conversion function BoundsBase inline BoundsBase ( const Point < T , S > & p1 , const Point < T , S > & p2 ) Construct a new Bounds Base object with two points (take min/max of them to pMin and pMax) function diagonal inline Vector < T , S > diagonal () const get the diagonal of the bounding box function maxExtent inline size_t maxExtent () const get the dimension who has the maximum extent Return : the dimension function operator== inline bool operator == ( const BoundsBase & rhs ) const function operator!= inline bool operator != ( const BoundsBase & rhs ) const function lerp inline Point < T , S > lerp ( const Point < float , S > & t ) const linera interpolation between pMin and pMax Parameters : t interpolate \\(t\\) (element wise) function offset inline Vector < T , S > offset ( const Point < T , S > & p ) const get the offset \\(v\\) of a point, p = o + v * d Parameters : p the point Return : the offset function boundingSphere inline void boundingSphere ( Point < T , S > & center , float & rad ) get the bounding sphere of the bounds Parameters : center the center of the sphere rad the radius of the sphere function toString inline std :: string toString () const Public Attributes Documentation variable pMin Point < T , S > pMin { std :: numeric_limits < T >:: max ()}; left bottom corner of the bounds variable pMax Point < T , S > pMax { std :: numeric_limits < T >:: lowest ()}; right top corner of the bounds Friends friend overlaps friend bool overlaps ( const BoundsBase & a , const BoundsBase & b ); check whether two bounds overlaps friend inside friend bool inside ( const Point < T , S > & p , const BoundsBase & b ); check whether point is inside the bounds (exclusive) Parameters : p the point b the bounds friend insideExclusive friend bool insideExclusive ( const Point < T , S > & p , const BoundsBase & b ); check whether point is inside the bounds (inclusive) Parameters : p the point b the bounds friend distanceSquared friend decltype ( auto ) distanceSquared ( const Point < T , S > & p , const BoundsBase & b ); minimum squared distance between point and bounds, if inside return 0 Parameters : p the point b the bounds Return : the squared distance friend distance friend decltype ( auto ) distance ( const Point < T , S > & p , const BoundsBase & b ); minimum distance between point and bounds, if inside return 0 Parameters : p the point b the bounds Return : the distance friend operator| friend BoundsBase operator | ( const BoundsBase & a , const BoundsBase & b ); take the union of the two bounds friend operator| friend BoundsBase operator | ( const BoundsBase & b , const Point < T , S > & p ); take the union between bounds and a point friend operator& friend BoundsBase operator & ( const BoundsBase & a , const BoundsBase & b ); take the intersect between two bounds friend operator<< friend std :: ostream & operator << ( std :: ostream & os , const BoundsBase & b ); Updated on 2022-04-11 at 15:27:23 +0000","title":"dakku::BoundsBase"},{"location":"Classes/classdakku_1_1BoundsBase/#dakkuboundsbase","text":"bounding box base More... #include <bounds.h>","title":"dakku::BoundsBase"},{"location":"Classes/classdakku_1_1BoundsBase/#public-functions","text":"Name BoundsBase () =default default constructor BoundsBase (const Point < T, S > & p) Construct a new Bounds2 with a point. template <ArithmeticType U> BoundsBase (const BoundsBase < U, S > & b) type conversion BoundsBase (const Point < T, S > & p1, const Point < T, S > & p2) Construct a new Bounds Base object with two points (take min/max of them to pMin and pMax) Vector < T, S > diagonal () const get the diagonal of the bounding box size_t maxExtent () const get the dimension who has the maximum extent bool operator== (const BoundsBase & rhs) const bool operator!= (const BoundsBase & rhs) const Point < T, S > lerp (const Point < float, S > & t) const linera interpolation between pMin and pMax Vector < T, S > offset (const Point < T, S > & p) const get the offset \\(v\\) of a point, p = o + v * d void boundingSphere ( Point < T, S > & center, float & rad) get the bounding sphere of the bounds std::string toString () const","title":"Public Functions"},{"location":"Classes/classdakku_1_1BoundsBase/#public-attributes","text":"Name Point < T, S > pMin left bottom corner of the bounds Point < T, S > pMax right top corner of the bounds","title":"Public Attributes"},{"location":"Classes/classdakku_1_1BoundsBase/#friends","text":"Name bool overlaps (const BoundsBase & a, const BoundsBase & b) check whether two bounds overlaps bool inside (const Point < T, S > & p, const BoundsBase & b) check whether point is inside the bounds (exclusive) bool insideExclusive (const Point < T, S > & p, const BoundsBase & b) check whether point is inside the bounds (inclusive) decltype(auto) distanceSquared (const Point < T, S > & p, const BoundsBase & b) minimum squared distance between point and bounds, if inside return 0 decltype(auto) distance (const Point < T, S > & p, const BoundsBase & b) minimum distance between point and bounds, if inside return 0 BoundsBase **[operator BoundsBase **[operator BoundsBase operator& (const BoundsBase & a, const BoundsBase & b) take the intersect between two bounds std::ostream & operator<< (std::ostream & os, const BoundsBase & b)","title":"Friends"},{"location":"Classes/classdakku_1_1BoundsBase/#detailed-description","text":"template < ArithmeticType T , size_t S > class dakku :: BoundsBase ; bounding box base Template Parameters : T data type S dimension","title":"Detailed Description"},{"location":"Classes/classdakku_1_1BoundsBase/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Classes/classdakku_1_1BoundsBase/#function-boundsbase","text":"BoundsBase () = default default constructor","title":"function BoundsBase"},{"location":"Classes/classdakku_1_1BoundsBase/#function-boundsbase_1","text":"inline explicit BoundsBase ( const Point < T , S > & p ) Construct a new Bounds2 with a point. Parameters : p the given point","title":"function BoundsBase"},{"location":"Classes/classdakku_1_1BoundsBase/#function-boundsbase_2","text":"template < ArithmeticType U > inline explicit BoundsBase ( const BoundsBase < U , S > & b ) type conversion","title":"function BoundsBase"},{"location":"Classes/classdakku_1_1BoundsBase/#function-boundsbase_3","text":"inline BoundsBase ( const Point < T , S > & p1 , const Point < T , S > & p2 ) Construct a new Bounds Base object with two points (take min/max of them to pMin and pMax)","title":"function BoundsBase"},{"location":"Classes/classdakku_1_1BoundsBase/#function-diagonal","text":"inline Vector < T , S > diagonal () const get the diagonal of the bounding box","title":"function diagonal"},{"location":"Classes/classdakku_1_1BoundsBase/#function-maxextent","text":"inline size_t maxExtent () const get the dimension who has the maximum extent Return : the dimension","title":"function maxExtent"},{"location":"Classes/classdakku_1_1BoundsBase/#function-operator","text":"inline bool operator == ( const BoundsBase & rhs ) const","title":"function operator=="},{"location":"Classes/classdakku_1_1BoundsBase/#function-operator_1","text":"inline bool operator != ( const BoundsBase & rhs ) const","title":"function operator!="},{"location":"Classes/classdakku_1_1BoundsBase/#function-lerp","text":"inline Point < T , S > lerp ( const Point < float , S > & t ) const linera interpolation between pMin and pMax Parameters : t interpolate \\(t\\) (element wise)","title":"function lerp"},{"location":"Classes/classdakku_1_1BoundsBase/#function-offset","text":"inline Vector < T , S > offset ( const Point < T , S > & p ) const get the offset \\(v\\) of a point, p = o + v * d Parameters : p the point Return : the offset","title":"function offset"},{"location":"Classes/classdakku_1_1BoundsBase/#function-boundingsphere","text":"inline void boundingSphere ( Point < T , S > & center , float & rad ) get the bounding sphere of the bounds Parameters : center the center of the sphere rad the radius of the sphere","title":"function boundingSphere"},{"location":"Classes/classdakku_1_1BoundsBase/#function-tostring","text":"inline std :: string toString () const","title":"function toString"},{"location":"Classes/classdakku_1_1BoundsBase/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"Classes/classdakku_1_1BoundsBase/#variable-pmin","text":"Point < T , S > pMin { std :: numeric_limits < T >:: max ()}; left bottom corner of the bounds","title":"variable pMin"},{"location":"Classes/classdakku_1_1BoundsBase/#variable-pmax","text":"Point < T , S > pMax { std :: numeric_limits < T >:: lowest ()}; right top corner of the bounds","title":"variable pMax"},{"location":"Classes/classdakku_1_1BoundsBase/#friends_1","text":"","title":"Friends"},{"location":"Classes/classdakku_1_1BoundsBase/#friend-overlaps","text":"friend bool overlaps ( const BoundsBase & a , const BoundsBase & b ); check whether two bounds overlaps","title":"friend overlaps"},{"location":"Classes/classdakku_1_1BoundsBase/#friend-inside","text":"friend bool inside ( const Point < T , S > & p , const BoundsBase & b ); check whether point is inside the bounds (exclusive) Parameters : p the point b the bounds","title":"friend inside"},{"location":"Classes/classdakku_1_1BoundsBase/#friend-insideexclusive","text":"friend bool insideExclusive ( const Point < T , S > & p , const BoundsBase & b ); check whether point is inside the bounds (inclusive) Parameters : p the point b the bounds","title":"friend insideExclusive"},{"location":"Classes/classdakku_1_1BoundsBase/#friend-distancesquared","text":"friend decltype ( auto ) distanceSquared ( const Point < T , S > & p , const BoundsBase & b ); minimum squared distance between point and bounds, if inside return 0 Parameters : p the point b the bounds Return : the squared distance","title":"friend distanceSquared"},{"location":"Classes/classdakku_1_1BoundsBase/#friend-distance","text":"friend decltype ( auto ) distance ( const Point < T , S > & p , const BoundsBase & b ); minimum distance between point and bounds, if inside return 0 Parameters : p the point b the bounds Return : the distance","title":"friend distance"},{"location":"Classes/classdakku_1_1BoundsBase/#friend-operator","text":"friend BoundsBase operator | ( const BoundsBase & a , const BoundsBase & b ); take the union of the two bounds","title":"friend operator|"},{"location":"Classes/classdakku_1_1BoundsBase/#friend-operator_1","text":"friend BoundsBase operator | ( const BoundsBase & b , const Point < T , S > & p ); take the union between bounds and a point","title":"friend operator|"},{"location":"Classes/classdakku_1_1BoundsBase/#friend-operator_2","text":"friend BoundsBase operator & ( const BoundsBase & a , const BoundsBase & b ); take the intersect between two bounds","title":"friend operator&amp;"},{"location":"Classes/classdakku_1_1BoundsBase/#friend-operator_3","text":"friend std :: ostream & operator << ( std :: ostream & os , const BoundsBase & b ); Updated on 2022-04-11 at 15:27:23 +0000","title":"friend operator&lt;&lt;"},{"location":"Classes/classdakku_1_1BoxFilter/","text":"dakku::BoxFilter box filter the box filter is simple, just return \\(1\\) for all values #include <box.h> Inherits from dakku::Filter , dakku::Object Public Functions Name DAKKU_DECLARE_OBJECT ( BoxFilter , Filter ) virtual float evaluate (const Point2f & p) const override Given a 2D point which is relative to the center of the filter, the filter's value at that point is returned. Filter (const Vector2f & radius) Construct a new Filter object The filter's overall extent in each direction is twice the value given in radius Additional inherited members Public Attributes inherited from dakku::Filter Name const Vector2f radius filter radius const Vector2f invRadius filter radius inversion Public Functions inherited from dakku::Object Name virtual ~Object () =default Object (const Property & ={}) virtual std::string getClassName () const virtual std::string getParentName () const virtual std::string toString () const bool isDerivedFrom (std::string_view name) const whther the object is derived from name (inclusive) bool isBaseOf (std::string_view name) const whether the object is base of name (inclusive) std::string getClassNameStatic () std::string getParentNameStatic () Public Functions Documentation function DAKKU_DECLARE_OBJECT DAKKU_DECLARE_OBJECT ( BoxFilter , Filter ) function evaluate virtual float evaluate ( const Point2f & p ) const override Given a 2D point which is relative to the center of the filter, the filter's value at that point is returned. Parameters : p the given 2D point Return : float filter's value Reimplements : dakku::Filter::evaluate function Filter explicit Filter ( const Vector2f & radius ) Construct a new Filter object The filter's overall extent in each direction is twice the value given in radius Parameters : radius radius of the filter Updated on 2022-04-11 at 15:27:23 +0000","title":"dakku::BoxFilter"},{"location":"Classes/classdakku_1_1BoxFilter/#dakkuboxfilter","text":"box filter the box filter is simple, just return \\(1\\) for all values #include <box.h> Inherits from dakku::Filter , dakku::Object","title":"dakku::BoxFilter"},{"location":"Classes/classdakku_1_1BoxFilter/#public-functions","text":"Name DAKKU_DECLARE_OBJECT ( BoxFilter , Filter ) virtual float evaluate (const Point2f & p) const override Given a 2D point which is relative to the center of the filter, the filter's value at that point is returned. Filter (const Vector2f & radius) Construct a new Filter object The filter's overall extent in each direction is twice the value given in radius","title":"Public Functions"},{"location":"Classes/classdakku_1_1BoxFilter/#additional-inherited-members","text":"Public Attributes inherited from dakku::Filter Name const Vector2f radius filter radius const Vector2f invRadius filter radius inversion Public Functions inherited from dakku::Object Name virtual ~Object () =default Object (const Property & ={}) virtual std::string getClassName () const virtual std::string getParentName () const virtual std::string toString () const bool isDerivedFrom (std::string_view name) const whther the object is derived from name (inclusive) bool isBaseOf (std::string_view name) const whether the object is base of name (inclusive) std::string getClassNameStatic () std::string getParentNameStatic ()","title":"Additional inherited members"},{"location":"Classes/classdakku_1_1BoxFilter/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Classes/classdakku_1_1BoxFilter/#function-dakku_declare_object","text":"DAKKU_DECLARE_OBJECT ( BoxFilter , Filter )","title":"function DAKKU_DECLARE_OBJECT"},{"location":"Classes/classdakku_1_1BoxFilter/#function-evaluate","text":"virtual float evaluate ( const Point2f & p ) const override Given a 2D point which is relative to the center of the filter, the filter's value at that point is returned. Parameters : p the given 2D point Return : float filter's value Reimplements : dakku::Filter::evaluate","title":"function evaluate"},{"location":"Classes/classdakku_1_1BoxFilter/#function-filter","text":"explicit Filter ( const Vector2f & radius ) Construct a new Filter object The filter's overall extent in each direction is twice the value given in radius Parameters : radius radius of the filter Updated on 2022-04-11 at 15:27:23 +0000","title":"function Filter"},{"location":"Classes/classdakku_1_1Class/","text":"dakku::Class RTTI support. #include <class.h> Public Functions Name Class & instance () get the class instance (singleton) template <ObjectType T> void registerClass () register an object class bool isDerivedFrom (std::string_view cur, std::string_view from) const check whether cur dervies from from bool isBaseof (std::string_view cur, std::string_view other) const check whether cur is base of other bool contains (std::string_view name) const check whether name is registered Object * create (std::string_view name, const Property & ={}) create an object instance and construct with property Public Functions Documentation function instance static Class & instance () get the class instance (singleton) Return : the instance function registerClass template < ObjectType T > void registerClass () register an object class Template Parameters : T object type function isDerivedFrom bool isDerivedFrom ( std :: string_view cur , std :: string_view from ) const check whether cur dervies from from function isBaseof bool isBaseof ( std :: string_view cur , std :: string_view other ) const check whether cur is base of other function contains bool contains ( std :: string_view name ) const check whether name is registered function create Object * create ( std :: string_view name , const Property & = {} ) create an object instance and construct with property Parameters : name object name Return : the object Updated on 2022-04-11 at 15:27:23 +0000","title":"dakku::Class"},{"location":"Classes/classdakku_1_1Class/#dakkuclass","text":"RTTI support. #include <class.h>","title":"dakku::Class"},{"location":"Classes/classdakku_1_1Class/#public-functions","text":"Name Class & instance () get the class instance (singleton) template <ObjectType T> void registerClass () register an object class bool isDerivedFrom (std::string_view cur, std::string_view from) const check whether cur dervies from from bool isBaseof (std::string_view cur, std::string_view other) const check whether cur is base of other bool contains (std::string_view name) const check whether name is registered Object * create (std::string_view name, const Property & ={}) create an object instance and construct with property","title":"Public Functions"},{"location":"Classes/classdakku_1_1Class/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Classes/classdakku_1_1Class/#function-instance","text":"static Class & instance () get the class instance (singleton) Return : the instance","title":"function instance"},{"location":"Classes/classdakku_1_1Class/#function-registerclass","text":"template < ObjectType T > void registerClass () register an object class Template Parameters : T object type","title":"function registerClass"},{"location":"Classes/classdakku_1_1Class/#function-isderivedfrom","text":"bool isDerivedFrom ( std :: string_view cur , std :: string_view from ) const check whether cur dervies from from","title":"function isDerivedFrom"},{"location":"Classes/classdakku_1_1Class/#function-isbaseof","text":"bool isBaseof ( std :: string_view cur , std :: string_view other ) const check whether cur is base of other","title":"function isBaseof"},{"location":"Classes/classdakku_1_1Class/#function-contains","text":"bool contains ( std :: string_view name ) const check whether name is registered","title":"function contains"},{"location":"Classes/classdakku_1_1Class/#function-create","text":"Object * create ( std :: string_view name , const Property & = {} ) create an object instance and construct with property Parameters : name object name Return : the object Updated on 2022-04-11 at 15:27:23 +0000","title":"function create"},{"location":"Classes/classdakku_1_1CoefficientSpectrum/","text":"dakku::CoefficientSpectrum coefficient spectrum More... #include <spectrum.h> Inherits from dakku::VectorBase< float, S, Derived > Public Functions Name bool isBlack () const whether the spectrum is black Derived clamp (float low =0, float high =INF) const element-wise clamp Additional inherited members Public Functions inherited from dakku::VectorBase< float, S, Derived > Name VectorBase () Construct a new Vector Base object with all components initialized to zero. template <ArithmeticType Arg> VectorBase (Arg value) Construct a new Vector Base object with all components initialized to value template <ArithmeticType Other,typename OtherDerived > VectorBase (const VectorBase < Other, S, OtherDerived > & other) Construct a new Vector Base object with a vector expression. VectorBase (const VectorBase & other) VectorBase ( VectorBase && other) VectorBase & operator= (const VectorBase & other) VectorBase & operator= ( VectorBase && other) template <ArithmeticType Arg> void set (Arg value) Construct a new Vector Base object with given values. template <ArithmeticType Arg> void setByIndex (size_t index, Arg value) set data[index] to value template <ArithmeticType... Args,size_t... Is> void set (std::index_sequence< Is... > , Args &&... args) set data to args template <ArithmeticType... Args> void set (Args &&... args) set data to args template <ArithmeticType Other,typename OtherDerived > void set (const VectorBase < Other, S, OtherDerived > & rhs) set data by rhs 's data bool hasNaNs () const check whether there are nan components const T & get (size_t i) const get i'th component std::string toString () const convert vector to string size_t size () const size of the vector const T & operator[] (size_t i) const get i'th value T & operator[] (size_t i) get i'th value Derived operator- () const negation of the vector const Derived & derived () const get derived class Derived & derived () get derived class Derived & operator+= (const Derived & rhs) addition template <ArithmeticType V> Derived & operator+= (const V & rhs) addition Derived & operator-= (const Derived & rhs) subtraction template <ArithmeticType V> Derived & operator-= (const V & rhs) subtraction Derived & operator*= (const Derived & rhs) multiplication template <ArithmeticType V> Derived & operator*= (const V & rhs) multiplication Derived & operator/= (const Derived & rhs) division template <ArithmeticType V> Derived & operator/= (const V & rhs) division std::vector< float > toFloatVector () const convert this to float vector (Property::VECTOR) VectorBase (const std::vector< float > & v) Construct a new Vector Base object with std::vector (Property::VECTOR) decltype(auto) x () const get the first element decltype(auto) x () get the first element decltype(auto) y () const get the second element decltype(auto) y () get the second element decltype(auto) z () const get the third element decltype(auto) z () get the fourth element decltype(auto) w () const get the fourth element decltype(auto) w () get the third element size_t maxElementIndex () const get the index of the max element decltype(auto) maxElement () const get the max element in the vector decltype(auto) begin () decltype(auto) begin () const decltype(auto) end () decltype(auto) end () const decltype(auto) normalized () const normalized vector Derived & normalize () normalize this template <typename OtherDerived > decltype(auto) dot (const VectorBase < T, S, OtherDerived > & rhs) const dot product between two vectors decltype(auto) squaredNorm () const squared norm decltype(auto) norm () const norm decltype(auto) length () const length Derived cross (const Derived & rhs) const cross product bool isZero () const check whether all components are zero operator std::span< T, S > () operator std::span< const T, S > () const Protected Attributes inherited from dakku::VectorBase< float, S, Derived > Name std::array< T, S > _data vector base data Friends inherited from dakku::VectorBase< float, S, Derived > Name std::ostream & operator<< (std::ostream & os, const VectorBase & vec) output the vector Derived operator+ (const Derived & a, const Derived & b) addition Derived operator+ (const Derived & a, const U & b) addition Derived operator+ (const U & a, const Derived & b) addition Derived operator- (const Derived & a, const U & b) subtraction Derived operator- (const U & a, const Derived & b) subtraction Derived operator* (const Derived & a, const Derived & b) multiplication Derived operator* (const Derived & a, const U & b) multiplication Derived operator* (const U & a, const Derived & b) multiplication Derived operator/ (const Derived & a, const Derived & b) division Derived operator/ (const Derived & a, const U & b) division Derived operator/ (const U & a, const Derived & b) division bool operator== (const Derived & a, const Derived & b) a == b (element wise) bool operator!= (const Derived & a, const Derived & b) a != b (element wise) Derived max (const Derived & v1, const Derived & v2) element wise max Derived min (const Derived & v1, const Derived & v2) element wise min Derived normalize (const Derived & v) normalized vector decltype(auto) distance (const Derived & a, const Derived & b) the distance decltype(auto) abs (const Derived & v) abs Derived sqrt (const Derived & v) element-wise sqrt Derived pow (const Derived & v, E e) element-wise power Derived exp (const Derived & v) element-wise exp Derived floor (const Derived & v) element-wise floor Derived ceil (const Derived & v) element-wise ceil Derived lerp (const Derived & a, const Derived & b, T t) element-wise linear interpolation Detailed Description template < size_t S , typename Derived > class dakku :: CoefficientSpectrum ; coefficient spectrum Template Parameters : S the number of spectrum samples Derived derived type Public Functions Documentation function isBlack inline bool isBlack () const whether the spectrum is black function clamp inline Derived clamp ( float low = 0 , float high = INF ) const element-wise clamp Updated on 2022-04-11 at 15:27:23 +0000","title":"dakku::CoefficientSpectrum"},{"location":"Classes/classdakku_1_1CoefficientSpectrum/#dakkucoefficientspectrum","text":"coefficient spectrum More... #include <spectrum.h> Inherits from dakku::VectorBase< float, S, Derived >","title":"dakku::CoefficientSpectrum"},{"location":"Classes/classdakku_1_1CoefficientSpectrum/#public-functions","text":"Name bool isBlack () const whether the spectrum is black Derived clamp (float low =0, float high =INF) const element-wise clamp","title":"Public Functions"},{"location":"Classes/classdakku_1_1CoefficientSpectrum/#additional-inherited-members","text":"Public Functions inherited from dakku::VectorBase< float, S, Derived > Name VectorBase () Construct a new Vector Base object with all components initialized to zero. template <ArithmeticType Arg> VectorBase (Arg value) Construct a new Vector Base object with all components initialized to value template <ArithmeticType Other,typename OtherDerived > VectorBase (const VectorBase < Other, S, OtherDerived > & other) Construct a new Vector Base object with a vector expression. VectorBase (const VectorBase & other) VectorBase ( VectorBase && other) VectorBase & operator= (const VectorBase & other) VectorBase & operator= ( VectorBase && other) template <ArithmeticType Arg> void set (Arg value) Construct a new Vector Base object with given values. template <ArithmeticType Arg> void setByIndex (size_t index, Arg value) set data[index] to value template <ArithmeticType... Args,size_t... Is> void set (std::index_sequence< Is... > , Args &&... args) set data to args template <ArithmeticType... Args> void set (Args &&... args) set data to args template <ArithmeticType Other,typename OtherDerived > void set (const VectorBase < Other, S, OtherDerived > & rhs) set data by rhs 's data bool hasNaNs () const check whether there are nan components const T & get (size_t i) const get i'th component std::string toString () const convert vector to string size_t size () const size of the vector const T & operator[] (size_t i) const get i'th value T & operator[] (size_t i) get i'th value Derived operator- () const negation of the vector const Derived & derived () const get derived class Derived & derived () get derived class Derived & operator+= (const Derived & rhs) addition template <ArithmeticType V> Derived & operator+= (const V & rhs) addition Derived & operator-= (const Derived & rhs) subtraction template <ArithmeticType V> Derived & operator-= (const V & rhs) subtraction Derived & operator*= (const Derived & rhs) multiplication template <ArithmeticType V> Derived & operator*= (const V & rhs) multiplication Derived & operator/= (const Derived & rhs) division template <ArithmeticType V> Derived & operator/= (const V & rhs) division std::vector< float > toFloatVector () const convert this to float vector (Property::VECTOR) VectorBase (const std::vector< float > & v) Construct a new Vector Base object with std::vector (Property::VECTOR) decltype(auto) x () const get the first element decltype(auto) x () get the first element decltype(auto) y () const get the second element decltype(auto) y () get the second element decltype(auto) z () const get the third element decltype(auto) z () get the fourth element decltype(auto) w () const get the fourth element decltype(auto) w () get the third element size_t maxElementIndex () const get the index of the max element decltype(auto) maxElement () const get the max element in the vector decltype(auto) begin () decltype(auto) begin () const decltype(auto) end () decltype(auto) end () const decltype(auto) normalized () const normalized vector Derived & normalize () normalize this template <typename OtherDerived > decltype(auto) dot (const VectorBase < T, S, OtherDerived > & rhs) const dot product between two vectors decltype(auto) squaredNorm () const squared norm decltype(auto) norm () const norm decltype(auto) length () const length Derived cross (const Derived & rhs) const cross product bool isZero () const check whether all components are zero operator std::span< T, S > () operator std::span< const T, S > () const Protected Attributes inherited from dakku::VectorBase< float, S, Derived > Name std::array< T, S > _data vector base data Friends inherited from dakku::VectorBase< float, S, Derived > Name std::ostream & operator<< (std::ostream & os, const VectorBase & vec) output the vector Derived operator+ (const Derived & a, const Derived & b) addition Derived operator+ (const Derived & a, const U & b) addition Derived operator+ (const U & a, const Derived & b) addition Derived operator- (const Derived & a, const U & b) subtraction Derived operator- (const U & a, const Derived & b) subtraction Derived operator* (const Derived & a, const Derived & b) multiplication Derived operator* (const Derived & a, const U & b) multiplication Derived operator* (const U & a, const Derived & b) multiplication Derived operator/ (const Derived & a, const Derived & b) division Derived operator/ (const Derived & a, const U & b) division Derived operator/ (const U & a, const Derived & b) division bool operator== (const Derived & a, const Derived & b) a == b (element wise) bool operator!= (const Derived & a, const Derived & b) a != b (element wise) Derived max (const Derived & v1, const Derived & v2) element wise max Derived min (const Derived & v1, const Derived & v2) element wise min Derived normalize (const Derived & v) normalized vector decltype(auto) distance (const Derived & a, const Derived & b) the distance decltype(auto) abs (const Derived & v) abs Derived sqrt (const Derived & v) element-wise sqrt Derived pow (const Derived & v, E e) element-wise power Derived exp (const Derived & v) element-wise exp Derived floor (const Derived & v) element-wise floor Derived ceil (const Derived & v) element-wise ceil Derived lerp (const Derived & a, const Derived & b, T t) element-wise linear interpolation","title":"Additional inherited members"},{"location":"Classes/classdakku_1_1CoefficientSpectrum/#detailed-description","text":"template < size_t S , typename Derived > class dakku :: CoefficientSpectrum ; coefficient spectrum Template Parameters : S the number of spectrum samples Derived derived type","title":"Detailed Description"},{"location":"Classes/classdakku_1_1CoefficientSpectrum/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Classes/classdakku_1_1CoefficientSpectrum/#function-isblack","text":"inline bool isBlack () const whether the spectrum is black","title":"function isBlack"},{"location":"Classes/classdakku_1_1CoefficientSpectrum/#function-clamp","text":"inline Derived clamp ( float low = 0 , float high = INF ) const element-wise clamp Updated on 2022-04-11 at 15:27:23 +0000","title":"function clamp"},{"location":"Classes/classdakku_1_1ConstantTexture/","text":"dakku::ConstantTexture #include <constant.h> Inherits from dakku::Texture , dakku::Object Public Functions Name DAKKU_DECLARE_OBJECT ( ConstantTexture , Texture ) ConstantTexture (float v) ConstantTexture ( Spectrum v) virtual Spectrum evaluate (const SurfaceInteraction & ) const override Additional inherited members Public Functions inherited from dakku::Texture Name Texture (bool floatType) Protected Attributes inherited from dakku::Texture Name bool floatType Public Functions inherited from dakku::Object Name virtual ~Object () =default Object (const Property & ={}) virtual std::string getClassName () const virtual std::string getParentName () const virtual std::string toString () const bool isDerivedFrom (std::string_view name) const whther the object is derived from name (inclusive) bool isBaseOf (std::string_view name) const whether the object is base of name (inclusive) std::string getClassNameStatic () std::string getParentNameStatic () Public Functions Documentation function DAKKU_DECLARE_OBJECT DAKKU_DECLARE_OBJECT ( ConstantTexture , Texture ) function ConstantTexture explicit ConstantTexture ( float v ) function ConstantTexture explicit ConstantTexture ( Spectrum v ) function evaluate virtual Spectrum evaluate ( const SurfaceInteraction & ) const override Reimplements : dakku::Texture::evaluate Updated on 2022-04-11 at 15:27:23 +0000","title":"dakku::ConstantTexture"},{"location":"Classes/classdakku_1_1ConstantTexture/#dakkuconstanttexture","text":"#include <constant.h> Inherits from dakku::Texture , dakku::Object","title":"dakku::ConstantTexture"},{"location":"Classes/classdakku_1_1ConstantTexture/#public-functions","text":"Name DAKKU_DECLARE_OBJECT ( ConstantTexture , Texture ) ConstantTexture (float v) ConstantTexture ( Spectrum v) virtual Spectrum evaluate (const SurfaceInteraction & ) const override","title":"Public Functions"},{"location":"Classes/classdakku_1_1ConstantTexture/#additional-inherited-members","text":"Public Functions inherited from dakku::Texture Name Texture (bool floatType) Protected Attributes inherited from dakku::Texture Name bool floatType Public Functions inherited from dakku::Object Name virtual ~Object () =default Object (const Property & ={}) virtual std::string getClassName () const virtual std::string getParentName () const virtual std::string toString () const bool isDerivedFrom (std::string_view name) const whther the object is derived from name (inclusive) bool isBaseOf (std::string_view name) const whether the object is base of name (inclusive) std::string getClassNameStatic () std::string getParentNameStatic ()","title":"Additional inherited members"},{"location":"Classes/classdakku_1_1ConstantTexture/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Classes/classdakku_1_1ConstantTexture/#function-dakku_declare_object","text":"DAKKU_DECLARE_OBJECT ( ConstantTexture , Texture )","title":"function DAKKU_DECLARE_OBJECT"},{"location":"Classes/classdakku_1_1ConstantTexture/#function-constanttexture","text":"explicit ConstantTexture ( float v )","title":"function ConstantTexture"},{"location":"Classes/classdakku_1_1ConstantTexture/#function-constanttexture_1","text":"explicit ConstantTexture ( Spectrum v )","title":"function ConstantTexture"},{"location":"Classes/classdakku_1_1ConstantTexture/#function-evaluate","text":"virtual Spectrum evaluate ( const SurfaceInteraction & ) const override Reimplements : dakku::Texture::evaluate Updated on 2022-04-11 at 15:27:23 +0000","title":"function evaluate"},{"location":"Classes/classdakku_1_1FileInputStream/","text":"dakku::FileInputStream file input stream #include <fstream.h> Inherits from dakku::InputStream , dakku::Object Public Functions Name DAKKU_DECLARE_OBJECT ( FileInputStream , InputStream ) FileInputStream (const std::filesystem::path & path) virtual std::uint8_t readByte () override virtual size_t readBytes (void * ptr, size_t size) override read size bytes into ptr Protected Attributes Name std::ifstream stream ifstream Additional inherited members Public Functions inherited from dakku::Object Name virtual ~Object () =default Object (const Property & ={}) virtual std::string getClassName () const virtual std::string getParentName () const virtual std::string toString () const bool isDerivedFrom (std::string_view name) const whther the object is derived from name (inclusive) bool isBaseOf (std::string_view name) const whether the object is base of name (inclusive) std::string getClassNameStatic () std::string getParentNameStatic () Public Functions Documentation function DAKKU_DECLARE_OBJECT DAKKU_DECLARE_OBJECT ( FileInputStream , InputStream ) function FileInputStream explicit FileInputStream ( const std :: filesystem :: path & path ) Parameters : path the path of the file function readByte virtual std :: uint8_t readByte () override Return : one byte read from the stream Reimplements : dakku::InputStream::readByte function readBytes virtual size_t readBytes ( void * ptr , size_t size ) override read size bytes into ptr Parameters : ptr the address of the buffer size the number of bytes to read Return : the actual number of bytes that the stream reads Reimplements : dakku::InputStream::readBytes Protected Attributes Documentation variable stream std :: ifstream stream ; ifstream Updated on 2022-04-11 at 15:27:23 +0000","title":"dakku::FileInputStream"},{"location":"Classes/classdakku_1_1FileInputStream/#dakkufileinputstream","text":"file input stream #include <fstream.h> Inherits from dakku::InputStream , dakku::Object","title":"dakku::FileInputStream"},{"location":"Classes/classdakku_1_1FileInputStream/#public-functions","text":"Name DAKKU_DECLARE_OBJECT ( FileInputStream , InputStream ) FileInputStream (const std::filesystem::path & path) virtual std::uint8_t readByte () override virtual size_t readBytes (void * ptr, size_t size) override read size bytes into ptr","title":"Public Functions"},{"location":"Classes/classdakku_1_1FileInputStream/#protected-attributes","text":"Name std::ifstream stream ifstream","title":"Protected Attributes"},{"location":"Classes/classdakku_1_1FileInputStream/#additional-inherited-members","text":"Public Functions inherited from dakku::Object Name virtual ~Object () =default Object (const Property & ={}) virtual std::string getClassName () const virtual std::string getParentName () const virtual std::string toString () const bool isDerivedFrom (std::string_view name) const whther the object is derived from name (inclusive) bool isBaseOf (std::string_view name) const whether the object is base of name (inclusive) std::string getClassNameStatic () std::string getParentNameStatic ()","title":"Additional inherited members"},{"location":"Classes/classdakku_1_1FileInputStream/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Classes/classdakku_1_1FileInputStream/#function-dakku_declare_object","text":"DAKKU_DECLARE_OBJECT ( FileInputStream , InputStream )","title":"function DAKKU_DECLARE_OBJECT"},{"location":"Classes/classdakku_1_1FileInputStream/#function-fileinputstream","text":"explicit FileInputStream ( const std :: filesystem :: path & path ) Parameters : path the path of the file","title":"function FileInputStream"},{"location":"Classes/classdakku_1_1FileInputStream/#function-readbyte","text":"virtual std :: uint8_t readByte () override Return : one byte read from the stream Reimplements : dakku::InputStream::readByte","title":"function readByte"},{"location":"Classes/classdakku_1_1FileInputStream/#function-readbytes","text":"virtual size_t readBytes ( void * ptr , size_t size ) override read size bytes into ptr Parameters : ptr the address of the buffer size the number of bytes to read Return : the actual number of bytes that the stream reads Reimplements : dakku::InputStream::readBytes","title":"function readBytes"},{"location":"Classes/classdakku_1_1FileInputStream/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"Classes/classdakku_1_1FileInputStream/#variable-stream","text":"std :: ifstream stream ; ifstream Updated on 2022-04-11 at 15:27:23 +0000","title":"variable stream"},{"location":"Classes/classdakku_1_1FileOutputStream/","text":"dakku::FileOutputStream file output stream #include <fstream.h> Inherits from dakku::OutputStream , dakku::Object Public Functions Name DAKKU_DECLARE_OBJECT ( FileOutputStream , OutputStream ) FileOutputStream (const std::filesystem::path & path) virtual void writeByte (std::uint8_t value) override write one byte virtual size_t writeBytes (const void * ptr, size_t size) override write size bytes starting at ptr Protected Attributes Name std::ofstream stream ofstream Additional inherited members Public Functions inherited from dakku::Object Name virtual ~Object () =default Object (const Property & ={}) virtual std::string getClassName () const virtual std::string getParentName () const virtual std::string toString () const bool isDerivedFrom (std::string_view name) const whther the object is derived from name (inclusive) bool isBaseOf (std::string_view name) const whether the object is base of name (inclusive) std::string getClassNameStatic () std::string getParentNameStatic () Public Functions Documentation function DAKKU_DECLARE_OBJECT DAKKU_DECLARE_OBJECT ( FileOutputStream , OutputStream ) function FileOutputStream explicit FileOutputStream ( const std :: filesystem :: path & path ) Parameters : path the path of the file function writeByte virtual void writeByte ( std :: uint8_t value ) override write one byte Parameters : value the byte to write Reimplements : dakku::OutputStream::writeByte function writeBytes virtual size_t writeBytes ( const void * ptr , size_t size ) override write size bytes starting at ptr Parameters : ptr the starting pointer (buffer address) size the number of bytes Return : the actual number of bytes the stream writes Reimplements : dakku::OutputStream::writeBytes Protected Attributes Documentation variable stream std :: ofstream stream ; ofstream Updated on 2022-04-11 at 15:27:23 +0000","title":"dakku::FileOutputStream"},{"location":"Classes/classdakku_1_1FileOutputStream/#dakkufileoutputstream","text":"file output stream #include <fstream.h> Inherits from dakku::OutputStream , dakku::Object","title":"dakku::FileOutputStream"},{"location":"Classes/classdakku_1_1FileOutputStream/#public-functions","text":"Name DAKKU_DECLARE_OBJECT ( FileOutputStream , OutputStream ) FileOutputStream (const std::filesystem::path & path) virtual void writeByte (std::uint8_t value) override write one byte virtual size_t writeBytes (const void * ptr, size_t size) override write size bytes starting at ptr","title":"Public Functions"},{"location":"Classes/classdakku_1_1FileOutputStream/#protected-attributes","text":"Name std::ofstream stream ofstream","title":"Protected Attributes"},{"location":"Classes/classdakku_1_1FileOutputStream/#additional-inherited-members","text":"Public Functions inherited from dakku::Object Name virtual ~Object () =default Object (const Property & ={}) virtual std::string getClassName () const virtual std::string getParentName () const virtual std::string toString () const bool isDerivedFrom (std::string_view name) const whther the object is derived from name (inclusive) bool isBaseOf (std::string_view name) const whether the object is base of name (inclusive) std::string getClassNameStatic () std::string getParentNameStatic ()","title":"Additional inherited members"},{"location":"Classes/classdakku_1_1FileOutputStream/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Classes/classdakku_1_1FileOutputStream/#function-dakku_declare_object","text":"DAKKU_DECLARE_OBJECT ( FileOutputStream , OutputStream )","title":"function DAKKU_DECLARE_OBJECT"},{"location":"Classes/classdakku_1_1FileOutputStream/#function-fileoutputstream","text":"explicit FileOutputStream ( const std :: filesystem :: path & path ) Parameters : path the path of the file","title":"function FileOutputStream"},{"location":"Classes/classdakku_1_1FileOutputStream/#function-writebyte","text":"virtual void writeByte ( std :: uint8_t value ) override write one byte Parameters : value the byte to write Reimplements : dakku::OutputStream::writeByte","title":"function writeByte"},{"location":"Classes/classdakku_1_1FileOutputStream/#function-writebytes","text":"virtual size_t writeBytes ( const void * ptr , size_t size ) override write size bytes starting at ptr Parameters : ptr the starting pointer (buffer address) size the number of bytes Return : the actual number of bytes the stream writes Reimplements : dakku::OutputStream::writeBytes","title":"function writeBytes"},{"location":"Classes/classdakku_1_1FileOutputStream/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"Classes/classdakku_1_1FileOutputStream/#variable-stream","text":"std :: ofstream stream ; ofstream Updated on 2022-04-11 at 15:27:23 +0000","title":"variable stream"},{"location":"Classes/classdakku_1_1Film/","text":"dakku::Film film class #include <film.h> Inherits from dakku::SerializableObject , dakku::Object Public Functions Name DAKKU_DECLARE_OBJECT ( Film , SerializableObject ) Film (const Point2i & fullResolution, const Bounds2f & cropWindow, std::unique_ptr< Filter > filter, std::string fileName, float scale, float maxSampleLuminance =INF) Construct a new Film object. Bounds2i getSampleBounds () const get the area to be sampled because the pixel reconstruction filter spans a number of pixels std::unique_ptr< FilmTile > getFilmTile (const Bounds2i & sampleBounds) get the film tile according to the given sample bounds void mergeFilmTile (std::unique_ptr< FilmTile > tile) merge a film tile into the film void writeImage (float splatScale =1) const write image to fileName void writeImageTo (std::span< float > buffer, float splatScale =1) const write image to buffer void writeImageTo (std::vector< std::uint8_t > & buffer, float splatScale =1) const write image to buffer virtual void serialize ( OutputStream * stream) const override serialize the object (do not include the property part) virtual void deserialize ( InputStream * stream) override deserialize the object (do not include the property part) Bounds2i getCroppedPixelBounds () const Get the Cropped Pixel Bounds object. Additional inherited members Public Functions inherited from dakku::Object Name virtual ~Object () =default Object (const Property & ={}) virtual std::string getClassName () const virtual std::string getParentName () const virtual std::string toString () const bool isDerivedFrom (std::string_view name) const whther the object is derived from name (inclusive) bool isBaseOf (std::string_view name) const whether the object is base of name (inclusive) std::string getClassNameStatic () std::string getParentNameStatic () Public Functions Documentation function DAKKU_DECLARE_OBJECT DAKKU_DECLARE_OBJECT ( Film , SerializableObject ) function Film explicit Film ( const Point2i & fullResolution , const Bounds2f & cropWindow , std :: unique_ptr < Filter > filter , std :: string fileName , float scale , float maxSampleLuminance = INF ) Construct a new Film object. Parameters : fullResolution full resolution cropWindow crop window, default: \\((0, 0) \\times (1, 1)\\) filter filter fileName file name to save image scale scale the pixel value maxSampleLuminance max sample luminance function getSampleBounds Bounds2i getSampleBounds () const get the area to be sampled because the pixel reconstruction filter spans a number of pixels Return : the sample bounds function getFilmTile std :: unique_ptr < FilmTile > getFilmTile ( const Bounds2i & sampleBounds ) get the film tile according to the given sample bounds Parameters : sampleBounds given region of the image Return : the film tile function mergeFilmTile void mergeFilmTile ( std :: unique_ptr < FilmTile > tile ) merge a film tile into the film Parameters : tile the given film tile function writeImage void writeImage ( float splatScale = 1 ) const write image to fileName Parameters : splatScale scale splat values function writeImageTo void writeImageTo ( std :: span < float > buffer , float splatScale = 1 ) const write image to buffer Parameters : splatScale scale splat values function writeImageTo void writeImageTo ( std :: vector < std :: uint8_t > & buffer , float splatScale = 1 ) const write image to buffer Parameters : splatScale scale splat values function serialize virtual void serialize ( OutputStream * stream ) const override serialize the object (do not include the property part) Parameters : stream Reimplements : dakku::SerializableObject::serialize function deserialize virtual void deserialize ( InputStream * stream ) override deserialize the object (do not include the property part) Parameters : stream Reimplements : dakku::SerializableObject::deserialize function getCroppedPixelBounds Bounds2i getCroppedPixelBounds () const Get the Cropped Pixel Bounds object. Updated on 2022-04-11 at 15:27:23 +0000","title":"dakku::Film"},{"location":"Classes/classdakku_1_1Film/#dakkufilm","text":"film class #include <film.h> Inherits from dakku::SerializableObject , dakku::Object","title":"dakku::Film"},{"location":"Classes/classdakku_1_1Film/#public-functions","text":"Name DAKKU_DECLARE_OBJECT ( Film , SerializableObject ) Film (const Point2i & fullResolution, const Bounds2f & cropWindow, std::unique_ptr< Filter > filter, std::string fileName, float scale, float maxSampleLuminance =INF) Construct a new Film object. Bounds2i getSampleBounds () const get the area to be sampled because the pixel reconstruction filter spans a number of pixels std::unique_ptr< FilmTile > getFilmTile (const Bounds2i & sampleBounds) get the film tile according to the given sample bounds void mergeFilmTile (std::unique_ptr< FilmTile > tile) merge a film tile into the film void writeImage (float splatScale =1) const write image to fileName void writeImageTo (std::span< float > buffer, float splatScale =1) const write image to buffer void writeImageTo (std::vector< std::uint8_t > & buffer, float splatScale =1) const write image to buffer virtual void serialize ( OutputStream * stream) const override serialize the object (do not include the property part) virtual void deserialize ( InputStream * stream) override deserialize the object (do not include the property part) Bounds2i getCroppedPixelBounds () const Get the Cropped Pixel Bounds object.","title":"Public Functions"},{"location":"Classes/classdakku_1_1Film/#additional-inherited-members","text":"Public Functions inherited from dakku::Object Name virtual ~Object () =default Object (const Property & ={}) virtual std::string getClassName () const virtual std::string getParentName () const virtual std::string toString () const bool isDerivedFrom (std::string_view name) const whther the object is derived from name (inclusive) bool isBaseOf (std::string_view name) const whether the object is base of name (inclusive) std::string getClassNameStatic () std::string getParentNameStatic ()","title":"Additional inherited members"},{"location":"Classes/classdakku_1_1Film/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Classes/classdakku_1_1Film/#function-dakku_declare_object","text":"DAKKU_DECLARE_OBJECT ( Film , SerializableObject )","title":"function DAKKU_DECLARE_OBJECT"},{"location":"Classes/classdakku_1_1Film/#function-film","text":"explicit Film ( const Point2i & fullResolution , const Bounds2f & cropWindow , std :: unique_ptr < Filter > filter , std :: string fileName , float scale , float maxSampleLuminance = INF ) Construct a new Film object. Parameters : fullResolution full resolution cropWindow crop window, default: \\((0, 0) \\times (1, 1)\\) filter filter fileName file name to save image scale scale the pixel value maxSampleLuminance max sample luminance","title":"function Film"},{"location":"Classes/classdakku_1_1Film/#function-getsamplebounds","text":"Bounds2i getSampleBounds () const get the area to be sampled because the pixel reconstruction filter spans a number of pixels Return : the sample bounds","title":"function getSampleBounds"},{"location":"Classes/classdakku_1_1Film/#function-getfilmtile","text":"std :: unique_ptr < FilmTile > getFilmTile ( const Bounds2i & sampleBounds ) get the film tile according to the given sample bounds Parameters : sampleBounds given region of the image Return : the film tile","title":"function getFilmTile"},{"location":"Classes/classdakku_1_1Film/#function-mergefilmtile","text":"void mergeFilmTile ( std :: unique_ptr < FilmTile > tile ) merge a film tile into the film Parameters : tile the given film tile","title":"function mergeFilmTile"},{"location":"Classes/classdakku_1_1Film/#function-writeimage","text":"void writeImage ( float splatScale = 1 ) const write image to fileName Parameters : splatScale scale splat values","title":"function writeImage"},{"location":"Classes/classdakku_1_1Film/#function-writeimageto","text":"void writeImageTo ( std :: span < float > buffer , float splatScale = 1 ) const write image to buffer Parameters : splatScale scale splat values","title":"function writeImageTo"},{"location":"Classes/classdakku_1_1Film/#function-writeimageto_1","text":"void writeImageTo ( std :: vector < std :: uint8_t > & buffer , float splatScale = 1 ) const write image to buffer Parameters : splatScale scale splat values","title":"function writeImageTo"},{"location":"Classes/classdakku_1_1Film/#function-serialize","text":"virtual void serialize ( OutputStream * stream ) const override serialize the object (do not include the property part) Parameters : stream Reimplements : dakku::SerializableObject::serialize","title":"function serialize"},{"location":"Classes/classdakku_1_1Film/#function-deserialize","text":"virtual void deserialize ( InputStream * stream ) override deserialize the object (do not include the property part) Parameters : stream Reimplements : dakku::SerializableObject::deserialize","title":"function deserialize"},{"location":"Classes/classdakku_1_1Film/#function-getcroppedpixelbounds","text":"Bounds2i getCroppedPixelBounds () const Get the Cropped Pixel Bounds object. Updated on 2022-04-11 at 15:27:23 +0000","title":"function getCroppedPixelBounds"},{"location":"Classes/classdakku_1_1FilmImageProvider/","text":"dakku::FilmImageProvider #include <film.h> Inherits from QQuickImageProvider Public Signals Name void updateGui (int id) Public Functions Name FilmImageProvider () QPixmap requestPixmap (const QString & , QSize * size, const QSize & requestedSize) override void setImage (const Film & film) void setImage (std::span< const float > data, int width, int height) Public Signals Documentation signal updateGui void updateGui ( int id ) Public Functions Documentation function FilmImageProvider inline FilmImageProvider () function requestPixmap QPixmap requestPixmap ( const QString & , QSize * size , const QSize & requestedSize ) override function setImage void setImage ( const Film & film ) function setImage void setImage ( std :: span < const float > data , int width , int height ) Updated on 2022-04-11 at 15:27:23 +0000","title":"dakku::FilmImageProvider"},{"location":"Classes/classdakku_1_1FilmImageProvider/#dakkufilmimageprovider","text":"#include <film.h> Inherits from QQuickImageProvider","title":"dakku::FilmImageProvider"},{"location":"Classes/classdakku_1_1FilmImageProvider/#public-signals","text":"Name void updateGui (int id)","title":"Public Signals"},{"location":"Classes/classdakku_1_1FilmImageProvider/#public-functions","text":"Name FilmImageProvider () QPixmap requestPixmap (const QString & , QSize * size, const QSize & requestedSize) override void setImage (const Film & film) void setImage (std::span< const float > data, int width, int height)","title":"Public Functions"},{"location":"Classes/classdakku_1_1FilmImageProvider/#public-signals-documentation","text":"","title":"Public Signals Documentation"},{"location":"Classes/classdakku_1_1FilmImageProvider/#signal-updategui","text":"void updateGui ( int id )","title":"signal updateGui"},{"location":"Classes/classdakku_1_1FilmImageProvider/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Classes/classdakku_1_1FilmImageProvider/#function-filmimageprovider","text":"inline FilmImageProvider ()","title":"function FilmImageProvider"},{"location":"Classes/classdakku_1_1FilmImageProvider/#function-requestpixmap","text":"QPixmap requestPixmap ( const QString & , QSize * size , const QSize & requestedSize ) override","title":"function requestPixmap"},{"location":"Classes/classdakku_1_1FilmImageProvider/#function-setimage","text":"void setImage ( const Film & film )","title":"function setImage"},{"location":"Classes/classdakku_1_1FilmImageProvider/#function-setimage_1","text":"void setImage ( std :: span < const float > data , int width , int height ) Updated on 2022-04-11 at 15:27:23 +0000","title":"function setImage"},{"location":"Classes/classdakku_1_1FilmTile/","text":"dakku::FilmTile film tile #include <film.h> Public Functions Name FilmTile (const Bounds2i & pixelBounds, const Vector2f & filterRadius, std::span< const float > filterTable, int filterTableSize, float maxSampleLuminance =INF) FilmTilePixel & getPixel (const Point2i & p) Get the Pixel object. const FilmTilePixel & getPixel (const Point2i & p) const Get the Pixel object. Bounds2i getPixelBounds () const Get the Pixel Bounds object. void addSample (const Point2f & pFilm, Spectrum L, float sampleWeight =1) add sample to the film tile Friends Name class Film Public Functions Documentation function FilmTile inline explicit FilmTile ( const Bounds2i & pixelBounds , const Vector2f & filterRadius , std :: span < const float > filterTable , int filterTableSize , float maxSampleLuminance = INF ) function getPixel inline FilmTilePixel & getPixel ( const Point2i & p ) Get the Pixel object. function getPixel inline const FilmTilePixel & getPixel ( const Point2i & p ) const Get the Pixel object. function getPixelBounds inline Bounds2i getPixelBounds () const Get the Pixel Bounds object. function addSample inline void addSample ( const Point2f & pFilm , Spectrum L , float sampleWeight = 1 ) add sample to the film tile Friends friend Film friend class Film ( Film ); Updated on 2022-04-11 at 15:27:23 +0000","title":"dakku::FilmTile"},{"location":"Classes/classdakku_1_1FilmTile/#dakkufilmtile","text":"film tile #include <film.h>","title":"dakku::FilmTile"},{"location":"Classes/classdakku_1_1FilmTile/#public-functions","text":"Name FilmTile (const Bounds2i & pixelBounds, const Vector2f & filterRadius, std::span< const float > filterTable, int filterTableSize, float maxSampleLuminance =INF) FilmTilePixel & getPixel (const Point2i & p) Get the Pixel object. const FilmTilePixel & getPixel (const Point2i & p) const Get the Pixel object. Bounds2i getPixelBounds () const Get the Pixel Bounds object. void addSample (const Point2f & pFilm, Spectrum L, float sampleWeight =1) add sample to the film tile","title":"Public Functions"},{"location":"Classes/classdakku_1_1FilmTile/#friends","text":"Name class Film","title":"Friends"},{"location":"Classes/classdakku_1_1FilmTile/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Classes/classdakku_1_1FilmTile/#function-filmtile","text":"inline explicit FilmTile ( const Bounds2i & pixelBounds , const Vector2f & filterRadius , std :: span < const float > filterTable , int filterTableSize , float maxSampleLuminance = INF )","title":"function FilmTile"},{"location":"Classes/classdakku_1_1FilmTile/#function-getpixel","text":"inline FilmTilePixel & getPixel ( const Point2i & p ) Get the Pixel object.","title":"function getPixel"},{"location":"Classes/classdakku_1_1FilmTile/#function-getpixel_1","text":"inline const FilmTilePixel & getPixel ( const Point2i & p ) const Get the Pixel object.","title":"function getPixel"},{"location":"Classes/classdakku_1_1FilmTile/#function-getpixelbounds","text":"inline Bounds2i getPixelBounds () const Get the Pixel Bounds object.","title":"function getPixelBounds"},{"location":"Classes/classdakku_1_1FilmTile/#function-addsample","text":"inline void addSample ( const Point2f & pFilm , Spectrum L , float sampleWeight = 1 ) add sample to the film tile","title":"function addSample"},{"location":"Classes/classdakku_1_1FilmTile/#friends_1","text":"","title":"Friends"},{"location":"Classes/classdakku_1_1FilmTile/#friend-film","text":"friend class Film ( Film ); Updated on 2022-04-11 at 15:27:23 +0000","title":"friend Film"},{"location":"Classes/classdakku_1_1Filter/","text":"dakku::Filter filter class all filters are centered at origin \\((0, 0)\\) and defined a radius beyond which they have a value of \\(0\\) this width may be different in the \\(x\\) and \\(y\\) directions #include <filter.h> Inherits from dakku::Object Inherited by dakku::BoxFilter , dakku::TriangleFilter Public Functions Name DAKKU_DECLARE_OBJECT ( Filter , Object ) Filter (const Vector2f & radius) Construct a new Filter object The filter's overall extent in each direction is twice the value given in radius virtual float evaluate (const Point2f & p) const =0 Given a 2D point which is relative to the center of the filter, the filter's value at that point is returned. Public Attributes Name const Vector2f radius filter radius const Vector2f invRadius filter radius inversion Additional inherited members Public Functions inherited from dakku::Object Name virtual ~Object () =default Object (const Property & ={}) virtual std::string getClassName () const virtual std::string getParentName () const virtual std::string toString () const bool isDerivedFrom (std::string_view name) const whther the object is derived from name (inclusive) bool isBaseOf (std::string_view name) const whether the object is base of name (inclusive) std::string getClassNameStatic () std::string getParentNameStatic () Public Functions Documentation function DAKKU_DECLARE_OBJECT DAKKU_DECLARE_OBJECT ( Filter , Object ) function Filter explicit Filter ( const Vector2f & radius ) Construct a new Filter object The filter's overall extent in each direction is twice the value given in radius Parameters : radius radius of the filter function evaluate virtual float evaluate ( const Point2f & p ) const = 0 Given a 2D point which is relative to the center of the filter, the filter's value at that point is returned. Parameters : p the given 2D point Return : float filter's value Reimplemented by : dakku::BoxFilter::evaluate , dakku::TriangleFilter::evaluate Public Attributes Documentation variable radius const Vector2f radius ; filter radius variable invRadius const Vector2f invRadius ; filter radius inversion Updated on 2022-04-11 at 15:27:23 +0000","title":"dakku::Filter"},{"location":"Classes/classdakku_1_1Filter/#dakkufilter","text":"filter class all filters are centered at origin \\((0, 0)\\) and defined a radius beyond which they have a value of \\(0\\) this width may be different in the \\(x\\) and \\(y\\) directions #include <filter.h> Inherits from dakku::Object Inherited by dakku::BoxFilter , dakku::TriangleFilter","title":"dakku::Filter"},{"location":"Classes/classdakku_1_1Filter/#public-functions","text":"Name DAKKU_DECLARE_OBJECT ( Filter , Object ) Filter (const Vector2f & radius) Construct a new Filter object The filter's overall extent in each direction is twice the value given in radius virtual float evaluate (const Point2f & p) const =0 Given a 2D point which is relative to the center of the filter, the filter's value at that point is returned.","title":"Public Functions"},{"location":"Classes/classdakku_1_1Filter/#public-attributes","text":"Name const Vector2f radius filter radius const Vector2f invRadius filter radius inversion","title":"Public Attributes"},{"location":"Classes/classdakku_1_1Filter/#additional-inherited-members","text":"Public Functions inherited from dakku::Object Name virtual ~Object () =default Object (const Property & ={}) virtual std::string getClassName () const virtual std::string getParentName () const virtual std::string toString () const bool isDerivedFrom (std::string_view name) const whther the object is derived from name (inclusive) bool isBaseOf (std::string_view name) const whether the object is base of name (inclusive) std::string getClassNameStatic () std::string getParentNameStatic ()","title":"Additional inherited members"},{"location":"Classes/classdakku_1_1Filter/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Classes/classdakku_1_1Filter/#function-dakku_declare_object","text":"DAKKU_DECLARE_OBJECT ( Filter , Object )","title":"function DAKKU_DECLARE_OBJECT"},{"location":"Classes/classdakku_1_1Filter/#function-filter","text":"explicit Filter ( const Vector2f & radius ) Construct a new Filter object The filter's overall extent in each direction is twice the value given in radius Parameters : radius radius of the filter","title":"function Filter"},{"location":"Classes/classdakku_1_1Filter/#function-evaluate","text":"virtual float evaluate ( const Point2f & p ) const = 0 Given a 2D point which is relative to the center of the filter, the filter's value at that point is returned. Parameters : p the given 2D point Return : float filter's value Reimplemented by : dakku::BoxFilter::evaluate , dakku::TriangleFilter::evaluate","title":"function evaluate"},{"location":"Classes/classdakku_1_1Filter/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"Classes/classdakku_1_1Filter/#variable-radius","text":"const Vector2f radius ; filter radius","title":"variable radius"},{"location":"Classes/classdakku_1_1Filter/#variable-invradius","text":"const Vector2f invRadius ; filter radius inversion Updated on 2022-04-11 at 15:27:23 +0000","title":"variable invRadius"},{"location":"Classes/classdakku_1_1GuiEngine/","text":"dakku::GuiEngine #include <engine.h> Inherits from QQmlApplicationEngine Public Slots Name void updateFilmImage (int id) Public Functions Name GuiEngine () FilmImageProvider * getProvider () const Public Slots Documentation slot updateFilmImage void updateFilmImage ( int id ) Public Functions Documentation function GuiEngine GuiEngine () function getProvider FilmImageProvider * getProvider () const Updated on 2022-04-11 at 15:27:23 +0000","title":"dakku::GuiEngine"},{"location":"Classes/classdakku_1_1GuiEngine/#dakkuguiengine","text":"#include <engine.h> Inherits from QQmlApplicationEngine","title":"dakku::GuiEngine"},{"location":"Classes/classdakku_1_1GuiEngine/#public-slots","text":"Name void updateFilmImage (int id)","title":"Public Slots"},{"location":"Classes/classdakku_1_1GuiEngine/#public-functions","text":"Name GuiEngine () FilmImageProvider * getProvider () const","title":"Public Functions"},{"location":"Classes/classdakku_1_1GuiEngine/#public-slots-documentation","text":"","title":"Public Slots Documentation"},{"location":"Classes/classdakku_1_1GuiEngine/#slot-updatefilmimage","text":"void updateFilmImage ( int id )","title":"slot updateFilmImage"},{"location":"Classes/classdakku_1_1GuiEngine/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Classes/classdakku_1_1GuiEngine/#function-guiengine","text":"GuiEngine ()","title":"function GuiEngine"},{"location":"Classes/classdakku_1_1GuiEngine/#function-getprovider","text":"FilmImageProvider * getProvider () const Updated on 2022-04-11 at 15:27:23 +0000","title":"function getProvider"},{"location":"Classes/classdakku_1_1ImageTexture/","text":"dakku::ImageTexture #include <image.h> Inherits from dakku::Texture , dakku::Object Public Functions Name DAKKU_DECLARE_OBJECT ( ImageTexture , Texture ) ImageTexture (std::unique_ptr< TextureMapping2D > m, const std::filesystem::path & fileName, bool doTrilinear, float maxAnisotropy, ImageWrapMode mode, float scale, bool gamma, bool floatType =false) virtual Spectrum evaluate (const SurfaceInteraction & si) const override Additional inherited members Public Functions inherited from dakku::Texture Name Texture (bool floatType) Protected Attributes inherited from dakku::Texture Name bool floatType Public Functions inherited from dakku::Object Name virtual ~Object () =default Object (const Property & ={}) virtual std::string getClassName () const virtual std::string getParentName () const virtual std::string toString () const bool isDerivedFrom (std::string_view name) const whther the object is derived from name (inclusive) bool isBaseOf (std::string_view name) const whether the object is base of name (inclusive) std::string getClassNameStatic () std::string getParentNameStatic () Public Functions Documentation function DAKKU_DECLARE_OBJECT DAKKU_DECLARE_OBJECT ( ImageTexture , Texture ) function ImageTexture explicit ImageTexture ( std :: unique_ptr < TextureMapping2D > m , const std :: filesystem :: path & fileName , bool doTrilinear , float maxAnisotropy , ImageWrapMode mode , float scale , bool gamma , bool floatType = false ) function evaluate virtual Spectrum evaluate ( const SurfaceInteraction & si ) const override Reimplements : dakku::Texture::evaluate Updated on 2022-04-11 at 15:27:23 +0000","title":"dakku::ImageTexture"},{"location":"Classes/classdakku_1_1ImageTexture/#dakkuimagetexture","text":"#include <image.h> Inherits from dakku::Texture , dakku::Object","title":"dakku::ImageTexture"},{"location":"Classes/classdakku_1_1ImageTexture/#public-functions","text":"Name DAKKU_DECLARE_OBJECT ( ImageTexture , Texture ) ImageTexture (std::unique_ptr< TextureMapping2D > m, const std::filesystem::path & fileName, bool doTrilinear, float maxAnisotropy, ImageWrapMode mode, float scale, bool gamma, bool floatType =false) virtual Spectrum evaluate (const SurfaceInteraction & si) const override","title":"Public Functions"},{"location":"Classes/classdakku_1_1ImageTexture/#additional-inherited-members","text":"Public Functions inherited from dakku::Texture Name Texture (bool floatType) Protected Attributes inherited from dakku::Texture Name bool floatType Public Functions inherited from dakku::Object Name virtual ~Object () =default Object (const Property & ={}) virtual std::string getClassName () const virtual std::string getParentName () const virtual std::string toString () const bool isDerivedFrom (std::string_view name) const whther the object is derived from name (inclusive) bool isBaseOf (std::string_view name) const whether the object is base of name (inclusive) std::string getClassNameStatic () std::string getParentNameStatic ()","title":"Additional inherited members"},{"location":"Classes/classdakku_1_1ImageTexture/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Classes/classdakku_1_1ImageTexture/#function-dakku_declare_object","text":"DAKKU_DECLARE_OBJECT ( ImageTexture , Texture )","title":"function DAKKU_DECLARE_OBJECT"},{"location":"Classes/classdakku_1_1ImageTexture/#function-imagetexture","text":"explicit ImageTexture ( std :: unique_ptr < TextureMapping2D > m , const std :: filesystem :: path & fileName , bool doTrilinear , float maxAnisotropy , ImageWrapMode mode , float scale , bool gamma , bool floatType = false )","title":"function ImageTexture"},{"location":"Classes/classdakku_1_1ImageTexture/#function-evaluate","text":"virtual Spectrum evaluate ( const SurfaceInteraction & si ) const override Reimplements : dakku::Texture::evaluate Updated on 2022-04-11 at 15:27:23 +0000","title":"function evaluate"},{"location":"Classes/classdakku_1_1InputStream/","text":"dakku::InputStream input stream #include <serialization.h> Inherits from dakku::Object Inherited by dakku::FileInputStream Public Functions Name DAKKU_DECLARE_OBJECT ( InputStream , Object ) virtual std::uint8_t readByte () =0 read next byte virtual size_t readBytes (void * ptr, size_t size) =0 read bytes Additional inherited members Public Functions inherited from dakku::Object Name virtual ~Object () =default Object (const Property & ={}) virtual std::string getClassName () const virtual std::string getParentName () const virtual std::string toString () const bool isDerivedFrom (std::string_view name) const whther the object is derived from name (inclusive) bool isBaseOf (std::string_view name) const whether the object is base of name (inclusive) std::string getClassNameStatic () std::string getParentNameStatic () Public Functions Documentation function DAKKU_DECLARE_OBJECT DAKKU_DECLARE_OBJECT ( InputStream , Object ) function readByte virtual std :: uint8_t readByte () = 0 read next byte Return : the next byte Reimplemented by : dakku::FileInputStream::readByte function readBytes virtual size_t readBytes ( void * ptr , size_t size ) = 0 read bytes Parameters : ptr the output address size the size of bytes Return : the size actually read Reimplemented by : dakku::FileInputStream::readBytes Updated on 2022-04-11 at 15:27:23 +0000","title":"dakku::InputStream"},{"location":"Classes/classdakku_1_1InputStream/#dakkuinputstream","text":"input stream #include <serialization.h> Inherits from dakku::Object Inherited by dakku::FileInputStream","title":"dakku::InputStream"},{"location":"Classes/classdakku_1_1InputStream/#public-functions","text":"Name DAKKU_DECLARE_OBJECT ( InputStream , Object ) virtual std::uint8_t readByte () =0 read next byte virtual size_t readBytes (void * ptr, size_t size) =0 read bytes","title":"Public Functions"},{"location":"Classes/classdakku_1_1InputStream/#additional-inherited-members","text":"Public Functions inherited from dakku::Object Name virtual ~Object () =default Object (const Property & ={}) virtual std::string getClassName () const virtual std::string getParentName () const virtual std::string toString () const bool isDerivedFrom (std::string_view name) const whther the object is derived from name (inclusive) bool isBaseOf (std::string_view name) const whether the object is base of name (inclusive) std::string getClassNameStatic () std::string getParentNameStatic ()","title":"Additional inherited members"},{"location":"Classes/classdakku_1_1InputStream/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Classes/classdakku_1_1InputStream/#function-dakku_declare_object","text":"DAKKU_DECLARE_OBJECT ( InputStream , Object )","title":"function DAKKU_DECLARE_OBJECT"},{"location":"Classes/classdakku_1_1InputStream/#function-readbyte","text":"virtual std :: uint8_t readByte () = 0 read next byte Return : the next byte Reimplemented by : dakku::FileInputStream::readByte","title":"function readByte"},{"location":"Classes/classdakku_1_1InputStream/#function-readbytes","text":"virtual size_t readBytes ( void * ptr , size_t size ) = 0 read bytes Parameters : ptr the output address size the size of bytes Return : the size actually read Reimplemented by : dakku::FileInputStream::readBytes Updated on 2022-04-11 at 15:27:23 +0000","title":"function readBytes"},{"location":"Classes/classdakku_1_1L1CacheLineAlignedResource/","text":"dakku::L1CacheLineAlignedResource memory resource that at least aligned with L1 cache line size #include <memory.h> Inherits from std::pmr::memory_resource Public Functions Name L1CacheLineAlignedResource (std::pmr::memory_resource * upStream =std::pmr::get_default_resource()) void * do_allocate (size_t bytes, size_t align) override void do_deallocate (void * ptr, size_t bytes, size_t align) override bool do_is_equal (const memory_resource & rhs) const override Public Functions Documentation function L1CacheLineAlignedResource inline explicit L1CacheLineAlignedResource ( std :: pmr :: memory_resource * upStream = std :: pmr :: get_default_resource () ) function do_allocate inline void * do_allocate ( size_t bytes , size_t align ) override function do_deallocate inline void do_deallocate ( void * ptr , size_t bytes , size_t align ) override function do_is_equal inline bool do_is_equal ( const memory_resource & rhs ) const override Updated on 2022-04-11 at 15:27:23 +0000","title":"dakku::L1CacheLineAlignedResource"},{"location":"Classes/classdakku_1_1L1CacheLineAlignedResource/#dakkul1cachelinealignedresource","text":"memory resource that at least aligned with L1 cache line size #include <memory.h> Inherits from std::pmr::memory_resource","title":"dakku::L1CacheLineAlignedResource"},{"location":"Classes/classdakku_1_1L1CacheLineAlignedResource/#public-functions","text":"Name L1CacheLineAlignedResource (std::pmr::memory_resource * upStream =std::pmr::get_default_resource()) void * do_allocate (size_t bytes, size_t align) override void do_deallocate (void * ptr, size_t bytes, size_t align) override bool do_is_equal (const memory_resource & rhs) const override","title":"Public Functions"},{"location":"Classes/classdakku_1_1L1CacheLineAlignedResource/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Classes/classdakku_1_1L1CacheLineAlignedResource/#function-l1cachelinealignedresource","text":"inline explicit L1CacheLineAlignedResource ( std :: pmr :: memory_resource * upStream = std :: pmr :: get_default_resource () )","title":"function L1CacheLineAlignedResource"},{"location":"Classes/classdakku_1_1L1CacheLineAlignedResource/#function-do_allocate","text":"inline void * do_allocate ( size_t bytes , size_t align ) override","title":"function do_allocate"},{"location":"Classes/classdakku_1_1L1CacheLineAlignedResource/#function-do_deallocate","text":"inline void do_deallocate ( void * ptr , size_t bytes , size_t align ) override","title":"function do_deallocate"},{"location":"Classes/classdakku_1_1L1CacheLineAlignedResource/#function-do_is_equal","text":"inline bool do_is_equal ( const memory_resource & rhs ) const override Updated on 2022-04-11 at 15:27:23 +0000","title":"function do_is_equal"},{"location":"Classes/classdakku_1_1Logger/","text":"dakku::Logger logger class #include <logger.h> Public Functions Name const Logger & get () get logger instance spdlog::logger * handle () const get raw spdlog::logger handle Public Functions Documentation function get static const Logger & get () get logger instance Return : the logger instance function handle inline spdlog :: logger * handle () const get raw spdlog::logger handle Return : the corresponding spdlog::logger Updated on 2022-04-11 at 15:27:23 +0000","title":"dakku::Logger"},{"location":"Classes/classdakku_1_1Logger/#dakkulogger","text":"logger class #include <logger.h>","title":"dakku::Logger"},{"location":"Classes/classdakku_1_1Logger/#public-functions","text":"Name const Logger & get () get logger instance spdlog::logger * handle () const get raw spdlog::logger handle","title":"Public Functions"},{"location":"Classes/classdakku_1_1Logger/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Classes/classdakku_1_1Logger/#function-get","text":"static const Logger & get () get logger instance Return : the logger instance","title":"function get"},{"location":"Classes/classdakku_1_1Logger/#function-handle","text":"inline spdlog :: logger * handle () const get raw spdlog::logger handle Return : the corresponding spdlog::logger Updated on 2022-04-11 at 15:27:23 +0000","title":"function handle"},{"location":"Classes/classdakku_1_1MemoryArena/","text":"dakku::MemoryArena memory arena #include <memory.h> Public Functions Name MemoryArena () =default MemoryArena (std::pmr::memory_resource * buffer) template <typename T ,typename... Args> T * allocObject (Args &&... args) allocate and construct a object from the arena void release () release the memory arena Public Functions Documentation function MemoryArena explicit MemoryArena () = default function MemoryArena inline explicit MemoryArena ( std :: pmr :: memory_resource * buffer ) function allocObject template < typename T , typename ... Args > inline T * allocObject ( Args && ... args ) allocate and construct a object from the arena Parameters : args arguments Template Parameters : T object type Args argument types Return : T* object instance function release inline void release () release the memory arena Updated on 2022-04-11 at 15:27:23 +0000","title":"dakku::MemoryArena"},{"location":"Classes/classdakku_1_1MemoryArena/#dakkumemoryarena","text":"memory arena #include <memory.h>","title":"dakku::MemoryArena"},{"location":"Classes/classdakku_1_1MemoryArena/#public-functions","text":"Name MemoryArena () =default MemoryArena (std::pmr::memory_resource * buffer) template <typename T ,typename... Args> T * allocObject (Args &&... args) allocate and construct a object from the arena void release () release the memory arena","title":"Public Functions"},{"location":"Classes/classdakku_1_1MemoryArena/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Classes/classdakku_1_1MemoryArena/#function-memoryarena","text":"explicit MemoryArena () = default","title":"function MemoryArena"},{"location":"Classes/classdakku_1_1MemoryArena/#function-memoryarena_1","text":"inline explicit MemoryArena ( std :: pmr :: memory_resource * buffer )","title":"function MemoryArena"},{"location":"Classes/classdakku_1_1MemoryArena/#function-allocobject","text":"template < typename T , typename ... Args > inline T * allocObject ( Args && ... args ) allocate and construct a object from the arena Parameters : args arguments Template Parameters : T object type Args argument types Return : T* object instance","title":"function allocObject"},{"location":"Classes/classdakku_1_1MemoryArena/#function-release","text":"inline void release () release the memory arena Updated on 2022-04-11 at 15:27:23 +0000","title":"function release"},{"location":"Classes/classdakku_1_1MipMap/","text":"dakku::MipMap mipmap class More... #include <mipmap.h> Public Functions Name MipMap ( Point2i resolution, std::span< const T > data, bool doTrilinear =true, float maxAnisotropy =8.0f, ImageWrapMode wrapMode = ImageWrapMode::REPEAT ) int width () const int height () const int levels () const const T & texel (int level, int s, int t) const get texel value T lookup (const Point2f & st, float width) const trilinear triangle filter lookup \\(\\frac 1 w = 2 ^ {n - 1 - l}\\) T lookup (const Point2f & st, Vector2f dst0, Vector2f dst1) const Detailed Description template < typename T > class dakku :: MipMap ; mipmap class Template Parameters : T data type Public Functions Documentation function MipMap explicit MipMap ( Point2i resolution , std :: span < const T > data , bool doTrilinear = true , float maxAnisotropy = 8.0f , ImageWrapMode wrapMode = ImageWrapMode :: REPEAT ) function width inline int width () const function height inline int height () const function levels inline int levels () const function texel const T & texel ( int level , int s , int t ) const get texel value Parameters : level mipmap level function lookup T lookup ( const Point2f & st , float width ) const trilinear triangle filter lookup \\(\\frac 1 w = 2 ^ {n - 1 - l}\\) function lookup T lookup ( const Point2f & st , Vector2f dst0 , Vector2f dst1 ) const Updated on 2022-04-11 at 15:27:23 +0000","title":"dakku::MipMap"},{"location":"Classes/classdakku_1_1MipMap/#dakkumipmap","text":"mipmap class More... #include <mipmap.h>","title":"dakku::MipMap"},{"location":"Classes/classdakku_1_1MipMap/#public-functions","text":"Name MipMap ( Point2i resolution, std::span< const T > data, bool doTrilinear =true, float maxAnisotropy =8.0f, ImageWrapMode wrapMode = ImageWrapMode::REPEAT ) int width () const int height () const int levels () const const T & texel (int level, int s, int t) const get texel value T lookup (const Point2f & st, float width) const trilinear triangle filter lookup \\(\\frac 1 w = 2 ^ {n - 1 - l}\\) T lookup (const Point2f & st, Vector2f dst0, Vector2f dst1) const","title":"Public Functions"},{"location":"Classes/classdakku_1_1MipMap/#detailed-description","text":"template < typename T > class dakku :: MipMap ; mipmap class Template Parameters : T data type","title":"Detailed Description"},{"location":"Classes/classdakku_1_1MipMap/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Classes/classdakku_1_1MipMap/#function-mipmap","text":"explicit MipMap ( Point2i resolution , std :: span < const T > data , bool doTrilinear = true , float maxAnisotropy = 8.0f , ImageWrapMode wrapMode = ImageWrapMode :: REPEAT )","title":"function MipMap"},{"location":"Classes/classdakku_1_1MipMap/#function-width","text":"inline int width () const","title":"function width"},{"location":"Classes/classdakku_1_1MipMap/#function-height","text":"inline int height () const","title":"function height"},{"location":"Classes/classdakku_1_1MipMap/#function-levels","text":"inline int levels () const","title":"function levels"},{"location":"Classes/classdakku_1_1MipMap/#function-texel","text":"const T & texel ( int level , int s , int t ) const get texel value Parameters : level mipmap level","title":"function texel"},{"location":"Classes/classdakku_1_1MipMap/#function-lookup","text":"T lookup ( const Point2f & st , float width ) const trilinear triangle filter lookup \\(\\frac 1 w = 2 ^ {n - 1 - l}\\)","title":"function lookup"},{"location":"Classes/classdakku_1_1MipMap/#function-lookup_1","text":"T lookup ( const Point2f & st , Vector2f dst0 , Vector2f dst1 ) const Updated on 2022-04-11 at 15:27:23 +0000","title":"function lookup"},{"location":"Classes/classdakku_1_1Normal/","text":"dakku::Normal normal More... #include <vector.h> Inherits from dakku::VectorBase< T, S, Normal< T, S > > Friends Name Normal operator- (const Normal & a, const Normal & b) subtraction between two normals Additional inherited members Public Functions inherited from dakku::VectorBase< T, S, Normal< T, S > > Name VectorBase () Construct a new Vector Base object with all components initialized to zero. template <ArithmeticType Arg> VectorBase (Arg value) Construct a new Vector Base object with all components initialized to value template <ArithmeticType Other,typename OtherDerived > VectorBase (const VectorBase < Other, S, OtherDerived > & other) Construct a new Vector Base object with a vector expression. VectorBase (const VectorBase & other) VectorBase ( VectorBase && other) VectorBase & operator= (const VectorBase & other) VectorBase & operator= ( VectorBase && other) template <ArithmeticType Arg> void set (Arg value) Construct a new Vector Base object with given values. template <ArithmeticType Arg> void setByIndex (size_t index, Arg value) set data[index] to value template <ArithmeticType... Args,size_t... Is> void set (std::index_sequence< Is... > , Args &&... args) set data to args template <ArithmeticType... Args> void set (Args &&... args) set data to args template <ArithmeticType Other,typename OtherDerived > void set (const VectorBase < Other, S, OtherDerived > & rhs) set data by rhs 's data bool hasNaNs () const check whether there are nan components const T & get (size_t i) const get i'th component std::string toString () const convert vector to string size_t size () const size of the vector const T & operator[] (size_t i) const get i'th value T & operator[] (size_t i) get i'th value const Derived & derived () const get derived class Derived & derived () get derived class Derived & operator+= (const Derived & rhs) addition template <ArithmeticType V> Derived & operator+= (const V & rhs) addition Derived & operator-= (const Derived & rhs) subtraction template <ArithmeticType V> Derived & operator-= (const V & rhs) subtraction Derived & operator*= (const Derived & rhs) multiplication template <ArithmeticType V> Derived & operator*= (const V & rhs) multiplication Derived & operator/= (const Derived & rhs) division template <ArithmeticType V> Derived & operator/= (const V & rhs) division std::vector< float > toFloatVector () const convert this to float vector (Property::VECTOR) VectorBase (const std::vector< float > & v) Construct a new Vector Base object with std::vector (Property::VECTOR) decltype(auto) x () const get the first element decltype(auto) x () get the first element decltype(auto) y () const get the second element decltype(auto) y () get the second element decltype(auto) z () const get the third element decltype(auto) z () get the fourth element decltype(auto) w () const get the fourth element decltype(auto) w () get the third element size_t maxElementIndex () const get the index of the max element decltype(auto) maxElement () const get the max element in the vector decltype(auto) begin () decltype(auto) begin () const decltype(auto) end () decltype(auto) end () const decltype(auto) normalized () const normalized vector Derived & normalize () normalize this template <typename OtherDerived > decltype(auto) dot (const VectorBase < T, S, OtherDerived > & rhs) const dot product between two vectors decltype(auto) squaredNorm () const squared norm decltype(auto) norm () const norm decltype(auto) length () const length Derived cross (const Derived & rhs) const cross product bool isZero () const check whether all components are zero operator std::span< T, S > () operator std::span< const T, S > () const Protected Attributes inherited from dakku::VectorBase< T, S, Normal< T, S > > Name std::array< T, S > _data vector base data Friends inherited from dakku::VectorBase< T, S, Normal< T, S > > Name std::ostream & operator<< (std::ostream & os, const VectorBase & vec) output the vector Derived operator+ (const Derived & a, const Derived & b) addition Derived operator+ (const Derived & a, const U & b) addition Derived operator+ (const U & a, const Derived & b) addition Derived operator* (const Derived & a, const Derived & b) multiplication Derived operator* (const Derived & a, const U & b) multiplication Derived operator* (const U & a, const Derived & b) multiplication Derived operator/ (const Derived & a, const Derived & b) division Derived operator/ (const Derived & a, const U & b) division Derived operator/ (const U & a, const Derived & b) division bool operator== (const Derived & a, const Derived & b) a == b (element wise) bool operator!= (const Derived & a, const Derived & b) a != b (element wise) Derived max (const Derived & v1, const Derived & v2) element wise max Derived min (const Derived & v1, const Derived & v2) element wise min Derived normalize (const Derived & v) normalized vector decltype(auto) distance (const Derived & a, const Derived & b) the distance decltype(auto) abs (const Derived & v) abs Derived sqrt (const Derived & v) element-wise sqrt Derived pow (const Derived & v, E e) element-wise power Derived exp (const Derived & v) element-wise exp Derived floor (const Derived & v) element-wise floor Derived ceil (const Derived & v) element-wise ceil Derived lerp (const Derived & a, const Derived & b, T t) element-wise linear interpolation Detailed Description template < ArithmeticType T , size_t S > class dakku :: Normal ; normal Template Parameters : T data type S size Friends friend operator- friend Normal operator - ( const Normal & a , const Normal & b ); subtraction between two normals Updated on 2022-04-11 at 15:27:23 +0000","title":"dakku::Normal"},{"location":"Classes/classdakku_1_1Normal/#dakkunormal","text":"normal More... #include <vector.h> Inherits from dakku::VectorBase< T, S, Normal< T, S > >","title":"dakku::Normal"},{"location":"Classes/classdakku_1_1Normal/#friends","text":"Name Normal operator- (const Normal & a, const Normal & b) subtraction between two normals","title":"Friends"},{"location":"Classes/classdakku_1_1Normal/#additional-inherited-members","text":"Public Functions inherited from dakku::VectorBase< T, S, Normal< T, S > > Name VectorBase () Construct a new Vector Base object with all components initialized to zero. template <ArithmeticType Arg> VectorBase (Arg value) Construct a new Vector Base object with all components initialized to value template <ArithmeticType Other,typename OtherDerived > VectorBase (const VectorBase < Other, S, OtherDerived > & other) Construct a new Vector Base object with a vector expression. VectorBase (const VectorBase & other) VectorBase ( VectorBase && other) VectorBase & operator= (const VectorBase & other) VectorBase & operator= ( VectorBase && other) template <ArithmeticType Arg> void set (Arg value) Construct a new Vector Base object with given values. template <ArithmeticType Arg> void setByIndex (size_t index, Arg value) set data[index] to value template <ArithmeticType... Args,size_t... Is> void set (std::index_sequence< Is... > , Args &&... args) set data to args template <ArithmeticType... Args> void set (Args &&... args) set data to args template <ArithmeticType Other,typename OtherDerived > void set (const VectorBase < Other, S, OtherDerived > & rhs) set data by rhs 's data bool hasNaNs () const check whether there are nan components const T & get (size_t i) const get i'th component std::string toString () const convert vector to string size_t size () const size of the vector const T & operator[] (size_t i) const get i'th value T & operator[] (size_t i) get i'th value const Derived & derived () const get derived class Derived & derived () get derived class Derived & operator+= (const Derived & rhs) addition template <ArithmeticType V> Derived & operator+= (const V & rhs) addition Derived & operator-= (const Derived & rhs) subtraction template <ArithmeticType V> Derived & operator-= (const V & rhs) subtraction Derived & operator*= (const Derived & rhs) multiplication template <ArithmeticType V> Derived & operator*= (const V & rhs) multiplication Derived & operator/= (const Derived & rhs) division template <ArithmeticType V> Derived & operator/= (const V & rhs) division std::vector< float > toFloatVector () const convert this to float vector (Property::VECTOR) VectorBase (const std::vector< float > & v) Construct a new Vector Base object with std::vector (Property::VECTOR) decltype(auto) x () const get the first element decltype(auto) x () get the first element decltype(auto) y () const get the second element decltype(auto) y () get the second element decltype(auto) z () const get the third element decltype(auto) z () get the fourth element decltype(auto) w () const get the fourth element decltype(auto) w () get the third element size_t maxElementIndex () const get the index of the max element decltype(auto) maxElement () const get the max element in the vector decltype(auto) begin () decltype(auto) begin () const decltype(auto) end () decltype(auto) end () const decltype(auto) normalized () const normalized vector Derived & normalize () normalize this template <typename OtherDerived > decltype(auto) dot (const VectorBase < T, S, OtherDerived > & rhs) const dot product between two vectors decltype(auto) squaredNorm () const squared norm decltype(auto) norm () const norm decltype(auto) length () const length Derived cross (const Derived & rhs) const cross product bool isZero () const check whether all components are zero operator std::span< T, S > () operator std::span< const T, S > () const Protected Attributes inherited from dakku::VectorBase< T, S, Normal< T, S > > Name std::array< T, S > _data vector base data Friends inherited from dakku::VectorBase< T, S, Normal< T, S > > Name std::ostream & operator<< (std::ostream & os, const VectorBase & vec) output the vector Derived operator+ (const Derived & a, const Derived & b) addition Derived operator+ (const Derived & a, const U & b) addition Derived operator+ (const U & a, const Derived & b) addition Derived operator* (const Derived & a, const Derived & b) multiplication Derived operator* (const Derived & a, const U & b) multiplication Derived operator* (const U & a, const Derived & b) multiplication Derived operator/ (const Derived & a, const Derived & b) division Derived operator/ (const Derived & a, const U & b) division Derived operator/ (const U & a, const Derived & b) division bool operator== (const Derived & a, const Derived & b) a == b (element wise) bool operator!= (const Derived & a, const Derived & b) a != b (element wise) Derived max (const Derived & v1, const Derived & v2) element wise max Derived min (const Derived & v1, const Derived & v2) element wise min Derived normalize (const Derived & v) normalized vector decltype(auto) distance (const Derived & a, const Derived & b) the distance decltype(auto) abs (const Derived & v) abs Derived sqrt (const Derived & v) element-wise sqrt Derived pow (const Derived & v, E e) element-wise power Derived exp (const Derived & v) element-wise exp Derived floor (const Derived & v) element-wise floor Derived ceil (const Derived & v) element-wise ceil Derived lerp (const Derived & a, const Derived & b, T t) element-wise linear interpolation","title":"Additional inherited members"},{"location":"Classes/classdakku_1_1Normal/#detailed-description","text":"template < ArithmeticType T , size_t S > class dakku :: Normal ; normal Template Parameters : T data type S size","title":"Detailed Description"},{"location":"Classes/classdakku_1_1Normal/#friends_1","text":"","title":"Friends"},{"location":"Classes/classdakku_1_1Normal/#friend-operator-","text":"friend Normal operator - ( const Normal & a , const Normal & b ); subtraction between two normals Updated on 2022-04-11 at 15:27:23 +0000","title":"friend operator-"},{"location":"Classes/classdakku_1_1Object/","text":"dakku::Object Object class, RTTI support. #include <object.h> Inherited by dakku::Filter , dakku::InputStream , dakku::OutputStream , dakku::SerializableObject , dakku::Shape , dakku::Texture , dakku::TextureMapping2D Public Functions Name virtual ~Object () =default Object (const Property & ={}) virtual std::string getClassName () const virtual std::string getParentName () const virtual std::string toString () const bool isDerivedFrom (std::string_view name) const whther the object is derived from name (inclusive) bool isBaseOf (std::string_view name) const whether the object is base of name (inclusive) std::string getClassNameStatic () std::string getParentNameStatic () Public Functions Documentation function ~Object virtual ~ Object () = default function Object explicit Object ( const Property & = {} ) function getClassName virtual std :: string getClassName () const Return : the class name of the object function getParentName virtual std :: string getParentName () const Return : the class name of the parent of the object function toString virtual std :: string toString () const Return : object to string (default: class name) function isDerivedFrom bool isDerivedFrom ( std :: string_view name ) const whther the object is derived from name (inclusive) function isBaseOf bool isBaseOf ( std :: string_view name ) const whether the object is base of name (inclusive) function getClassNameStatic static inline std :: string getClassNameStatic () Return : the class name of the object function getParentNameStatic static inline std :: string getParentNameStatic () Return : the class name of the parent of the object Updated on 2022-04-11 at 15:27:23 +0000","title":"dakku::Object"},{"location":"Classes/classdakku_1_1Object/#dakkuobject","text":"Object class, RTTI support. #include <object.h> Inherited by dakku::Filter , dakku::InputStream , dakku::OutputStream , dakku::SerializableObject , dakku::Shape , dakku::Texture , dakku::TextureMapping2D","title":"dakku::Object"},{"location":"Classes/classdakku_1_1Object/#public-functions","text":"Name virtual ~Object () =default Object (const Property & ={}) virtual std::string getClassName () const virtual std::string getParentName () const virtual std::string toString () const bool isDerivedFrom (std::string_view name) const whther the object is derived from name (inclusive) bool isBaseOf (std::string_view name) const whether the object is base of name (inclusive) std::string getClassNameStatic () std::string getParentNameStatic ()","title":"Public Functions"},{"location":"Classes/classdakku_1_1Object/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Classes/classdakku_1_1Object/#function-object","text":"virtual ~ Object () = default","title":"function ~Object"},{"location":"Classes/classdakku_1_1Object/#function-object_1","text":"explicit Object ( const Property & = {} )","title":"function Object"},{"location":"Classes/classdakku_1_1Object/#function-getclassname","text":"virtual std :: string getClassName () const Return : the class name of the object","title":"function getClassName"},{"location":"Classes/classdakku_1_1Object/#function-getparentname","text":"virtual std :: string getParentName () const Return : the class name of the parent of the object","title":"function getParentName"},{"location":"Classes/classdakku_1_1Object/#function-tostring","text":"virtual std :: string toString () const Return : object to string (default: class name)","title":"function toString"},{"location":"Classes/classdakku_1_1Object/#function-isderivedfrom","text":"bool isDerivedFrom ( std :: string_view name ) const whther the object is derived from name (inclusive)","title":"function isDerivedFrom"},{"location":"Classes/classdakku_1_1Object/#function-isbaseof","text":"bool isBaseOf ( std :: string_view name ) const whether the object is base of name (inclusive)","title":"function isBaseOf"},{"location":"Classes/classdakku_1_1Object/#function-getclassnamestatic","text":"static inline std :: string getClassNameStatic () Return : the class name of the object","title":"function getClassNameStatic"},{"location":"Classes/classdakku_1_1Object/#function-getparentnamestatic","text":"static inline std :: string getParentNameStatic () Return : the class name of the parent of the object Updated on 2022-04-11 at 15:27:23 +0000","title":"function getParentNameStatic"},{"location":"Classes/classdakku_1_1OutputStream/","text":"dakku::OutputStream output stream #include <serialization.h> Inherits from dakku::Object Inherited by dakku::FileOutputStream Public Functions Name DAKKU_DECLARE_OBJECT ( OutputStream , Object ) virtual void writeByte (std::uint8_t value) =0 write a byte virtual size_t writeBytes (const void * ptr, size_t size) =0 write bytes Additional inherited members Public Functions inherited from dakku::Object Name virtual ~Object () =default Object (const Property & ={}) virtual std::string getClassName () const virtual std::string getParentName () const virtual std::string toString () const bool isDerivedFrom (std::string_view name) const whther the object is derived from name (inclusive) bool isBaseOf (std::string_view name) const whether the object is base of name (inclusive) std::string getClassNameStatic () std::string getParentNameStatic () Public Functions Documentation function DAKKU_DECLARE_OBJECT DAKKU_DECLARE_OBJECT ( OutputStream , Object ) function writeByte virtual void writeByte ( std :: uint8_t value ) = 0 write a byte Parameters : value the value of the byte Reimplemented by : dakku::FileOutputStream::writeByte function writeBytes virtual size_t writeBytes ( const void * ptr , size_t size ) = 0 write bytes Parameters : ptr the start address of the bytes to write size the size of bytes Return : the size actually write Reimplemented by : dakku::FileOutputStream::writeBytes Updated on 2022-04-11 at 15:27:23 +0000","title":"dakku::OutputStream"},{"location":"Classes/classdakku_1_1OutputStream/#dakkuoutputstream","text":"output stream #include <serialization.h> Inherits from dakku::Object Inherited by dakku::FileOutputStream","title":"dakku::OutputStream"},{"location":"Classes/classdakku_1_1OutputStream/#public-functions","text":"Name DAKKU_DECLARE_OBJECT ( OutputStream , Object ) virtual void writeByte (std::uint8_t value) =0 write a byte virtual size_t writeBytes (const void * ptr, size_t size) =0 write bytes","title":"Public Functions"},{"location":"Classes/classdakku_1_1OutputStream/#additional-inherited-members","text":"Public Functions inherited from dakku::Object Name virtual ~Object () =default Object (const Property & ={}) virtual std::string getClassName () const virtual std::string getParentName () const virtual std::string toString () const bool isDerivedFrom (std::string_view name) const whther the object is derived from name (inclusive) bool isBaseOf (std::string_view name) const whether the object is base of name (inclusive) std::string getClassNameStatic () std::string getParentNameStatic ()","title":"Additional inherited members"},{"location":"Classes/classdakku_1_1OutputStream/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Classes/classdakku_1_1OutputStream/#function-dakku_declare_object","text":"DAKKU_DECLARE_OBJECT ( OutputStream , Object )","title":"function DAKKU_DECLARE_OBJECT"},{"location":"Classes/classdakku_1_1OutputStream/#function-writebyte","text":"virtual void writeByte ( std :: uint8_t value ) = 0 write a byte Parameters : value the value of the byte Reimplemented by : dakku::FileOutputStream::writeByte","title":"function writeByte"},{"location":"Classes/classdakku_1_1OutputStream/#function-writebytes","text":"virtual size_t writeBytes ( const void * ptr , size_t size ) = 0 write bytes Parameters : ptr the start address of the bytes to write size the size of bytes Return : the size actually write Reimplemented by : dakku::FileOutputStream::writeBytes Updated on 2022-04-11 at 15:27:23 +0000","title":"function writeBytes"},{"location":"Classes/classdakku_1_1Point/","text":"dakku::Point point More... #include <vector.h> Inherits from dakku::VectorBase< T, S, Point< T, S > > Friends Name Vector < T, S > operator- (const Point & a, const Point & b) subtraction between two points yields vectors Point operator- (const Point & a, const Vector < T, S > & b) point - vector => point Point operator+ (const Point & a, const Vector < T, S > & b) point + vector => point Additional inherited members Public Functions inherited from dakku::VectorBase< T, S, Point< T, S > > Name VectorBase () Construct a new Vector Base object with all components initialized to zero. template <ArithmeticType Arg> VectorBase (Arg value) Construct a new Vector Base object with all components initialized to value template <ArithmeticType Other,typename OtherDerived > VectorBase (const VectorBase < Other, S, OtherDerived > & other) Construct a new Vector Base object with a vector expression. VectorBase (const VectorBase & other) VectorBase ( VectorBase && other) VectorBase & operator= (const VectorBase & other) VectorBase & operator= ( VectorBase && other) template <ArithmeticType Arg> void set (Arg value) Construct a new Vector Base object with given values. template <ArithmeticType Arg> void setByIndex (size_t index, Arg value) set data[index] to value template <ArithmeticType... Args,size_t... Is> void set (std::index_sequence< Is... > , Args &&... args) set data to args template <ArithmeticType... Args> void set (Args &&... args) set data to args template <ArithmeticType Other,typename OtherDerived > void set (const VectorBase < Other, S, OtherDerived > & rhs) set data by rhs 's data bool hasNaNs () const check whether there are nan components const T & get (size_t i) const get i'th component std::string toString () const convert vector to string size_t size () const size of the vector const T & operator[] (size_t i) const get i'th value T & operator[] (size_t i) get i'th value const Derived & derived () const get derived class Derived & derived () get derived class Derived & operator+= (const Derived & rhs) addition template <ArithmeticType V> Derived & operator+= (const V & rhs) addition Derived & operator-= (const Derived & rhs) subtraction template <ArithmeticType V> Derived & operator-= (const V & rhs) subtraction Derived & operator*= (const Derived & rhs) multiplication template <ArithmeticType V> Derived & operator*= (const V & rhs) multiplication Derived & operator/= (const Derived & rhs) division template <ArithmeticType V> Derived & operator/= (const V & rhs) division std::vector< float > toFloatVector () const convert this to float vector (Property::VECTOR) VectorBase (const std::vector< float > & v) Construct a new Vector Base object with std::vector (Property::VECTOR) decltype(auto) x () const get the first element decltype(auto) x () get the first element decltype(auto) y () const get the second element decltype(auto) y () get the second element decltype(auto) z () const get the third element decltype(auto) z () get the fourth element decltype(auto) w () const get the fourth element decltype(auto) w () get the third element size_t maxElementIndex () const get the index of the max element decltype(auto) maxElement () const get the max element in the vector decltype(auto) begin () decltype(auto) begin () const decltype(auto) end () decltype(auto) end () const decltype(auto) normalized () const normalized vector Derived & normalize () normalize this template <typename OtherDerived > decltype(auto) dot (const VectorBase < T, S, OtherDerived > & rhs) const dot product between two vectors decltype(auto) squaredNorm () const squared norm decltype(auto) norm () const norm decltype(auto) length () const length Derived cross (const Derived & rhs) const cross product bool isZero () const check whether all components are zero operator std::span< T, S > () operator std::span< const T, S > () const Protected Attributes inherited from dakku::VectorBase< T, S, Point< T, S > > Name std::array< T, S > _data vector base data Friends inherited from dakku::VectorBase< T, S, Point< T, S > > Name std::ostream & operator<< (std::ostream & os, const VectorBase & vec) output the vector Derived operator* (const Derived & a, const Derived & b) multiplication Derived operator* (const Derived & a, const U & b) multiplication Derived operator* (const U & a, const Derived & b) multiplication Derived operator/ (const Derived & a, const Derived & b) division Derived operator/ (const Derived & a, const U & b) division Derived operator/ (const U & a, const Derived & b) division bool operator== (const Derived & a, const Derived & b) a == b (element wise) bool operator!= (const Derived & a, const Derived & b) a != b (element wise) Derived max (const Derived & v1, const Derived & v2) element wise max Derived min (const Derived & v1, const Derived & v2) element wise min Derived normalize (const Derived & v) normalized vector decltype(auto) distance (const Derived & a, const Derived & b) the distance decltype(auto) abs (const Derived & v) abs Derived sqrt (const Derived & v) element-wise sqrt Derived pow (const Derived & v, E e) element-wise power Derived exp (const Derived & v) element-wise exp Derived floor (const Derived & v) element-wise floor Derived ceil (const Derived & v) element-wise ceil Derived lerp (const Derived & a, const Derived & b, T t) element-wise linear interpolation Detailed Description template < ArithmeticType T , size_t S > class dakku :: Point ; point Template Parameters : T data type S size Friends friend operator- friend Vector < T , S > operator - ( const Point & a , const Point & b ); subtraction between two points yields vectors friend operator- friend Point operator - ( const Point & a , const Vector < T , S > & b ); point - vector => point friend operator+ friend Point operator + ( const Point & a , const Vector < T , S > & b ); point + vector => point Updated on 2022-04-11 at 15:27:23 +0000","title":"dakku::Point"},{"location":"Classes/classdakku_1_1Point/#dakkupoint","text":"point More... #include <vector.h> Inherits from dakku::VectorBase< T, S, Point< T, S > >","title":"dakku::Point"},{"location":"Classes/classdakku_1_1Point/#friends","text":"Name Vector < T, S > operator- (const Point & a, const Point & b) subtraction between two points yields vectors Point operator- (const Point & a, const Vector < T, S > & b) point - vector => point Point operator+ (const Point & a, const Vector < T, S > & b) point + vector => point","title":"Friends"},{"location":"Classes/classdakku_1_1Point/#additional-inherited-members","text":"Public Functions inherited from dakku::VectorBase< T, S, Point< T, S > > Name VectorBase () Construct a new Vector Base object with all components initialized to zero. template <ArithmeticType Arg> VectorBase (Arg value) Construct a new Vector Base object with all components initialized to value template <ArithmeticType Other,typename OtherDerived > VectorBase (const VectorBase < Other, S, OtherDerived > & other) Construct a new Vector Base object with a vector expression. VectorBase (const VectorBase & other) VectorBase ( VectorBase && other) VectorBase & operator= (const VectorBase & other) VectorBase & operator= ( VectorBase && other) template <ArithmeticType Arg> void set (Arg value) Construct a new Vector Base object with given values. template <ArithmeticType Arg> void setByIndex (size_t index, Arg value) set data[index] to value template <ArithmeticType... Args,size_t... Is> void set (std::index_sequence< Is... > , Args &&... args) set data to args template <ArithmeticType... Args> void set (Args &&... args) set data to args template <ArithmeticType Other,typename OtherDerived > void set (const VectorBase < Other, S, OtherDerived > & rhs) set data by rhs 's data bool hasNaNs () const check whether there are nan components const T & get (size_t i) const get i'th component std::string toString () const convert vector to string size_t size () const size of the vector const T & operator[] (size_t i) const get i'th value T & operator[] (size_t i) get i'th value const Derived & derived () const get derived class Derived & derived () get derived class Derived & operator+= (const Derived & rhs) addition template <ArithmeticType V> Derived & operator+= (const V & rhs) addition Derived & operator-= (const Derived & rhs) subtraction template <ArithmeticType V> Derived & operator-= (const V & rhs) subtraction Derived & operator*= (const Derived & rhs) multiplication template <ArithmeticType V> Derived & operator*= (const V & rhs) multiplication Derived & operator/= (const Derived & rhs) division template <ArithmeticType V> Derived & operator/= (const V & rhs) division std::vector< float > toFloatVector () const convert this to float vector (Property::VECTOR) VectorBase (const std::vector< float > & v) Construct a new Vector Base object with std::vector (Property::VECTOR) decltype(auto) x () const get the first element decltype(auto) x () get the first element decltype(auto) y () const get the second element decltype(auto) y () get the second element decltype(auto) z () const get the third element decltype(auto) z () get the fourth element decltype(auto) w () const get the fourth element decltype(auto) w () get the third element size_t maxElementIndex () const get the index of the max element decltype(auto) maxElement () const get the max element in the vector decltype(auto) begin () decltype(auto) begin () const decltype(auto) end () decltype(auto) end () const decltype(auto) normalized () const normalized vector Derived & normalize () normalize this template <typename OtherDerived > decltype(auto) dot (const VectorBase < T, S, OtherDerived > & rhs) const dot product between two vectors decltype(auto) squaredNorm () const squared norm decltype(auto) norm () const norm decltype(auto) length () const length Derived cross (const Derived & rhs) const cross product bool isZero () const check whether all components are zero operator std::span< T, S > () operator std::span< const T, S > () const Protected Attributes inherited from dakku::VectorBase< T, S, Point< T, S > > Name std::array< T, S > _data vector base data Friends inherited from dakku::VectorBase< T, S, Point< T, S > > Name std::ostream & operator<< (std::ostream & os, const VectorBase & vec) output the vector Derived operator* (const Derived & a, const Derived & b) multiplication Derived operator* (const Derived & a, const U & b) multiplication Derived operator* (const U & a, const Derived & b) multiplication Derived operator/ (const Derived & a, const Derived & b) division Derived operator/ (const Derived & a, const U & b) division Derived operator/ (const U & a, const Derived & b) division bool operator== (const Derived & a, const Derived & b) a == b (element wise) bool operator!= (const Derived & a, const Derived & b) a != b (element wise) Derived max (const Derived & v1, const Derived & v2) element wise max Derived min (const Derived & v1, const Derived & v2) element wise min Derived normalize (const Derived & v) normalized vector decltype(auto) distance (const Derived & a, const Derived & b) the distance decltype(auto) abs (const Derived & v) abs Derived sqrt (const Derived & v) element-wise sqrt Derived pow (const Derived & v, E e) element-wise power Derived exp (const Derived & v) element-wise exp Derived floor (const Derived & v) element-wise floor Derived ceil (const Derived & v) element-wise ceil Derived lerp (const Derived & a, const Derived & b, T t) element-wise linear interpolation","title":"Additional inherited members"},{"location":"Classes/classdakku_1_1Point/#detailed-description","text":"template < ArithmeticType T , size_t S > class dakku :: Point ; point Template Parameters : T data type S size","title":"Detailed Description"},{"location":"Classes/classdakku_1_1Point/#friends_1","text":"","title":"Friends"},{"location":"Classes/classdakku_1_1Point/#friend-operator-","text":"friend Vector < T , S > operator - ( const Point & a , const Point & b ); subtraction between two points yields vectors","title":"friend operator-"},{"location":"Classes/classdakku_1_1Point/#friend-operator-_1","text":"friend Point operator - ( const Point & a , const Vector < T , S > & b ); point - vector => point","title":"friend operator-"},{"location":"Classes/classdakku_1_1Point/#friend-operator","text":"friend Point operator + ( const Point & a , const Vector < T , S > & b ); point + vector => point Updated on 2022-04-11 at 15:27:23 +0000","title":"friend operator+"},{"location":"Classes/classdakku_1_1Property/","text":"dakku::Property property class, containing many data types, similar to json #include <property.h> Public Types Name using std::map< std::string, Property , std::less<> > ObjectType using std::vector< Property > ArrayType using float NumberType using std::vector< float > VectorType using std::string StringType using Transform TransformType Public Functions Name Property () =default Construct a new empty Property object. template <ArithmeticType T> Property (const T & v) Construct a new Property object with a number. Property (const std::string & s) template <ArithmeticType T,size_t S,typename D > Property (const VectorBase < T, S, D > & v) Construct a new Property object with a vector. Property (const std::vector< float > & v) Construct a new Property object with a float vector. Property (const Transform & t) Construct a new Property object with a transform. decltype(auto) getPropertyType () const get the type of current property template <PropertyType type> decltype(auto) get () get the property data according to given type template <PropertyType type,bool required =false> decltype(auto) get () const get the property data according to given type (const) decltype(auto) getObject () get object decltype(auto) getObject () const get object decltype(auto) getArray () get array decltype(auto) getArray () const get array decltype(auto) getNumber () get number decltype(auto) getNumber () const get number decltype(auto) getString () get string decltype(auto) getString () const get string decltype(auto) getVector () get vector decltype(auto) getVector () const get vector decltype(auto) getTransform () get transform decltype(auto) getTransform () const get transform bool isObjectType () const is this an object bool isArrayType () const is this an array bool isNumberType () const is this a number bool isStringType () const is this a string bool isVectorType () const is this a vector bool isTransformType () const is this a transform decltype(auto) operator[] (const std::string & key) index key , if this is NONE, then => OBJECT decltype(auto) operator[] (const std::string & key) const index key (const), key must exists decltype(auto) operator[] (size_t i) index i, if this is NONE, then => ARRAY if i >= size, it will grow automatically decltype(auto) operator[] (size_t i) const index i, if this is NONE, then => ARRAY if i >= size, it will grow automatically std::string toString () const to string Transform mergeTransform () const special case, merge transforms (e.g., lookat, rotate, translate) template <typename T > T getVectorIf (std::string_view key, const T & value) const get a vector by looking up key , if not found return the given value template <ArithmeticType T =float> T getNumberIf (std::string_view key, const T & value) const get a number by looking up key , if not found return the given value std::string getStringIf (std::string_view key, const std::string & value) const get a string by looking up key , if not found return the given value Friends Name std::ostream & operator<< (std::ostream & os, const Property & property) output the property void to_json (nlohmann::json & j, const Property & p) void from_json (const nlohmann::json & j, Property & p) Public Types Documentation using ObjectType using dakku :: Property :: ObjectType = std :: map < std :: string , Property , std :: less <> > ; using ArrayType using dakku :: Property :: ArrayType = std :: vector < Property > ; using NumberType using dakku :: Property :: NumberType = float ; using VectorType using dakku :: Property :: VectorType = std :: vector < float > ; using StringType using dakku :: Property :: StringType = std :: string ; using TransformType using dakku :: Property :: TransformType = Transform ; Public Functions Documentation function Property Property () = default Construct a new empty Property object. function Property template < ArithmeticType T > inline Property ( const T & v ) Construct a new Property object with a number. Parameters : v number value function Property inline Property ( const std :: string & s ) function Property template < ArithmeticType T , size_t S , typename D > inline Property ( const VectorBase < T , S , D > & v ) Construct a new Property object with a vector. Parameters : v vector function Property inline Property ( const std :: vector < float > & v ) Construct a new Property object with a float vector. function Property inline Property ( const Transform & t ) Construct a new Property object with a transform. Parameters : t transform function getPropertyType inline decltype ( auto ) getPropertyType () const get the type of current property Return : the property type function get template < PropertyType type > inline decltype ( auto ) get () get the property data according to given type Template Parameters : type the type to get Return : the data function get template < PropertyType type , bool required = false > inline decltype ( auto ) get () const get the property data according to given type (const) Template Parameters : type the type to get Return : the data function getObject inline decltype ( auto ) getObject () get object function getObject inline decltype ( auto ) getObject () const get object function getArray inline decltype ( auto ) getArray () get array function getArray inline decltype ( auto ) getArray () const get array function getNumber inline decltype ( auto ) getNumber () get number function getNumber inline decltype ( auto ) getNumber () const get number function getString inline decltype ( auto ) getString () get string function getString inline decltype ( auto ) getString () const get string function getVector inline decltype ( auto ) getVector () get vector function getVector inline decltype ( auto ) getVector () const get vector function getTransform inline decltype ( auto ) getTransform () get transform function getTransform inline decltype ( auto ) getTransform () const get transform function isObjectType inline bool isObjectType () const is this an object function isArrayType inline bool isArrayType () const is this an array function isNumberType inline bool isNumberType () const is this a number function isStringType inline bool isStringType () const is this a string function isVectorType inline bool isVectorType () const is this a vector function isTransformType inline bool isTransformType () const is this a transform function operator[] inline decltype ( auto ) operator []( const std :: string & key ) index key , if this is NONE, then => OBJECT Parameters : key key to index Return : value function operator[] inline decltype ( auto ) operator []( const std :: string & key ) const index key (const), key must exists Parameters : key key to index Return : value function operator[] inline decltype ( auto ) operator []( size_t i ) index i, if this is NONE, then => ARRAY if i >= size, it will grow automatically Parameters : i the index Return : the data function operator[] inline decltype ( auto ) operator []( size_t i ) const index i, if this is NONE, then => ARRAY if i >= size, it will grow automatically Parameters : i the index Return : the data function toString std :: string toString () const to string function mergeTransform inline Transform mergeTransform () const special case, merge transforms (e.g., lookat, rotate, translate) Return : Property & function getVectorIf template < typename T > inline T getVectorIf ( std :: string_view key , const T & value ) const get a vector by looking up key , if not found return the given value function getNumberIf template < ArithmeticType T = float > inline T getNumberIf ( std :: string_view key , const T & value ) const get a number by looking up key , if not found return the given value function getStringIf inline std :: string getStringIf ( std :: string_view key , const std :: string & value ) const get a string by looking up key , if not found return the given value Friends friend operator<< friend std :: ostream & operator << ( std :: ostream & os , const Property & property ); output the property friend to_json friend void to_json ( nlohmann :: json & j , const Property & p ); friend from_json friend void from_json ( const nlohmann :: json & j , Property & p ); Updated on 2022-04-11 at 15:27:23 +0000","title":"dakku::Property"},{"location":"Classes/classdakku_1_1Property/#dakkuproperty","text":"property class, containing many data types, similar to json #include <property.h>","title":"dakku::Property"},{"location":"Classes/classdakku_1_1Property/#public-types","text":"Name using std::map< std::string, Property , std::less<> > ObjectType using std::vector< Property > ArrayType using float NumberType using std::vector< float > VectorType using std::string StringType using Transform TransformType","title":"Public Types"},{"location":"Classes/classdakku_1_1Property/#public-functions","text":"Name Property () =default Construct a new empty Property object. template <ArithmeticType T> Property (const T & v) Construct a new Property object with a number. Property (const std::string & s) template <ArithmeticType T,size_t S,typename D > Property (const VectorBase < T, S, D > & v) Construct a new Property object with a vector. Property (const std::vector< float > & v) Construct a new Property object with a float vector. Property (const Transform & t) Construct a new Property object with a transform. decltype(auto) getPropertyType () const get the type of current property template <PropertyType type> decltype(auto) get () get the property data according to given type template <PropertyType type,bool required =false> decltype(auto) get () const get the property data according to given type (const) decltype(auto) getObject () get object decltype(auto) getObject () const get object decltype(auto) getArray () get array decltype(auto) getArray () const get array decltype(auto) getNumber () get number decltype(auto) getNumber () const get number decltype(auto) getString () get string decltype(auto) getString () const get string decltype(auto) getVector () get vector decltype(auto) getVector () const get vector decltype(auto) getTransform () get transform decltype(auto) getTransform () const get transform bool isObjectType () const is this an object bool isArrayType () const is this an array bool isNumberType () const is this a number bool isStringType () const is this a string bool isVectorType () const is this a vector bool isTransformType () const is this a transform decltype(auto) operator[] (const std::string & key) index key , if this is NONE, then => OBJECT decltype(auto) operator[] (const std::string & key) const index key (const), key must exists decltype(auto) operator[] (size_t i) index i, if this is NONE, then => ARRAY if i >= size, it will grow automatically decltype(auto) operator[] (size_t i) const index i, if this is NONE, then => ARRAY if i >= size, it will grow automatically std::string toString () const to string Transform mergeTransform () const special case, merge transforms (e.g., lookat, rotate, translate) template <typename T > T getVectorIf (std::string_view key, const T & value) const get a vector by looking up key , if not found return the given value template <ArithmeticType T =float> T getNumberIf (std::string_view key, const T & value) const get a number by looking up key , if not found return the given value std::string getStringIf (std::string_view key, const std::string & value) const get a string by looking up key , if not found return the given value","title":"Public Functions"},{"location":"Classes/classdakku_1_1Property/#friends","text":"Name std::ostream & operator<< (std::ostream & os, const Property & property) output the property void to_json (nlohmann::json & j, const Property & p) void from_json (const nlohmann::json & j, Property & p)","title":"Friends"},{"location":"Classes/classdakku_1_1Property/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Classes/classdakku_1_1Property/#using-objecttype","text":"using dakku :: Property :: ObjectType = std :: map < std :: string , Property , std :: less <> > ;","title":"using ObjectType"},{"location":"Classes/classdakku_1_1Property/#using-arraytype","text":"using dakku :: Property :: ArrayType = std :: vector < Property > ;","title":"using ArrayType"},{"location":"Classes/classdakku_1_1Property/#using-numbertype","text":"using dakku :: Property :: NumberType = float ;","title":"using NumberType"},{"location":"Classes/classdakku_1_1Property/#using-vectortype","text":"using dakku :: Property :: VectorType = std :: vector < float > ;","title":"using VectorType"},{"location":"Classes/classdakku_1_1Property/#using-stringtype","text":"using dakku :: Property :: StringType = std :: string ;","title":"using StringType"},{"location":"Classes/classdakku_1_1Property/#using-transformtype","text":"using dakku :: Property :: TransformType = Transform ;","title":"using TransformType"},{"location":"Classes/classdakku_1_1Property/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Classes/classdakku_1_1Property/#function-property","text":"Property () = default Construct a new empty Property object.","title":"function Property"},{"location":"Classes/classdakku_1_1Property/#function-property_1","text":"template < ArithmeticType T > inline Property ( const T & v ) Construct a new Property object with a number. Parameters : v number value","title":"function Property"},{"location":"Classes/classdakku_1_1Property/#function-property_2","text":"inline Property ( const std :: string & s )","title":"function Property"},{"location":"Classes/classdakku_1_1Property/#function-property_3","text":"template < ArithmeticType T , size_t S , typename D > inline Property ( const VectorBase < T , S , D > & v ) Construct a new Property object with a vector. Parameters : v vector","title":"function Property"},{"location":"Classes/classdakku_1_1Property/#function-property_4","text":"inline Property ( const std :: vector < float > & v ) Construct a new Property object with a float vector.","title":"function Property"},{"location":"Classes/classdakku_1_1Property/#function-property_5","text":"inline Property ( const Transform & t ) Construct a new Property object with a transform. Parameters : t transform","title":"function Property"},{"location":"Classes/classdakku_1_1Property/#function-getpropertytype","text":"inline decltype ( auto ) getPropertyType () const get the type of current property Return : the property type","title":"function getPropertyType"},{"location":"Classes/classdakku_1_1Property/#function-get","text":"template < PropertyType type > inline decltype ( auto ) get () get the property data according to given type Template Parameters : type the type to get Return : the data","title":"function get"},{"location":"Classes/classdakku_1_1Property/#function-get_1","text":"template < PropertyType type , bool required = false > inline decltype ( auto ) get () const get the property data according to given type (const) Template Parameters : type the type to get Return : the data","title":"function get"},{"location":"Classes/classdakku_1_1Property/#function-getobject","text":"inline decltype ( auto ) getObject () get object","title":"function getObject"},{"location":"Classes/classdakku_1_1Property/#function-getobject_1","text":"inline decltype ( auto ) getObject () const get object","title":"function getObject"},{"location":"Classes/classdakku_1_1Property/#function-getarray","text":"inline decltype ( auto ) getArray () get array","title":"function getArray"},{"location":"Classes/classdakku_1_1Property/#function-getarray_1","text":"inline decltype ( auto ) getArray () const get array","title":"function getArray"},{"location":"Classes/classdakku_1_1Property/#function-getnumber","text":"inline decltype ( auto ) getNumber () get number","title":"function getNumber"},{"location":"Classes/classdakku_1_1Property/#function-getnumber_1","text":"inline decltype ( auto ) getNumber () const get number","title":"function getNumber"},{"location":"Classes/classdakku_1_1Property/#function-getstring","text":"inline decltype ( auto ) getString () get string","title":"function getString"},{"location":"Classes/classdakku_1_1Property/#function-getstring_1","text":"inline decltype ( auto ) getString () const get string","title":"function getString"},{"location":"Classes/classdakku_1_1Property/#function-getvector","text":"inline decltype ( auto ) getVector () get vector","title":"function getVector"},{"location":"Classes/classdakku_1_1Property/#function-getvector_1","text":"inline decltype ( auto ) getVector () const get vector","title":"function getVector"},{"location":"Classes/classdakku_1_1Property/#function-gettransform","text":"inline decltype ( auto ) getTransform () get transform","title":"function getTransform"},{"location":"Classes/classdakku_1_1Property/#function-gettransform_1","text":"inline decltype ( auto ) getTransform () const get transform","title":"function getTransform"},{"location":"Classes/classdakku_1_1Property/#function-isobjecttype","text":"inline bool isObjectType () const is this an object","title":"function isObjectType"},{"location":"Classes/classdakku_1_1Property/#function-isarraytype","text":"inline bool isArrayType () const is this an array","title":"function isArrayType"},{"location":"Classes/classdakku_1_1Property/#function-isnumbertype","text":"inline bool isNumberType () const is this a number","title":"function isNumberType"},{"location":"Classes/classdakku_1_1Property/#function-isstringtype","text":"inline bool isStringType () const is this a string","title":"function isStringType"},{"location":"Classes/classdakku_1_1Property/#function-isvectortype","text":"inline bool isVectorType () const is this a vector","title":"function isVectorType"},{"location":"Classes/classdakku_1_1Property/#function-istransformtype","text":"inline bool isTransformType () const is this a transform","title":"function isTransformType"},{"location":"Classes/classdakku_1_1Property/#function-operator","text":"inline decltype ( auto ) operator []( const std :: string & key ) index key , if this is NONE, then => OBJECT Parameters : key key to index Return : value","title":"function operator[]"},{"location":"Classes/classdakku_1_1Property/#function-operator_1","text":"inline decltype ( auto ) operator []( const std :: string & key ) const index key (const), key must exists Parameters : key key to index Return : value","title":"function operator[]"},{"location":"Classes/classdakku_1_1Property/#function-operator_2","text":"inline decltype ( auto ) operator []( size_t i ) index i, if this is NONE, then => ARRAY if i >= size, it will grow automatically Parameters : i the index Return : the data","title":"function operator[]"},{"location":"Classes/classdakku_1_1Property/#function-operator_3","text":"inline decltype ( auto ) operator []( size_t i ) const index i, if this is NONE, then => ARRAY if i >= size, it will grow automatically Parameters : i the index Return : the data","title":"function operator[]"},{"location":"Classes/classdakku_1_1Property/#function-tostring","text":"std :: string toString () const to string","title":"function toString"},{"location":"Classes/classdakku_1_1Property/#function-mergetransform","text":"inline Transform mergeTransform () const special case, merge transforms (e.g., lookat, rotate, translate) Return : Property &","title":"function mergeTransform"},{"location":"Classes/classdakku_1_1Property/#function-getvectorif","text":"template < typename T > inline T getVectorIf ( std :: string_view key , const T & value ) const get a vector by looking up key , if not found return the given value","title":"function getVectorIf"},{"location":"Classes/classdakku_1_1Property/#function-getnumberif","text":"template < ArithmeticType T = float > inline T getNumberIf ( std :: string_view key , const T & value ) const get a number by looking up key , if not found return the given value","title":"function getNumberIf"},{"location":"Classes/classdakku_1_1Property/#function-getstringif","text":"inline std :: string getStringIf ( std :: string_view key , const std :: string & value ) const get a string by looking up key , if not found return the given value","title":"function getStringIf"},{"location":"Classes/classdakku_1_1Property/#friends_1","text":"","title":"Friends"},{"location":"Classes/classdakku_1_1Property/#friend-operator","text":"friend std :: ostream & operator << ( std :: ostream & os , const Property & property ); output the property","title":"friend operator&lt;&lt;"},{"location":"Classes/classdakku_1_1Property/#friend-to_json","text":"friend void to_json ( nlohmann :: json & j , const Property & p );","title":"friend to_json"},{"location":"Classes/classdakku_1_1Property/#friend-from_json","text":"friend void from_json ( const nlohmann :: json & j , Property & p ); Updated on 2022-04-11 at 15:27:23 +0000","title":"friend from_json"},{"location":"Classes/classdakku_1_1Ray/","text":"dakku::Ray ray #include <ray.h> Inherited by dakku::RayDifferential Public Functions Name Ray () =default Ray ( Point3f o, Vector3f d, float tMax =INF) Point3f operator() (float t) const get the point on the ray at \\(t\\) bool hasNaNs () const check whether the ray has nans Public Attributes Name Point3f o ray origin Vector3f d ray direction (note: it may not be normalized) float tMax Public Functions Documentation function Ray Ray () = default function Ray inline explicit Ray ( Point3f o , Vector3f d , float tMax = INF ) function operator() inline Point3f operator ()( float t ) const get the point on the ray at \\(t\\) function hasNaNs inline bool hasNaNs () const check whether the ray has nans Public Attributes Documentation variable o Point3f o ; ray origin variable d Vector3f d ; ray direction (note: it may not be normalized) variable tMax float tMax { INF }; Updated on 2022-04-11 at 15:27:23 +0000","title":"dakku::Ray"},{"location":"Classes/classdakku_1_1Ray/#dakkuray","text":"ray #include <ray.h> Inherited by dakku::RayDifferential","title":"dakku::Ray"},{"location":"Classes/classdakku_1_1Ray/#public-functions","text":"Name Ray () =default Ray ( Point3f o, Vector3f d, float tMax =INF) Point3f operator() (float t) const get the point on the ray at \\(t\\) bool hasNaNs () const check whether the ray has nans","title":"Public Functions"},{"location":"Classes/classdakku_1_1Ray/#public-attributes","text":"Name Point3f o ray origin Vector3f d ray direction (note: it may not be normalized) float tMax","title":"Public Attributes"},{"location":"Classes/classdakku_1_1Ray/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Classes/classdakku_1_1Ray/#function-ray","text":"Ray () = default","title":"function Ray"},{"location":"Classes/classdakku_1_1Ray/#function-ray_1","text":"inline explicit Ray ( Point3f o , Vector3f d , float tMax = INF )","title":"function Ray"},{"location":"Classes/classdakku_1_1Ray/#function-operator","text":"inline Point3f operator ()( float t ) const get the point on the ray at \\(t\\)","title":"function operator()"},{"location":"Classes/classdakku_1_1Ray/#function-hasnans","text":"inline bool hasNaNs () const check whether the ray has nans","title":"function hasNaNs"},{"location":"Classes/classdakku_1_1Ray/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"Classes/classdakku_1_1Ray/#variable-o","text":"Point3f o ; ray origin","title":"variable o"},{"location":"Classes/classdakku_1_1Ray/#variable-d","text":"Vector3f d ; ray direction (note: it may not be normalized)","title":"variable d"},{"location":"Classes/classdakku_1_1Ray/#variable-tmax","text":"float tMax { INF }; Updated on 2022-04-11 at 15:27:23 +0000","title":"variable tMax"},{"location":"Classes/classdakku_1_1RayDifferential/","text":"dakku::RayDifferential differential ray #include <ray.h> Inherits from dakku::Ray Public Functions Name RayDifferential () =default RayDifferential (const Point3f & o, const Vector3f & d, float tMax =INF) bool hasNaNs () const check whether the ray differentials has nans void scaleDifferentials (float s) scale the differential of the ray Public Attributes Name bool hasDifferentials has differentials Point3f rxOrigin x sub ray origin (x + 1, y) Point3f ryOrigin y sub ray origin (x, y + 1) Vector3f rxDirection x sub ray direction Vector3f ryDirection y sub ray direction Additional inherited members Public Functions inherited from dakku::Ray Name Ray () =default Ray ( Point3f o, Vector3f d, float tMax =INF) Point3f operator() (float t) const get the point on the ray at \\(t\\) Public Attributes inherited from dakku::Ray Name Point3f o ray origin Vector3f d ray direction (note: it may not be normalized) float tMax Public Functions Documentation function RayDifferential RayDifferential () = default function RayDifferential inline explicit RayDifferential ( const Point3f & o , const Vector3f & d , float tMax = INF ) function hasNaNs inline bool hasNaNs () const check whether the ray differentials has nans function scaleDifferentials inline void scaleDifferentials ( float s ) scale the differential of the ray Parameters : s scale let \\(c\\) be the camera position \\(o'' = o + s (o \\rightarrow o')\\) \\(d' = c \\rightarrow o'\\) \\(d'' = c \\rightarrow o'' = (c \\rightarrow o) + (o \\rightarrow o'') = d + s (d' - d)\\) Public Attributes Documentation variable hasDifferentials bool hasDifferentials { false }; has differentials variable rxOrigin Point3f rxOrigin ; x sub ray origin (x + 1, y) variable ryOrigin Point3f ryOrigin ; y sub ray origin (x, y + 1) variable rxDirection Vector3f rxDirection ; x sub ray direction variable ryDirection Vector3f ryDirection ; y sub ray direction Updated on 2022-04-11 at 15:27:23 +0000","title":"dakku::RayDifferential"},{"location":"Classes/classdakku_1_1RayDifferential/#dakkuraydifferential","text":"differential ray #include <ray.h> Inherits from dakku::Ray","title":"dakku::RayDifferential"},{"location":"Classes/classdakku_1_1RayDifferential/#public-functions","text":"Name RayDifferential () =default RayDifferential (const Point3f & o, const Vector3f & d, float tMax =INF) bool hasNaNs () const check whether the ray differentials has nans void scaleDifferentials (float s) scale the differential of the ray","title":"Public Functions"},{"location":"Classes/classdakku_1_1RayDifferential/#public-attributes","text":"Name bool hasDifferentials has differentials Point3f rxOrigin x sub ray origin (x + 1, y) Point3f ryOrigin y sub ray origin (x, y + 1) Vector3f rxDirection x sub ray direction Vector3f ryDirection y sub ray direction","title":"Public Attributes"},{"location":"Classes/classdakku_1_1RayDifferential/#additional-inherited-members","text":"Public Functions inherited from dakku::Ray Name Ray () =default Ray ( Point3f o, Vector3f d, float tMax =INF) Point3f operator() (float t) const get the point on the ray at \\(t\\) Public Attributes inherited from dakku::Ray Name Point3f o ray origin Vector3f d ray direction (note: it may not be normalized) float tMax","title":"Additional inherited members"},{"location":"Classes/classdakku_1_1RayDifferential/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Classes/classdakku_1_1RayDifferential/#function-raydifferential","text":"RayDifferential () = default","title":"function RayDifferential"},{"location":"Classes/classdakku_1_1RayDifferential/#function-raydifferential_1","text":"inline explicit RayDifferential ( const Point3f & o , const Vector3f & d , float tMax = INF )","title":"function RayDifferential"},{"location":"Classes/classdakku_1_1RayDifferential/#function-hasnans","text":"inline bool hasNaNs () const check whether the ray differentials has nans","title":"function hasNaNs"},{"location":"Classes/classdakku_1_1RayDifferential/#function-scaledifferentials","text":"inline void scaleDifferentials ( float s ) scale the differential of the ray Parameters : s scale let \\(c\\) be the camera position \\(o'' = o + s (o \\rightarrow o')\\) \\(d' = c \\rightarrow o'\\) \\(d'' = c \\rightarrow o'' = (c \\rightarrow o) + (o \\rightarrow o'') = d + s (d' - d)\\)","title":"function scaleDifferentials"},{"location":"Classes/classdakku_1_1RayDifferential/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"Classes/classdakku_1_1RayDifferential/#variable-hasdifferentials","text":"bool hasDifferentials { false }; has differentials","title":"variable hasDifferentials"},{"location":"Classes/classdakku_1_1RayDifferential/#variable-rxorigin","text":"Point3f rxOrigin ; x sub ray origin (x + 1, y)","title":"variable rxOrigin"},{"location":"Classes/classdakku_1_1RayDifferential/#variable-ryorigin","text":"Point3f ryOrigin ; y sub ray origin (x, y + 1)","title":"variable ryOrigin"},{"location":"Classes/classdakku_1_1RayDifferential/#variable-rxdirection","text":"Vector3f rxDirection ; x sub ray direction","title":"variable rxDirection"},{"location":"Classes/classdakku_1_1RayDifferential/#variable-rydirection","text":"Vector3f ryDirection ; y sub ray direction Updated on 2022-04-11 at 15:27:23 +0000","title":"variable ryDirection"},{"location":"Classes/classdakku_1_1RelativeRoot/","text":"dakku::RelativeRoot utility to retrieve relative path (used for scene loading and saving) #include <relative.h> Public Functions Name RelativeRoot & instance () get the relative root instance const std::string & get () const get the path std::filesystem::path get (const std::filesystem::path & path) const add relative path to the given path std::string get (const std::string & path) const add relative path to the given path void set (const std::filesystem::path & root) set the relative root Public Functions Documentation function instance static RelativeRoot & instance () get the relative root instance Return : RelativeRoot & function get const std :: string & get () const get the path function get std :: filesystem :: path get ( const std :: filesystem :: path & path ) const add relative path to the given path function get std :: string get ( const std :: string & path ) const add relative path to the given path function set void set ( const std :: filesystem :: path & root ) set the relative root Updated on 2022-04-11 at 15:27:23 +0000","title":"dakku::RelativeRoot"},{"location":"Classes/classdakku_1_1RelativeRoot/#dakkurelativeroot","text":"utility to retrieve relative path (used for scene loading and saving) #include <relative.h>","title":"dakku::RelativeRoot"},{"location":"Classes/classdakku_1_1RelativeRoot/#public-functions","text":"Name RelativeRoot & instance () get the relative root instance const std::string & get () const get the path std::filesystem::path get (const std::filesystem::path & path) const add relative path to the given path std::string get (const std::string & path) const add relative path to the given path void set (const std::filesystem::path & root) set the relative root","title":"Public Functions"},{"location":"Classes/classdakku_1_1RelativeRoot/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Classes/classdakku_1_1RelativeRoot/#function-instance","text":"static RelativeRoot & instance () get the relative root instance Return : RelativeRoot &","title":"function instance"},{"location":"Classes/classdakku_1_1RelativeRoot/#function-get","text":"const std :: string & get () const get the path","title":"function get"},{"location":"Classes/classdakku_1_1RelativeRoot/#function-get_1","text":"std :: filesystem :: path get ( const std :: filesystem :: path & path ) const add relative path to the given path","title":"function get"},{"location":"Classes/classdakku_1_1RelativeRoot/#function-get_2","text":"std :: string get ( const std :: string & path ) const add relative path to the given path","title":"function get"},{"location":"Classes/classdakku_1_1RelativeRoot/#function-set","text":"void set ( const std :: filesystem :: path & root ) set the relative root Updated on 2022-04-11 at 15:27:23 +0000","title":"function set"},{"location":"Classes/classdakku_1_1RgbSpectrum/","text":"dakku::RgbSpectrum spectrum that only use r, g, b #include <spectrum.h> Inherits from dakku::CoefficientSpectrum< 3, RgbSpectrum > , dakku::VectorBase< float, S, Derived > Public Functions Name RgbSpectrum fromRgb (std::span< const float, 3 > rgb) RgbSpectrum fromXyz (std::span< const float, 3 > xyz) void toRgb (std::span< float, 3 > rgb) const void toXyz (std::span< float, 3 > xyz) const Additional inherited members Public Functions inherited from dakku::CoefficientSpectrum< 3, RgbSpectrum > Name bool isBlack () const whether the spectrum is black Derived clamp (float low =0, float high =INF) const element-wise clamp Public Functions inherited from dakku::VectorBase< float, S, Derived > Name VectorBase () Construct a new Vector Base object with all components initialized to zero. template <ArithmeticType Arg> VectorBase (Arg value) Construct a new Vector Base object with all components initialized to value template <ArithmeticType Other,typename OtherDerived > VectorBase (const VectorBase < Other, S, OtherDerived > & other) Construct a new Vector Base object with a vector expression. VectorBase (const VectorBase & other) VectorBase ( VectorBase && other) VectorBase & operator= (const VectorBase & other) VectorBase & operator= ( VectorBase && other) template <ArithmeticType Arg> void set (Arg value) Construct a new Vector Base object with given values. template <ArithmeticType Arg> void setByIndex (size_t index, Arg value) set data[index] to value template <ArithmeticType... Args,size_t... Is> void set (std::index_sequence< Is... > , Args &&... args) set data to args template <ArithmeticType... Args> void set (Args &&... args) set data to args template <ArithmeticType Other,typename OtherDerived > void set (const VectorBase < Other, S, OtherDerived > & rhs) set data by rhs 's data bool hasNaNs () const check whether there are nan components const T & get (size_t i) const get i'th component std::string toString () const convert vector to string size_t size () const size of the vector const T & operator[] (size_t i) const get i'th value T & operator[] (size_t i) get i'th value Derived operator- () const negation of the vector const Derived & derived () const get derived class Derived & derived () get derived class Derived & operator+= (const Derived & rhs) addition template <ArithmeticType V> Derived & operator+= (const V & rhs) addition Derived & operator-= (const Derived & rhs) subtraction template <ArithmeticType V> Derived & operator-= (const V & rhs) subtraction Derived & operator*= (const Derived & rhs) multiplication template <ArithmeticType V> Derived & operator*= (const V & rhs) multiplication Derived & operator/= (const Derived & rhs) division template <ArithmeticType V> Derived & operator/= (const V & rhs) division std::vector< float > toFloatVector () const convert this to float vector (Property::VECTOR) VectorBase (const std::vector< float > & v) Construct a new Vector Base object with std::vector (Property::VECTOR) decltype(auto) x () const get the first element decltype(auto) x () get the first element decltype(auto) y () const get the second element decltype(auto) y () get the second element decltype(auto) z () const get the third element decltype(auto) z () get the fourth element decltype(auto) w () const get the fourth element decltype(auto) w () get the third element size_t maxElementIndex () const get the index of the max element decltype(auto) maxElement () const get the max element in the vector decltype(auto) begin () decltype(auto) begin () const decltype(auto) end () decltype(auto) end () const decltype(auto) normalized () const normalized vector Derived & normalize () normalize this template <typename OtherDerived > decltype(auto) dot (const VectorBase < T, S, OtherDerived > & rhs) const dot product between two vectors decltype(auto) squaredNorm () const squared norm decltype(auto) norm () const norm decltype(auto) length () const length Derived cross (const Derived & rhs) const cross product bool isZero () const check whether all components are zero operator std::span< T, S > () operator std::span< const T, S > () const Protected Attributes inherited from dakku::VectorBase< float, S, Derived > Name std::array< T, S > _data vector base data Friends inherited from dakku::VectorBase< float, S, Derived > Name std::ostream & operator<< (std::ostream & os, const VectorBase & vec) output the vector Derived operator+ (const Derived & a, const Derived & b) addition Derived operator+ (const Derived & a, const U & b) addition Derived operator+ (const U & a, const Derived & b) addition Derived operator- (const Derived & a, const U & b) subtraction Derived operator- (const U & a, const Derived & b) subtraction Derived operator* (const Derived & a, const Derived & b) multiplication Derived operator* (const Derived & a, const U & b) multiplication Derived operator* (const U & a, const Derived & b) multiplication Derived operator/ (const Derived & a, const Derived & b) division Derived operator/ (const Derived & a, const U & b) division Derived operator/ (const U & a, const Derived & b) division bool operator== (const Derived & a, const Derived & b) a == b (element wise) bool operator!= (const Derived & a, const Derived & b) a != b (element wise) Derived max (const Derived & v1, const Derived & v2) element wise max Derived min (const Derived & v1, const Derived & v2) element wise min Derived normalize (const Derived & v) normalized vector decltype(auto) distance (const Derived & a, const Derived & b) the distance decltype(auto) abs (const Derived & v) abs Derived sqrt (const Derived & v) element-wise sqrt Derived pow (const Derived & v, E e) element-wise power Derived exp (const Derived & v) element-wise exp Derived floor (const Derived & v) element-wise floor Derived ceil (const Derived & v) element-wise ceil Derived lerp (const Derived & a, const Derived & b, T t) element-wise linear interpolation Public Functions Documentation function fromRgb static inline RgbSpectrum fromRgb ( std :: span < const float , 3 > rgb ) function fromXyz static inline RgbSpectrum fromXyz ( std :: span < const float , 3 > xyz ) function toRgb inline void toRgb ( std :: span < float , 3 > rgb ) const function toXyz inline void toXyz ( std :: span < float , 3 > xyz ) const Updated on 2022-04-11 at 15:27:23 +0000","title":"dakku::RgbSpectrum"},{"location":"Classes/classdakku_1_1RgbSpectrum/#dakkurgbspectrum","text":"spectrum that only use r, g, b #include <spectrum.h> Inherits from dakku::CoefficientSpectrum< 3, RgbSpectrum > , dakku::VectorBase< float, S, Derived >","title":"dakku::RgbSpectrum"},{"location":"Classes/classdakku_1_1RgbSpectrum/#public-functions","text":"Name RgbSpectrum fromRgb (std::span< const float, 3 > rgb) RgbSpectrum fromXyz (std::span< const float, 3 > xyz) void toRgb (std::span< float, 3 > rgb) const void toXyz (std::span< float, 3 > xyz) const","title":"Public Functions"},{"location":"Classes/classdakku_1_1RgbSpectrum/#additional-inherited-members","text":"Public Functions inherited from dakku::CoefficientSpectrum< 3, RgbSpectrum > Name bool isBlack () const whether the spectrum is black Derived clamp (float low =0, float high =INF) const element-wise clamp Public Functions inherited from dakku::VectorBase< float, S, Derived > Name VectorBase () Construct a new Vector Base object with all components initialized to zero. template <ArithmeticType Arg> VectorBase (Arg value) Construct a new Vector Base object with all components initialized to value template <ArithmeticType Other,typename OtherDerived > VectorBase (const VectorBase < Other, S, OtherDerived > & other) Construct a new Vector Base object with a vector expression. VectorBase (const VectorBase & other) VectorBase ( VectorBase && other) VectorBase & operator= (const VectorBase & other) VectorBase & operator= ( VectorBase && other) template <ArithmeticType Arg> void set (Arg value) Construct a new Vector Base object with given values. template <ArithmeticType Arg> void setByIndex (size_t index, Arg value) set data[index] to value template <ArithmeticType... Args,size_t... Is> void set (std::index_sequence< Is... > , Args &&... args) set data to args template <ArithmeticType... Args> void set (Args &&... args) set data to args template <ArithmeticType Other,typename OtherDerived > void set (const VectorBase < Other, S, OtherDerived > & rhs) set data by rhs 's data bool hasNaNs () const check whether there are nan components const T & get (size_t i) const get i'th component std::string toString () const convert vector to string size_t size () const size of the vector const T & operator[] (size_t i) const get i'th value T & operator[] (size_t i) get i'th value Derived operator- () const negation of the vector const Derived & derived () const get derived class Derived & derived () get derived class Derived & operator+= (const Derived & rhs) addition template <ArithmeticType V> Derived & operator+= (const V & rhs) addition Derived & operator-= (const Derived & rhs) subtraction template <ArithmeticType V> Derived & operator-= (const V & rhs) subtraction Derived & operator*= (const Derived & rhs) multiplication template <ArithmeticType V> Derived & operator*= (const V & rhs) multiplication Derived & operator/= (const Derived & rhs) division template <ArithmeticType V> Derived & operator/= (const V & rhs) division std::vector< float > toFloatVector () const convert this to float vector (Property::VECTOR) VectorBase (const std::vector< float > & v) Construct a new Vector Base object with std::vector (Property::VECTOR) decltype(auto) x () const get the first element decltype(auto) x () get the first element decltype(auto) y () const get the second element decltype(auto) y () get the second element decltype(auto) z () const get the third element decltype(auto) z () get the fourth element decltype(auto) w () const get the fourth element decltype(auto) w () get the third element size_t maxElementIndex () const get the index of the max element decltype(auto) maxElement () const get the max element in the vector decltype(auto) begin () decltype(auto) begin () const decltype(auto) end () decltype(auto) end () const decltype(auto) normalized () const normalized vector Derived & normalize () normalize this template <typename OtherDerived > decltype(auto) dot (const VectorBase < T, S, OtherDerived > & rhs) const dot product between two vectors decltype(auto) squaredNorm () const squared norm decltype(auto) norm () const norm decltype(auto) length () const length Derived cross (const Derived & rhs) const cross product bool isZero () const check whether all components are zero operator std::span< T, S > () operator std::span< const T, S > () const Protected Attributes inherited from dakku::VectorBase< float, S, Derived > Name std::array< T, S > _data vector base data Friends inherited from dakku::VectorBase< float, S, Derived > Name std::ostream & operator<< (std::ostream & os, const VectorBase & vec) output the vector Derived operator+ (const Derived & a, const Derived & b) addition Derived operator+ (const Derived & a, const U & b) addition Derived operator+ (const U & a, const Derived & b) addition Derived operator- (const Derived & a, const U & b) subtraction Derived operator- (const U & a, const Derived & b) subtraction Derived operator* (const Derived & a, const Derived & b) multiplication Derived operator* (const Derived & a, const U & b) multiplication Derived operator* (const U & a, const Derived & b) multiplication Derived operator/ (const Derived & a, const Derived & b) division Derived operator/ (const Derived & a, const U & b) division Derived operator/ (const U & a, const Derived & b) division bool operator== (const Derived & a, const Derived & b) a == b (element wise) bool operator!= (const Derived & a, const Derived & b) a != b (element wise) Derived max (const Derived & v1, const Derived & v2) element wise max Derived min (const Derived & v1, const Derived & v2) element wise min Derived normalize (const Derived & v) normalized vector decltype(auto) distance (const Derived & a, const Derived & b) the distance decltype(auto) abs (const Derived & v) abs Derived sqrt (const Derived & v) element-wise sqrt Derived pow (const Derived & v, E e) element-wise power Derived exp (const Derived & v) element-wise exp Derived floor (const Derived & v) element-wise floor Derived ceil (const Derived & v) element-wise ceil Derived lerp (const Derived & a, const Derived & b, T t) element-wise linear interpolation","title":"Additional inherited members"},{"location":"Classes/classdakku_1_1RgbSpectrum/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Classes/classdakku_1_1RgbSpectrum/#function-fromrgb","text":"static inline RgbSpectrum fromRgb ( std :: span < const float , 3 > rgb )","title":"function fromRgb"},{"location":"Classes/classdakku_1_1RgbSpectrum/#function-fromxyz","text":"static inline RgbSpectrum fromXyz ( std :: span < const float , 3 > xyz )","title":"function fromXyz"},{"location":"Classes/classdakku_1_1RgbSpectrum/#function-torgb","text":"inline void toRgb ( std :: span < float , 3 > rgb ) const","title":"function toRgb"},{"location":"Classes/classdakku_1_1RgbSpectrum/#function-toxyz","text":"inline void toXyz ( std :: span < float , 3 > xyz ) const Updated on 2022-04-11 at 15:27:23 +0000","title":"function toXyz"},{"location":"Classes/classdakku_1_1SerializableObject/","text":"dakku::SerializableObject serializable object #include <serialization.h> Inherits from dakku::Object Inherited by dakku::Film Public Functions Name DAKKU_DECLARE_OBJECT ( SerializableObject , Object ) virtual void serialize ( OutputStream * stream) const =0 serialize the object (do not include the property part) virtual void deserialize ( InputStream * stream) =0 deserialize the object (do not include the property part) Additional inherited members Public Functions inherited from dakku::Object Name virtual ~Object () =default Object (const Property & ={}) virtual std::string getClassName () const virtual std::string getParentName () const virtual std::string toString () const bool isDerivedFrom (std::string_view name) const whther the object is derived from name (inclusive) bool isBaseOf (std::string_view name) const whether the object is base of name (inclusive) std::string getClassNameStatic () std::string getParentNameStatic () Public Functions Documentation function DAKKU_DECLARE_OBJECT DAKKU_DECLARE_OBJECT ( SerializableObject , Object ) function serialize virtual void serialize ( OutputStream * stream ) const = 0 serialize the object (do not include the property part) Parameters : stream Reimplemented by : dakku::Film::serialize function deserialize virtual void deserialize ( InputStream * stream ) = 0 deserialize the object (do not include the property part) Parameters : stream Reimplemented by : dakku::Film::deserialize Updated on 2022-04-11 at 15:27:23 +0000","title":"dakku::SerializableObject"},{"location":"Classes/classdakku_1_1SerializableObject/#dakkuserializableobject","text":"serializable object #include <serialization.h> Inherits from dakku::Object Inherited by dakku::Film","title":"dakku::SerializableObject"},{"location":"Classes/classdakku_1_1SerializableObject/#public-functions","text":"Name DAKKU_DECLARE_OBJECT ( SerializableObject , Object ) virtual void serialize ( OutputStream * stream) const =0 serialize the object (do not include the property part) virtual void deserialize ( InputStream * stream) =0 deserialize the object (do not include the property part)","title":"Public Functions"},{"location":"Classes/classdakku_1_1SerializableObject/#additional-inherited-members","text":"Public Functions inherited from dakku::Object Name virtual ~Object () =default Object (const Property & ={}) virtual std::string getClassName () const virtual std::string getParentName () const virtual std::string toString () const bool isDerivedFrom (std::string_view name) const whther the object is derived from name (inclusive) bool isBaseOf (std::string_view name) const whether the object is base of name (inclusive) std::string getClassNameStatic () std::string getParentNameStatic ()","title":"Additional inherited members"},{"location":"Classes/classdakku_1_1SerializableObject/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Classes/classdakku_1_1SerializableObject/#function-dakku_declare_object","text":"DAKKU_DECLARE_OBJECT ( SerializableObject , Object )","title":"function DAKKU_DECLARE_OBJECT"},{"location":"Classes/classdakku_1_1SerializableObject/#function-serialize","text":"virtual void serialize ( OutputStream * stream ) const = 0 serialize the object (do not include the property part) Parameters : stream Reimplemented by : dakku::Film::serialize","title":"function serialize"},{"location":"Classes/classdakku_1_1SerializableObject/#function-deserialize","text":"virtual void deserialize ( InputStream * stream ) = 0 deserialize the object (do not include the property part) Parameters : stream Reimplemented by : dakku::Film::deserialize Updated on 2022-04-11 at 15:27:23 +0000","title":"function deserialize"},{"location":"Classes/classdakku_1_1Shape/","text":"dakku::Shape #include <shape.h> Inherits from dakku::Object Public Functions Name DAKKU_DECLARE_OBJECT ( Shape , Object ) Shape (const Transform * objectToWorld, const Transform * worldToObject) Construct a new Shape object with given transform. virtual Bounds3f objectBound () const =0 get object bounding box virtual Bounds3f worldBound () const =0 get world bounding box Additional inherited members Public Functions inherited from dakku::Object Name virtual ~Object () =default Object (const Property & ={}) virtual std::string getClassName () const virtual std::string getParentName () const virtual std::string toString () const bool isDerivedFrom (std::string_view name) const whther the object is derived from name (inclusive) bool isBaseOf (std::string_view name) const whether the object is base of name (inclusive) std::string getClassNameStatic () std::string getParentNameStatic () Public Functions Documentation function DAKKU_DECLARE_OBJECT DAKKU_DECLARE_OBJECT ( Shape , Object ) function Shape explicit Shape ( const Transform * objectToWorld , const Transform * worldToObject ) Construct a new Shape object with given transform. function objectBound virtual Bounds3f objectBound () const = 0 get object bounding box function worldBound virtual Bounds3f worldBound () const = 0 get world bounding box Updated on 2022-04-11 at 15:27:23 +0000","title":"dakku::Shape"},{"location":"Classes/classdakku_1_1Shape/#dakkushape","text":"#include <shape.h> Inherits from dakku::Object","title":"dakku::Shape"},{"location":"Classes/classdakku_1_1Shape/#public-functions","text":"Name DAKKU_DECLARE_OBJECT ( Shape , Object ) Shape (const Transform * objectToWorld, const Transform * worldToObject) Construct a new Shape object with given transform. virtual Bounds3f objectBound () const =0 get object bounding box virtual Bounds3f worldBound () const =0 get world bounding box","title":"Public Functions"},{"location":"Classes/classdakku_1_1Shape/#additional-inherited-members","text":"Public Functions inherited from dakku::Object Name virtual ~Object () =default Object (const Property & ={}) virtual std::string getClassName () const virtual std::string getParentName () const virtual std::string toString () const bool isDerivedFrom (std::string_view name) const whther the object is derived from name (inclusive) bool isBaseOf (std::string_view name) const whether the object is base of name (inclusive) std::string getClassNameStatic () std::string getParentNameStatic ()","title":"Additional inherited members"},{"location":"Classes/classdakku_1_1Shape/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Classes/classdakku_1_1Shape/#function-dakku_declare_object","text":"DAKKU_DECLARE_OBJECT ( Shape , Object )","title":"function DAKKU_DECLARE_OBJECT"},{"location":"Classes/classdakku_1_1Shape/#function-shape","text":"explicit Shape ( const Transform * objectToWorld , const Transform * worldToObject ) Construct a new Shape object with given transform.","title":"function Shape"},{"location":"Classes/classdakku_1_1Shape/#function-objectbound","text":"virtual Bounds3f objectBound () const = 0 get object bounding box","title":"function objectBound"},{"location":"Classes/classdakku_1_1Shape/#function-worldbound","text":"virtual Bounds3f worldBound () const = 0 get world bounding box Updated on 2022-04-11 at 15:27:23 +0000","title":"function worldBound"},{"location":"Classes/classdakku_1_1SurfaceInteraction/","text":"dakku::SurfaceInteraction surface interaction #include <interaction.h> Inherits from dakku::Interaction Public Attributes Name Point2f uv float dudx float dvdx float dudy float dvdy Additional inherited members Public Functions inherited from dakku::Interaction Name Interaction () =default Interaction ( Point3f p, const Vector3f & wo, Normal3f n) bool isSurfaceInteraction () const check whether the interaction is surface interaction surface interaction contains non-zero normal \\(\\vec n\\) bool isMediumInteraction () const check whether the interaction is medium interaction Ray spawnRay (const Vector3f & d) const spawn a ray to the given direction Ray spawnRayTo (const Point3f & q) const spawn ray \\(p \\rightarrow q\\) Ray spawnRayTo (const Interaction & it) const spawn ray \\(p \\rightarrow it.p\\) Public Attributes inherited from dakku::Interaction Name Point3f p interaction point Vector3f wo outgoing direction Normal3f n normal Public Attributes Documentation variable uv Point2f uv ; variable dudx float dudx = 0 ; variable dvdx float dvdx = 0 ; variable dudy float dudy = 0 ; variable dvdy float dvdy = 0 ; Updated on 2022-04-11 at 15:27:23 +0000","title":"dakku::SurfaceInteraction"},{"location":"Classes/classdakku_1_1SurfaceInteraction/#dakkusurfaceinteraction","text":"surface interaction #include <interaction.h> Inherits from dakku::Interaction","title":"dakku::SurfaceInteraction"},{"location":"Classes/classdakku_1_1SurfaceInteraction/#public-attributes","text":"Name Point2f uv float dudx float dvdx float dudy float dvdy","title":"Public Attributes"},{"location":"Classes/classdakku_1_1SurfaceInteraction/#additional-inherited-members","text":"Public Functions inherited from dakku::Interaction Name Interaction () =default Interaction ( Point3f p, const Vector3f & wo, Normal3f n) bool isSurfaceInteraction () const check whether the interaction is surface interaction surface interaction contains non-zero normal \\(\\vec n\\) bool isMediumInteraction () const check whether the interaction is medium interaction Ray spawnRay (const Vector3f & d) const spawn a ray to the given direction Ray spawnRayTo (const Point3f & q) const spawn ray \\(p \\rightarrow q\\) Ray spawnRayTo (const Interaction & it) const spawn ray \\(p \\rightarrow it.p\\) Public Attributes inherited from dakku::Interaction Name Point3f p interaction point Vector3f wo outgoing direction Normal3f n normal","title":"Additional inherited members"},{"location":"Classes/classdakku_1_1SurfaceInteraction/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"Classes/classdakku_1_1SurfaceInteraction/#variable-uv","text":"Point2f uv ;","title":"variable uv"},{"location":"Classes/classdakku_1_1SurfaceInteraction/#variable-dudx","text":"float dudx = 0 ;","title":"variable dudx"},{"location":"Classes/classdakku_1_1SurfaceInteraction/#variable-dvdx","text":"float dvdx = 0 ;","title":"variable dvdx"},{"location":"Classes/classdakku_1_1SurfaceInteraction/#variable-dudy","text":"float dudy = 0 ;","title":"variable dudy"},{"location":"Classes/classdakku_1_1SurfaceInteraction/#variable-dvdy","text":"float dvdy = 0 ; Updated on 2022-04-11 at 15:27:23 +0000","title":"variable dvdy"},{"location":"Classes/classdakku_1_1Texture/","text":"dakku::Texture #include <texture.h> Inherits from dakku::Object Inherited by dakku::ConstantTexture , dakku::ImageTexture Public Functions Name DAKKU_DECLARE_OBJECT ( Texture , Object ) Texture (bool floatType) virtual Spectrum evaluate (const SurfaceInteraction & ) const =0 Protected Attributes Name bool floatType Additional inherited members Public Functions inherited from dakku::Object Name virtual ~Object () =default Object (const Property & ={}) virtual std::string getClassName () const virtual std::string getParentName () const virtual std::string toString () const bool isDerivedFrom (std::string_view name) const whther the object is derived from name (inclusive) bool isBaseOf (std::string_view name) const whether the object is base of name (inclusive) std::string getClassNameStatic () std::string getParentNameStatic () Public Functions Documentation function DAKKU_DECLARE_OBJECT DAKKU_DECLARE_OBJECT ( Texture , Object ) function Texture explicit Texture ( bool floatType ) function evaluate virtual Spectrum evaluate ( const SurfaceInteraction & ) const = 0 Reimplemented by : dakku::ConstantTexture::evaluate , dakku::ImageTexture::evaluate Protected Attributes Documentation variable floatType bool floatType {}; Updated on 2022-04-11 at 15:27:23 +0000","title":"dakku::Texture"},{"location":"Classes/classdakku_1_1Texture/#dakkutexture","text":"#include <texture.h> Inherits from dakku::Object Inherited by dakku::ConstantTexture , dakku::ImageTexture","title":"dakku::Texture"},{"location":"Classes/classdakku_1_1Texture/#public-functions","text":"Name DAKKU_DECLARE_OBJECT ( Texture , Object ) Texture (bool floatType) virtual Spectrum evaluate (const SurfaceInteraction & ) const =0","title":"Public Functions"},{"location":"Classes/classdakku_1_1Texture/#protected-attributes","text":"Name bool floatType","title":"Protected Attributes"},{"location":"Classes/classdakku_1_1Texture/#additional-inherited-members","text":"Public Functions inherited from dakku::Object Name virtual ~Object () =default Object (const Property & ={}) virtual std::string getClassName () const virtual std::string getParentName () const virtual std::string toString () const bool isDerivedFrom (std::string_view name) const whther the object is derived from name (inclusive) bool isBaseOf (std::string_view name) const whether the object is base of name (inclusive) std::string getClassNameStatic () std::string getParentNameStatic ()","title":"Additional inherited members"},{"location":"Classes/classdakku_1_1Texture/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Classes/classdakku_1_1Texture/#function-dakku_declare_object","text":"DAKKU_DECLARE_OBJECT ( Texture , Object )","title":"function DAKKU_DECLARE_OBJECT"},{"location":"Classes/classdakku_1_1Texture/#function-texture","text":"explicit Texture ( bool floatType )","title":"function Texture"},{"location":"Classes/classdakku_1_1Texture/#function-evaluate","text":"virtual Spectrum evaluate ( const SurfaceInteraction & ) const = 0 Reimplemented by : dakku::ConstantTexture::evaluate , dakku::ImageTexture::evaluate","title":"function evaluate"},{"location":"Classes/classdakku_1_1Texture/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"Classes/classdakku_1_1Texture/#variable-floattype","text":"bool floatType {}; Updated on 2022-04-11 at 15:27:23 +0000","title":"variable floatType"},{"location":"Classes/classdakku_1_1TextureMapping2D/","text":"dakku::TextureMapping2D 2d texture mapping #include <texture.h> Inherits from dakku::Object Inherited by dakku::UvMapping2D Public Functions Name DAKKU_DECLARE_OBJECT ( TextureMapping2D , Object ) virtual Point2f map (const SurfaceInteraction & si, Vector2f & dstdx, Vector2f & dstdy) const =0 Additional inherited members Public Functions inherited from dakku::Object Name virtual ~Object () =default Object (const Property & ={}) virtual std::string getClassName () const virtual std::string getParentName () const virtual std::string toString () const bool isDerivedFrom (std::string_view name) const whther the object is derived from name (inclusive) bool isBaseOf (std::string_view name) const whether the object is base of name (inclusive) std::string getClassNameStatic () std::string getParentNameStatic () Public Functions Documentation function DAKKU_DECLARE_OBJECT DAKKU_DECLARE_OBJECT ( TextureMapping2D , Object ) function map virtual Point2f map ( const SurfaceInteraction & si , Vector2f & dstdx , Vector2f & dstdy ) const = 0 Reimplemented by : dakku::UvMapping2D::map Updated on 2022-04-11 at 15:27:23 +0000","title":"dakku::TextureMapping2D"},{"location":"Classes/classdakku_1_1TextureMapping2D/#dakkutexturemapping2d","text":"2d texture mapping #include <texture.h> Inherits from dakku::Object Inherited by dakku::UvMapping2D","title":"dakku::TextureMapping2D"},{"location":"Classes/classdakku_1_1TextureMapping2D/#public-functions","text":"Name DAKKU_DECLARE_OBJECT ( TextureMapping2D , Object ) virtual Point2f map (const SurfaceInteraction & si, Vector2f & dstdx, Vector2f & dstdy) const =0","title":"Public Functions"},{"location":"Classes/classdakku_1_1TextureMapping2D/#additional-inherited-members","text":"Public Functions inherited from dakku::Object Name virtual ~Object () =default Object (const Property & ={}) virtual std::string getClassName () const virtual std::string getParentName () const virtual std::string toString () const bool isDerivedFrom (std::string_view name) const whther the object is derived from name (inclusive) bool isBaseOf (std::string_view name) const whether the object is base of name (inclusive) std::string getClassNameStatic () std::string getParentNameStatic ()","title":"Additional inherited members"},{"location":"Classes/classdakku_1_1TextureMapping2D/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Classes/classdakku_1_1TextureMapping2D/#function-dakku_declare_object","text":"DAKKU_DECLARE_OBJECT ( TextureMapping2D , Object )","title":"function DAKKU_DECLARE_OBJECT"},{"location":"Classes/classdakku_1_1TextureMapping2D/#function-map","text":"virtual Point2f map ( const SurfaceInteraction & si , Vector2f & dstdx , Vector2f & dstdy ) const = 0 Reimplemented by : dakku::UvMapping2D::map Updated on 2022-04-11 at 15:27:23 +0000","title":"function map"},{"location":"Classes/classdakku_1_1Transform/","text":"dakku::Transform #include <transform.h> Public Functions Name Transform () =default Transform (const Matrix4x4 & m) Transform (const Matrix4x4 & m, const Matrix4x4 & mInv) bool operator== (const Transform & rhs) const bool operator!= (const Transform & rhs) const bool operator< (const Transform & rhs) const bool isIdentity () const whether this is an identity transform const Matrix4x4 & getMatrix () const Get the Matrix object. const Matrix4x4 & getInverseMatrix () const Get the Inverse Matrix object. template <ArithmeticType T> Point3 < T > operator() (const Point3 < T > & p) const transform a point template <ArithmeticType T> Vector3 < T > operator() (const Vector3 < T > & v) const transform a vector template <ArithmeticType T> Normal3 < T > operator() (const Normal3 < T > & n) const transform a normal Ray operator() (const Ray & r) const transform a ray RayDifferential operator() (const RayDifferential & r) const transform a ray differential Transform operator* (const Transform & rhs) const bool swapsHandedNess () const whether the transform swaps handedness Friends Name Transform inverse ( Transform & t) transform inverse Transform transpose ( Transform & t) Public Functions Documentation function Transform Transform () = default function Transform inline Transform ( const Matrix4x4 & m ) function Transform inline Transform ( const Matrix4x4 & m , const Matrix4x4 & mInv ) function operator== inline bool operator == ( const Transform & rhs ) const function operator!= inline bool operator != ( const Transform & rhs ) const function operator< inline bool operator < ( const Transform & rhs ) const function isIdentity inline bool isIdentity () const whether this is an identity transform function getMatrix inline const Matrix4x4 & getMatrix () const Get the Matrix object. function getInverseMatrix inline const Matrix4x4 & getInverseMatrix () const Get the Inverse Matrix object. function operator() template < ArithmeticType T > inline Point3 < T > operator ()( const Point3 < T > & p ) const transform a point function operator() template < ArithmeticType T > inline Vector3 < T > operator ()( const Vector3 < T > & v ) const transform a vector function operator() template < ArithmeticType T > inline Normal3 < T > operator ()( const Normal3 < T > & n ) const transform a normal function operator() inline Ray operator ()( const Ray & r ) const transform a ray function operator() inline RayDifferential operator ()( const RayDifferential & r ) const transform a ray differential function operator* inline Transform operator * ( const Transform & rhs ) const function swapsHandedNess inline bool swapsHandedNess () const whether the transform swaps handedness Friends friend inverse friend Transform inverse ( Transform & t ); transform inverse friend transpose friend Transform transpose ( Transform & t ); Updated on 2022-04-11 at 15:27:23 +0000","title":"dakku::Transform"},{"location":"Classes/classdakku_1_1Transform/#dakkutransform","text":"#include <transform.h>","title":"dakku::Transform"},{"location":"Classes/classdakku_1_1Transform/#public-functions","text":"Name Transform () =default Transform (const Matrix4x4 & m) Transform (const Matrix4x4 & m, const Matrix4x4 & mInv) bool operator== (const Transform & rhs) const bool operator!= (const Transform & rhs) const bool operator< (const Transform & rhs) const bool isIdentity () const whether this is an identity transform const Matrix4x4 & getMatrix () const Get the Matrix object. const Matrix4x4 & getInverseMatrix () const Get the Inverse Matrix object. template <ArithmeticType T> Point3 < T > operator() (const Point3 < T > & p) const transform a point template <ArithmeticType T> Vector3 < T > operator() (const Vector3 < T > & v) const transform a vector template <ArithmeticType T> Normal3 < T > operator() (const Normal3 < T > & n) const transform a normal Ray operator() (const Ray & r) const transform a ray RayDifferential operator() (const RayDifferential & r) const transform a ray differential Transform operator* (const Transform & rhs) const bool swapsHandedNess () const whether the transform swaps handedness","title":"Public Functions"},{"location":"Classes/classdakku_1_1Transform/#friends","text":"Name Transform inverse ( Transform & t) transform inverse Transform transpose ( Transform & t)","title":"Friends"},{"location":"Classes/classdakku_1_1Transform/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Classes/classdakku_1_1Transform/#function-transform","text":"Transform () = default","title":"function Transform"},{"location":"Classes/classdakku_1_1Transform/#function-transform_1","text":"inline Transform ( const Matrix4x4 & m )","title":"function Transform"},{"location":"Classes/classdakku_1_1Transform/#function-transform_2","text":"inline Transform ( const Matrix4x4 & m , const Matrix4x4 & mInv )","title":"function Transform"},{"location":"Classes/classdakku_1_1Transform/#function-operator","text":"inline bool operator == ( const Transform & rhs ) const","title":"function operator=="},{"location":"Classes/classdakku_1_1Transform/#function-operator_1","text":"inline bool operator != ( const Transform & rhs ) const","title":"function operator!="},{"location":"Classes/classdakku_1_1Transform/#function-operator_2","text":"inline bool operator < ( const Transform & rhs ) const","title":"function operator&lt;"},{"location":"Classes/classdakku_1_1Transform/#function-isidentity","text":"inline bool isIdentity () const whether this is an identity transform","title":"function isIdentity"},{"location":"Classes/classdakku_1_1Transform/#function-getmatrix","text":"inline const Matrix4x4 & getMatrix () const Get the Matrix object.","title":"function getMatrix"},{"location":"Classes/classdakku_1_1Transform/#function-getinversematrix","text":"inline const Matrix4x4 & getInverseMatrix () const Get the Inverse Matrix object.","title":"function getInverseMatrix"},{"location":"Classes/classdakku_1_1Transform/#function-operator_3","text":"template < ArithmeticType T > inline Point3 < T > operator ()( const Point3 < T > & p ) const transform a point","title":"function operator()"},{"location":"Classes/classdakku_1_1Transform/#function-operator_4","text":"template < ArithmeticType T > inline Vector3 < T > operator ()( const Vector3 < T > & v ) const transform a vector","title":"function operator()"},{"location":"Classes/classdakku_1_1Transform/#function-operator_5","text":"template < ArithmeticType T > inline Normal3 < T > operator ()( const Normal3 < T > & n ) const transform a normal","title":"function operator()"},{"location":"Classes/classdakku_1_1Transform/#function-operator_6","text":"inline Ray operator ()( const Ray & r ) const transform a ray","title":"function operator()"},{"location":"Classes/classdakku_1_1Transform/#function-operator_7","text":"inline RayDifferential operator ()( const RayDifferential & r ) const transform a ray differential","title":"function operator()"},{"location":"Classes/classdakku_1_1Transform/#function-operator_8","text":"inline Transform operator * ( const Transform & rhs ) const","title":"function operator*"},{"location":"Classes/classdakku_1_1Transform/#function-swapshandedness","text":"inline bool swapsHandedNess () const whether the transform swaps handedness","title":"function swapsHandedNess"},{"location":"Classes/classdakku_1_1Transform/#friends_1","text":"","title":"Friends"},{"location":"Classes/classdakku_1_1Transform/#friend-inverse","text":"friend Transform inverse ( Transform & t ); transform inverse","title":"friend inverse"},{"location":"Classes/classdakku_1_1Transform/#friend-transpose","text":"friend Transform transpose ( Transform & t ); Updated on 2022-04-11 at 15:27:23 +0000","title":"friend transpose"},{"location":"Classes/classdakku_1_1TriangleFilter/","text":"dakku::TriangleFilter triangle filter the weight falls off linearly from the filter center over the square extent of the filter #include <triangle.h> Inherits from dakku::Filter , dakku::Object Public Functions Name DAKKU_DECLARE_OBJECT ( TriangleFilter , Filter ) virtual float evaluate (const Point2f & p) const override Given a 2D point which is relative to the center of the filter, the filter's value at that point is returned. Filter (const Vector2f & radius) Construct a new Filter object The filter's overall extent in each direction is twice the value given in radius Additional inherited members Public Attributes inherited from dakku::Filter Name const Vector2f radius filter radius const Vector2f invRadius filter radius inversion Public Functions inherited from dakku::Object Name virtual ~Object () =default Object (const Property & ={}) virtual std::string getClassName () const virtual std::string getParentName () const virtual std::string toString () const bool isDerivedFrom (std::string_view name) const whther the object is derived from name (inclusive) bool isBaseOf (std::string_view name) const whether the object is base of name (inclusive) std::string getClassNameStatic () std::string getParentNameStatic () Public Functions Documentation function DAKKU_DECLARE_OBJECT DAKKU_DECLARE_OBJECT ( TriangleFilter , Filter ) function evaluate virtual float evaluate ( const Point2f & p ) const override Given a 2D point which is relative to the center of the filter, the filter's value at that point is returned. Parameters : p the given 2D point Return : float filter's value Reimplements : dakku::Filter::evaluate function Filter explicit Filter ( const Vector2f & radius ) Construct a new Filter object The filter's overall extent in each direction is twice the value given in radius Parameters : radius radius of the filter Updated on 2022-04-11 at 15:27:23 +0000","title":"dakku::TriangleFilter"},{"location":"Classes/classdakku_1_1TriangleFilter/#dakkutrianglefilter","text":"triangle filter the weight falls off linearly from the filter center over the square extent of the filter #include <triangle.h> Inherits from dakku::Filter , dakku::Object","title":"dakku::TriangleFilter"},{"location":"Classes/classdakku_1_1TriangleFilter/#public-functions","text":"Name DAKKU_DECLARE_OBJECT ( TriangleFilter , Filter ) virtual float evaluate (const Point2f & p) const override Given a 2D point which is relative to the center of the filter, the filter's value at that point is returned. Filter (const Vector2f & radius) Construct a new Filter object The filter's overall extent in each direction is twice the value given in radius","title":"Public Functions"},{"location":"Classes/classdakku_1_1TriangleFilter/#additional-inherited-members","text":"Public Attributes inherited from dakku::Filter Name const Vector2f radius filter radius const Vector2f invRadius filter radius inversion Public Functions inherited from dakku::Object Name virtual ~Object () =default Object (const Property & ={}) virtual std::string getClassName () const virtual std::string getParentName () const virtual std::string toString () const bool isDerivedFrom (std::string_view name) const whther the object is derived from name (inclusive) bool isBaseOf (std::string_view name) const whether the object is base of name (inclusive) std::string getClassNameStatic () std::string getParentNameStatic ()","title":"Additional inherited members"},{"location":"Classes/classdakku_1_1TriangleFilter/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Classes/classdakku_1_1TriangleFilter/#function-dakku_declare_object","text":"DAKKU_DECLARE_OBJECT ( TriangleFilter , Filter )","title":"function DAKKU_DECLARE_OBJECT"},{"location":"Classes/classdakku_1_1TriangleFilter/#function-evaluate","text":"virtual float evaluate ( const Point2f & p ) const override Given a 2D point which is relative to the center of the filter, the filter's value at that point is returned. Parameters : p the given 2D point Return : float filter's value Reimplements : dakku::Filter::evaluate","title":"function evaluate"},{"location":"Classes/classdakku_1_1TriangleFilter/#function-filter","text":"explicit Filter ( const Vector2f & radius ) Construct a new Filter object The filter's overall extent in each direction is twice the value given in radius Parameters : radius radius of the filter Updated on 2022-04-11 at 15:27:23 +0000","title":"function Filter"},{"location":"Classes/classdakku_1_1UvMapping2D/","text":"dakku::UvMapping2D #include <texture.h> Inherits from dakku::TextureMapping2D , dakku::Object Public Functions Name DAKKU_DECLARE_OBJECT ( UvMapping2D , TextureMapping2D ) UvMapping2D (float su =1, float sv =1, float du =0, float dv =0) virtual Point2f map (const SurfaceInteraction & si, Vector2f & dstdx, Vector2f & dstdy) const override Additional inherited members Public Functions inherited from dakku::Object Name virtual ~Object () =default Object (const Property & ={}) virtual std::string getClassName () const virtual std::string getParentName () const virtual std::string toString () const bool isDerivedFrom (std::string_view name) const whther the object is derived from name (inclusive) bool isBaseOf (std::string_view name) const whether the object is base of name (inclusive) std::string getClassNameStatic () std::string getParentNameStatic () Public Functions Documentation function DAKKU_DECLARE_OBJECT DAKKU_DECLARE_OBJECT ( UvMapping2D , TextureMapping2D ) function UvMapping2D explicit UvMapping2D ( float su = 1 , float sv = 1 , float du = 0 , float dv = 0 ) function map virtual Point2f map ( const SurfaceInteraction & si , Vector2f & dstdx , Vector2f & dstdy ) const override Reimplements : dakku::TextureMapping2D::map Updated on 2022-04-11 at 15:27:23 +0000","title":"dakku::UvMapping2D"},{"location":"Classes/classdakku_1_1UvMapping2D/#dakkuuvmapping2d","text":"#include <texture.h> Inherits from dakku::TextureMapping2D , dakku::Object","title":"dakku::UvMapping2D"},{"location":"Classes/classdakku_1_1UvMapping2D/#public-functions","text":"Name DAKKU_DECLARE_OBJECT ( UvMapping2D , TextureMapping2D ) UvMapping2D (float su =1, float sv =1, float du =0, float dv =0) virtual Point2f map (const SurfaceInteraction & si, Vector2f & dstdx, Vector2f & dstdy) const override","title":"Public Functions"},{"location":"Classes/classdakku_1_1UvMapping2D/#additional-inherited-members","text":"Public Functions inherited from dakku::Object Name virtual ~Object () =default Object (const Property & ={}) virtual std::string getClassName () const virtual std::string getParentName () const virtual std::string toString () const bool isDerivedFrom (std::string_view name) const whther the object is derived from name (inclusive) bool isBaseOf (std::string_view name) const whether the object is base of name (inclusive) std::string getClassNameStatic () std::string getParentNameStatic ()","title":"Additional inherited members"},{"location":"Classes/classdakku_1_1UvMapping2D/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Classes/classdakku_1_1UvMapping2D/#function-dakku_declare_object","text":"DAKKU_DECLARE_OBJECT ( UvMapping2D , TextureMapping2D )","title":"function DAKKU_DECLARE_OBJECT"},{"location":"Classes/classdakku_1_1UvMapping2D/#function-uvmapping2d","text":"explicit UvMapping2D ( float su = 1 , float sv = 1 , float du = 0 , float dv = 0 )","title":"function UvMapping2D"},{"location":"Classes/classdakku_1_1UvMapping2D/#function-map","text":"virtual Point2f map ( const SurfaceInteraction & si , Vector2f & dstdx , Vector2f & dstdy ) const override Reimplements : dakku::TextureMapping2D::map Updated on 2022-04-11 at 15:27:23 +0000","title":"function map"},{"location":"Classes/classdakku_1_1Vector/","text":"dakku::Vector vector More... #include <vector.h> Inherits from dakku::VectorBase< T, S, Vector< T, S > > Friends Name Vector operator- (const Vector & a, const Vector & b) subtraction between vectors Additional inherited members Public Functions inherited from dakku::VectorBase< T, S, Vector< T, S > > Name VectorBase () Construct a new Vector Base object with all components initialized to zero. template <ArithmeticType Arg> VectorBase (Arg value) Construct a new Vector Base object with all components initialized to value template <ArithmeticType Other,typename OtherDerived > VectorBase (const VectorBase < Other, S, OtherDerived > & other) Construct a new Vector Base object with a vector expression. VectorBase (const VectorBase & other) VectorBase ( VectorBase && other) VectorBase & operator= (const VectorBase & other) VectorBase & operator= ( VectorBase && other) template <ArithmeticType Arg> void set (Arg value) Construct a new Vector Base object with given values. template <ArithmeticType Arg> void setByIndex (size_t index, Arg value) set data[index] to value template <ArithmeticType... Args,size_t... Is> void set (std::index_sequence< Is... > , Args &&... args) set data to args template <ArithmeticType... Args> void set (Args &&... args) set data to args template <ArithmeticType Other,typename OtherDerived > void set (const VectorBase < Other, S, OtherDerived > & rhs) set data by rhs 's data bool hasNaNs () const check whether there are nan components const T & get (size_t i) const get i'th component std::string toString () const convert vector to string size_t size () const size of the vector const T & operator[] (size_t i) const get i'th value T & operator[] (size_t i) get i'th value const Derived & derived () const get derived class Derived & derived () get derived class Derived & operator+= (const Derived & rhs) addition template <ArithmeticType V> Derived & operator+= (const V & rhs) addition Derived & operator-= (const Derived & rhs) subtraction template <ArithmeticType V> Derived & operator-= (const V & rhs) subtraction Derived & operator*= (const Derived & rhs) multiplication template <ArithmeticType V> Derived & operator*= (const V & rhs) multiplication Derived & operator/= (const Derived & rhs) division template <ArithmeticType V> Derived & operator/= (const V & rhs) division std::vector< float > toFloatVector () const convert this to float vector (Property::VECTOR) VectorBase (const std::vector< float > & v) Construct a new Vector Base object with std::vector (Property::VECTOR) decltype(auto) x () const get the first element decltype(auto) x () get the first element decltype(auto) y () const get the second element decltype(auto) y () get the second element decltype(auto) z () const get the third element decltype(auto) z () get the fourth element decltype(auto) w () const get the fourth element decltype(auto) w () get the third element size_t maxElementIndex () const get the index of the max element decltype(auto) maxElement () const get the max element in the vector decltype(auto) begin () decltype(auto) begin () const decltype(auto) end () decltype(auto) end () const decltype(auto) normalized () const normalized vector Derived & normalize () normalize this template <typename OtherDerived > decltype(auto) dot (const VectorBase < T, S, OtherDerived > & rhs) const dot product between two vectors decltype(auto) squaredNorm () const squared norm decltype(auto) norm () const norm decltype(auto) length () const length Derived cross (const Derived & rhs) const cross product bool isZero () const check whether all components are zero operator std::span< T, S > () operator std::span< const T, S > () const Protected Attributes inherited from dakku::VectorBase< T, S, Vector< T, S > > Name std::array< T, S > _data vector base data Friends inherited from dakku::VectorBase< T, S, Vector< T, S > > Name std::ostream & operator<< (std::ostream & os, const VectorBase & vec) output the vector Derived operator+ (const Derived & a, const Derived & b) addition Derived operator+ (const Derived & a, const U & b) addition Derived operator+ (const U & a, const Derived & b) addition Derived operator* (const Derived & a, const Derived & b) multiplication Derived operator* (const Derived & a, const U & b) multiplication Derived operator* (const U & a, const Derived & b) multiplication Derived operator/ (const Derived & a, const Derived & b) division Derived operator/ (const Derived & a, const U & b) division Derived operator/ (const U & a, const Derived & b) division bool operator== (const Derived & a, const Derived & b) a == b (element wise) bool operator!= (const Derived & a, const Derived & b) a != b (element wise) Derived max (const Derived & v1, const Derived & v2) element wise max Derived min (const Derived & v1, const Derived & v2) element wise min Derived normalize (const Derived & v) normalized vector decltype(auto) distance (const Derived & a, const Derived & b) the distance decltype(auto) abs (const Derived & v) abs Derived sqrt (const Derived & v) element-wise sqrt Derived pow (const Derived & v, E e) element-wise power Derived exp (const Derived & v) element-wise exp Derived floor (const Derived & v) element-wise floor Derived ceil (const Derived & v) element-wise ceil Derived lerp (const Derived & a, const Derived & b, T t) element-wise linear interpolation Detailed Description template < ArithmeticType T , size_t S > class dakku :: Vector ; vector Template Parameters : T data type S size Friends friend operator- friend Vector operator - ( const Vector & a , const Vector & b ); subtraction between vectors Updated on 2022-04-11 at 15:27:23 +0000","title":"dakku::Vector"},{"location":"Classes/classdakku_1_1Vector/#dakkuvector","text":"vector More... #include <vector.h> Inherits from dakku::VectorBase< T, S, Vector< T, S > >","title":"dakku::Vector"},{"location":"Classes/classdakku_1_1Vector/#friends","text":"Name Vector operator- (const Vector & a, const Vector & b) subtraction between vectors","title":"Friends"},{"location":"Classes/classdakku_1_1Vector/#additional-inherited-members","text":"Public Functions inherited from dakku::VectorBase< T, S, Vector< T, S > > Name VectorBase () Construct a new Vector Base object with all components initialized to zero. template <ArithmeticType Arg> VectorBase (Arg value) Construct a new Vector Base object with all components initialized to value template <ArithmeticType Other,typename OtherDerived > VectorBase (const VectorBase < Other, S, OtherDerived > & other) Construct a new Vector Base object with a vector expression. VectorBase (const VectorBase & other) VectorBase ( VectorBase && other) VectorBase & operator= (const VectorBase & other) VectorBase & operator= ( VectorBase && other) template <ArithmeticType Arg> void set (Arg value) Construct a new Vector Base object with given values. template <ArithmeticType Arg> void setByIndex (size_t index, Arg value) set data[index] to value template <ArithmeticType... Args,size_t... Is> void set (std::index_sequence< Is... > , Args &&... args) set data to args template <ArithmeticType... Args> void set (Args &&... args) set data to args template <ArithmeticType Other,typename OtherDerived > void set (const VectorBase < Other, S, OtherDerived > & rhs) set data by rhs 's data bool hasNaNs () const check whether there are nan components const T & get (size_t i) const get i'th component std::string toString () const convert vector to string size_t size () const size of the vector const T & operator[] (size_t i) const get i'th value T & operator[] (size_t i) get i'th value const Derived & derived () const get derived class Derived & derived () get derived class Derived & operator+= (const Derived & rhs) addition template <ArithmeticType V> Derived & operator+= (const V & rhs) addition Derived & operator-= (const Derived & rhs) subtraction template <ArithmeticType V> Derived & operator-= (const V & rhs) subtraction Derived & operator*= (const Derived & rhs) multiplication template <ArithmeticType V> Derived & operator*= (const V & rhs) multiplication Derived & operator/= (const Derived & rhs) division template <ArithmeticType V> Derived & operator/= (const V & rhs) division std::vector< float > toFloatVector () const convert this to float vector (Property::VECTOR) VectorBase (const std::vector< float > & v) Construct a new Vector Base object with std::vector (Property::VECTOR) decltype(auto) x () const get the first element decltype(auto) x () get the first element decltype(auto) y () const get the second element decltype(auto) y () get the second element decltype(auto) z () const get the third element decltype(auto) z () get the fourth element decltype(auto) w () const get the fourth element decltype(auto) w () get the third element size_t maxElementIndex () const get the index of the max element decltype(auto) maxElement () const get the max element in the vector decltype(auto) begin () decltype(auto) begin () const decltype(auto) end () decltype(auto) end () const decltype(auto) normalized () const normalized vector Derived & normalize () normalize this template <typename OtherDerived > decltype(auto) dot (const VectorBase < T, S, OtherDerived > & rhs) const dot product between two vectors decltype(auto) squaredNorm () const squared norm decltype(auto) norm () const norm decltype(auto) length () const length Derived cross (const Derived & rhs) const cross product bool isZero () const check whether all components are zero operator std::span< T, S > () operator std::span< const T, S > () const Protected Attributes inherited from dakku::VectorBase< T, S, Vector< T, S > > Name std::array< T, S > _data vector base data Friends inherited from dakku::VectorBase< T, S, Vector< T, S > > Name std::ostream & operator<< (std::ostream & os, const VectorBase & vec) output the vector Derived operator+ (const Derived & a, const Derived & b) addition Derived operator+ (const Derived & a, const U & b) addition Derived operator+ (const U & a, const Derived & b) addition Derived operator* (const Derived & a, const Derived & b) multiplication Derived operator* (const Derived & a, const U & b) multiplication Derived operator* (const U & a, const Derived & b) multiplication Derived operator/ (const Derived & a, const Derived & b) division Derived operator/ (const Derived & a, const U & b) division Derived operator/ (const U & a, const Derived & b) division bool operator== (const Derived & a, const Derived & b) a == b (element wise) bool operator!= (const Derived & a, const Derived & b) a != b (element wise) Derived max (const Derived & v1, const Derived & v2) element wise max Derived min (const Derived & v1, const Derived & v2) element wise min Derived normalize (const Derived & v) normalized vector decltype(auto) distance (const Derived & a, const Derived & b) the distance decltype(auto) abs (const Derived & v) abs Derived sqrt (const Derived & v) element-wise sqrt Derived pow (const Derived & v, E e) element-wise power Derived exp (const Derived & v) element-wise exp Derived floor (const Derived & v) element-wise floor Derived ceil (const Derived & v) element-wise ceil Derived lerp (const Derived & a, const Derived & b, T t) element-wise linear interpolation","title":"Additional inherited members"},{"location":"Classes/classdakku_1_1Vector/#detailed-description","text":"template < ArithmeticType T , size_t S > class dakku :: Vector ; vector Template Parameters : T data type S size","title":"Detailed Description"},{"location":"Classes/classdakku_1_1Vector/#friends_1","text":"","title":"Friends"},{"location":"Classes/classdakku_1_1Vector/#friend-operator-","text":"friend Vector operator - ( const Vector & a , const Vector & b ); subtraction between vectors Updated on 2022-04-11 at 15:27:23 +0000","title":"friend operator-"},{"location":"Classes/classdakku_1_1VectorBase/","text":"dakku::VectorBase vector base class More... #include <vector_base.h> Inherited by dakku::CoefficientSpectrum< 3, RgbSpectrum > Public Functions Name VectorBase () Construct a new Vector Base object with all components initialized to zero. template <ArithmeticType Arg> VectorBase (Arg value) Construct a new Vector Base object with all components initialized to value template <ArithmeticType Other,typename OtherDerived > VectorBase (const VectorBase < Other, S, OtherDerived > & other) Construct a new Vector Base object with a vector expression. VectorBase (const VectorBase & other) VectorBase ( VectorBase && other) VectorBase & operator= (const VectorBase & other) VectorBase & operator= ( VectorBase && other) template <ArithmeticType Arg> void set (Arg value) Construct a new Vector Base object with given values. template <ArithmeticType Arg> void setByIndex (size_t index, Arg value) set data[index] to value template <ArithmeticType... Args,size_t... Is> void set (std::index_sequence< Is... > , Args &&... args) set data to args template <ArithmeticType... Args> void set (Args &&... args) set data to args template <ArithmeticType Other,typename OtherDerived > void set (const VectorBase < Other, S, OtherDerived > & rhs) set data by rhs 's data bool hasNaNs () const check whether there are nan components const T & get (size_t i) const get i'th component std::string toString () const convert vector to string size_t size () const size of the vector const T & operator[] (size_t i) const get i'th value T & operator[] (size_t i) get i'th value Derived operator- () const negation of the vector const Derived & derived () const get derived class Derived & derived () get derived class Derived & operator+= (const Derived & rhs) addition template <ArithmeticType V> Derived & operator+= (const V & rhs) addition Derived & operator-= (const Derived & rhs) subtraction template <ArithmeticType V> Derived & operator-= (const V & rhs) subtraction Derived & operator*= (const Derived & rhs) multiplication template <ArithmeticType V> Derived & operator*= (const V & rhs) multiplication Derived & operator/= (const Derived & rhs) division template <ArithmeticType V> Derived & operator/= (const V & rhs) division std::vector< float > toFloatVector () const convert this to float vector (Property::VECTOR) VectorBase (const std::vector< float > & v) Construct a new Vector Base object with std::vector (Property::VECTOR) decltype(auto) x () const get the first element decltype(auto) x () get the first element decltype(auto) y () const get the second element decltype(auto) y () get the second element decltype(auto) z () const get the third element decltype(auto) z () get the fourth element decltype(auto) w () const get the fourth element decltype(auto) w () get the third element size_t maxElementIndex () const get the index of the max element decltype(auto) maxElement () const get the max element in the vector decltype(auto) begin () decltype(auto) begin () const decltype(auto) end () decltype(auto) end () const decltype(auto) normalized () const normalized vector Derived & normalize () normalize this template <typename OtherDerived > decltype(auto) dot (const VectorBase < T, S, OtherDerived > & rhs) const dot product between two vectors decltype(auto) squaredNorm () const squared norm decltype(auto) norm () const norm decltype(auto) length () const length Derived cross (const Derived & rhs) const cross product bool isZero () const check whether all components are zero operator std::span< T, S > () operator std::span< const T, S > () const Protected Attributes Name std::array< T, S > _data vector base data Friends Name std::ostream & operator<< (std::ostream & os, const VectorBase & vec) output the vector Derived operator+ (const Derived & a, const Derived & b) addition Derived operator+ (const Derived & a, const U & b) addition Derived operator+ (const U & a, const Derived & b) addition Derived operator- (const Derived & a, const U & b) subtraction Derived operator- (const U & a, const Derived & b) subtraction Derived operator* (const Derived & a, const Derived & b) multiplication Derived operator* (const Derived & a, const U & b) multiplication Derived operator* (const U & a, const Derived & b) multiplication Derived operator/ (const Derived & a, const Derived & b) division Derived operator/ (const Derived & a, const U & b) division Derived operator/ (const U & a, const Derived & b) division bool operator== (const Derived & a, const Derived & b) a == b (element wise) bool operator!= (const Derived & a, const Derived & b) a != b (element wise) Derived max (const Derived & v1, const Derived & v2) element wise max Derived min (const Derived & v1, const Derived & v2) element wise min Derived normalize (const Derived & v) normalized vector decltype(auto) distance (const Derived & a, const Derived & b) the distance decltype(auto) abs (const Derived & v) abs Derived sqrt (const Derived & v) element-wise sqrt Derived pow (const Derived & v, E e) element-wise power Derived exp (const Derived & v) element-wise exp Derived floor (const Derived & v) element-wise floor Derived ceil (const Derived & v) element-wise ceil Derived lerp (const Derived & a, const Derived & b, T t) element-wise linear interpolation Detailed Description template < ArithmeticType T , size_t S , typename Derived > class dakku :: VectorBase ; vector base class Template Parameters : T type size dimension of the vector Derived derived class type Public Functions Documentation function VectorBase inline explicit VectorBase () Construct a new Vector Base object with all components initialized to zero. function VectorBase template < ArithmeticType Arg > inline VectorBase ( Arg value ) Construct a new Vector Base object with all components initialized to value Parameters : value init value Template Parameters : Arg value type function VectorBase template < ArithmeticType Other , typename OtherDerived > inline explicit VectorBase ( const VectorBase < Other , S , OtherDerived > & other ) Construct a new Vector Base object with a vector expression. Parameters : expr the given expression Template Parameters : Other OtherDerived Expr function VectorBase inline VectorBase ( const VectorBase & other ) function VectorBase inline VectorBase ( VectorBase && other ) function operator= inline VectorBase & operator = ( const VectorBase & other ) function operator= inline VectorBase & operator = ( VectorBase && other ) function set template < ArithmeticType Arg > inline void set ( Arg value ) Construct a new Vector Base object with given values. Parameters : args init values value the given value Template Parameters : Args value types Arg value type set all components to value function setByIndex template < ArithmeticType Arg > inline void setByIndex ( size_t index , Arg value ) set data[index] to value Parameters : index the index of the component value the given value Template Parameters : Arg value type function set template < ArithmeticType ... Args , size_t ... Is > inline void set ( std :: index_sequence < Is ... > , Args && ... args ) set data to args Parameters : args values Template Parameters : Args value types Is indices (generated by std::index_sequence_for) function set template < ArithmeticType ... Args > inline void set ( Args && ... args ) set data to args Parameters : args values Template Parameters : Args value types function set template < ArithmeticType Other , typename OtherDerived > inline void set ( const VectorBase < Other , S , OtherDerived > & rhs ) set data by rhs 's data Parameters : rhs the given vector Template Parameters : Other rhs type OtherDerived rhs derived type function hasNaNs inline bool hasNaNs () const check whether there are nan components Return : true vector contains nan false vector does not contain nans function get inline const T & get ( size_t i ) const get i'th component Parameters : i the index Return : the value function toString inline std :: string toString () const convert vector to string Return : the converted string function size inline size_t size () const size of the vector Return : size function operator[] inline const T & operator []( size_t i ) const get i'th value Parameters : i index Return : value function operator[] inline T & operator []( size_t i ) get i'th value Parameters : i index Return : value function operator- inline Derived operator - () const negation of the vector Return : \\(-\\vec v\\) function derived inline const Derived & derived () const get derived class function derived inline Derived & derived () get derived class function operator+= inline Derived & operator += ( const Derived & rhs ) addition Parameters : rhs another vector Return : this function operator+= template < ArithmeticType V > inline Derived & operator += ( const V & rhs ) addition Parameters : rhs scalar Return : this function operator-= inline Derived & operator -= ( const Derived & rhs ) subtraction Parameters : rhs another vector Return : this function operator-= template < ArithmeticType V > inline Derived & operator -= ( const V & rhs ) subtraction Parameters : rhs scalar Return : this function operator*= inline Derived & operator *= ( const Derived & rhs ) multiplication Parameters : rhs another vector Return : this function operator*= template < ArithmeticType V > inline Derived & operator *= ( const V & rhs ) multiplication Parameters : rhs scalar Return : this function operator/= inline Derived & operator /= ( const Derived & rhs ) division Parameters : rhs another vector Return : this function operator/= template < ArithmeticType V > inline Derived & operator /= ( const V & rhs ) division Parameters : rhs scalar Return : this function toFloatVector inline std :: vector < float > toFloatVector () const convert this to float vector (Property::VECTOR) Return : the float vector function VectorBase inline VectorBase ( const std :: vector < float > & v ) Construct a new Vector Base object with std::vector (Property::VECTOR) Parameters : v the float vector function x inline decltype ( auto ) x () const get the first element function x inline decltype ( auto ) x () get the first element function y inline decltype ( auto ) y () const get the second element function y inline decltype ( auto ) y () get the second element function z inline decltype ( auto ) z () const get the third element function z inline decltype ( auto ) z () get the fourth element function w inline decltype ( auto ) w () const get the fourth element function w inline decltype ( auto ) w () get the third element function maxElementIndex inline size_t maxElementIndex () const get the index of the max element Return : the index function maxElement inline decltype ( auto ) maxElement () const get the max element in the vector Return : the max value function begin inline decltype ( auto ) begin () function begin inline decltype ( auto ) begin () const function end inline decltype ( auto ) end () function end inline decltype ( auto ) end () const function normalized inline decltype ( auto ) normalized () const normalized vector function normalize inline Derived & normalize () normalize this function dot template < typename OtherDerived > inline decltype ( auto ) dot ( const VectorBase < T , S , OtherDerived > & rhs ) const dot product between two vectors Return : \\(\\vec a \\cdot \\vec b\\) function squaredNorm inline decltype ( auto ) squaredNorm () const squared norm Return : \\(||v|| ^ 2\\) function norm inline decltype ( auto ) norm () const norm Return : \\(||v||\\) function length inline decltype ( auto ) length () const length Return : \\(||v||\\) function cross inline Derived cross ( const Derived & rhs ) const cross product function isZero inline bool isZero () const check whether all components are zero function operator std::span< T, S > inline operator std :: span < T , S > () function operator std::span< const T, S > inline operator std :: span < const T , S > () const Protected Attributes Documentation variable _data std :: array < T , S > _data ; vector base data Friends friend operator<< friend std :: ostream & operator << ( std :: ostream & os , const VectorBase & vec ); output the vector Parameters : os ostream vec the vector to output Return : ostream friend operator+ friend Derived operator + ( const Derived & a , const Derived & b ); addition Parameters : a vector \\(\\vec a\\) b vector \\(\\vec b\\) Return : \\(\\vec a + \\vec b\\) friend operator+ friend Derived operator + ( const Derived & a , const U & b ); addition Parameters : a \\(\\vec a\\) b \\(bb\\) Return : elementwise add b friend operator+ friend Derived operator + ( const U & a , const Derived & b ); addition Parameters : a \\(aa\\) b \\(\\vec b\\) Return : elementwise add a friend operator- friend Derived operator - ( const Derived & a , const U & b ); subtraction Parameters : a \\(\\vec a\\) b \\(bb\\) Return : elementwise sub friend operator- friend Derived operator - ( const U & a , const Derived & b ); subtraction Parameters : a \\(aa\\) b \\(\\vec b\\) Return : elementwise sub friend operator* friend Derived operator * ( const Derived & a , const Derived & b ); multiplication Parameters : a vector \\(\\vec a\\) b vector \\(\\vec b\\) Return : elementwise mul friend operator* friend Derived operator * ( const Derived & a , const U & b ); multiplication Parameters : a \\(\\vec a\\) b \\(bb\\) Return : \\(b\\vec a\\) friend operator* friend Derived operator * ( const U & a , const Derived & b ); multiplication Parameters : a \\(aa\\) b \\(\\vec b\\) Return : elementwise mul friend operator/ friend Derived operator / ( const Derived & a , const Derived & b ); division Parameters : a vector \\(\\vec a\\) b vector \\(\\vec b\\) Return : elementwise div friend operator/ friend Derived operator / ( const Derived & a , const U & b ); division Parameters : a \\(\\vec a\\) b \\(bb\\) Return : \\(\\vec a / b\\) friend operator/ friend Derived operator / ( const U & a , const Derived & b ); division Parameters : a \\(aa\\) b \\(\\vec b\\) Return : elementwise div (broad cast \\(a\\) ) friend operator== friend bool operator == ( const Derived & a , const Derived & b ); a == b (element wise) friend operator!= friend bool operator != ( const Derived & a , const Derived & b ); a != b (element wise) friend max friend Derived max ( const Derived & v1 , const Derived & v2 ); element wise max friend min friend Derived min ( const Derived & v1 , const Derived & v2 ); element wise min friend normalize friend Derived normalize ( const Derived & v ); normalized vector friend distance friend decltype ( auto ) distance ( const Derived & a , const Derived & b ); the distance friend abs friend decltype ( auto ) abs ( const Derived & v ); abs friend sqrt friend Derived sqrt ( const Derived & v ); element-wise sqrt friend pow friend Derived pow ( const Derived & v , E e ); element-wise power friend exp friend Derived exp ( const Derived & v ); element-wise exp friend floor friend Derived floor ( const Derived & v ); element-wise floor friend ceil friend Derived ceil ( const Derived & v ); element-wise ceil friend lerp friend Derived lerp ( const Derived & a , const Derived & b , T t ); element-wise linear interpolation Updated on 2022-04-11 at 15:27:23 +0000","title":"dakku::VectorBase"},{"location":"Classes/classdakku_1_1VectorBase/#dakkuvectorbase","text":"vector base class More... #include <vector_base.h> Inherited by dakku::CoefficientSpectrum< 3, RgbSpectrum >","title":"dakku::VectorBase"},{"location":"Classes/classdakku_1_1VectorBase/#public-functions","text":"Name VectorBase () Construct a new Vector Base object with all components initialized to zero. template <ArithmeticType Arg> VectorBase (Arg value) Construct a new Vector Base object with all components initialized to value template <ArithmeticType Other,typename OtherDerived > VectorBase (const VectorBase < Other, S, OtherDerived > & other) Construct a new Vector Base object with a vector expression. VectorBase (const VectorBase & other) VectorBase ( VectorBase && other) VectorBase & operator= (const VectorBase & other) VectorBase & operator= ( VectorBase && other) template <ArithmeticType Arg> void set (Arg value) Construct a new Vector Base object with given values. template <ArithmeticType Arg> void setByIndex (size_t index, Arg value) set data[index] to value template <ArithmeticType... Args,size_t... Is> void set (std::index_sequence< Is... > , Args &&... args) set data to args template <ArithmeticType... Args> void set (Args &&... args) set data to args template <ArithmeticType Other,typename OtherDerived > void set (const VectorBase < Other, S, OtherDerived > & rhs) set data by rhs 's data bool hasNaNs () const check whether there are nan components const T & get (size_t i) const get i'th component std::string toString () const convert vector to string size_t size () const size of the vector const T & operator[] (size_t i) const get i'th value T & operator[] (size_t i) get i'th value Derived operator- () const negation of the vector const Derived & derived () const get derived class Derived & derived () get derived class Derived & operator+= (const Derived & rhs) addition template <ArithmeticType V> Derived & operator+= (const V & rhs) addition Derived & operator-= (const Derived & rhs) subtraction template <ArithmeticType V> Derived & operator-= (const V & rhs) subtraction Derived & operator*= (const Derived & rhs) multiplication template <ArithmeticType V> Derived & operator*= (const V & rhs) multiplication Derived & operator/= (const Derived & rhs) division template <ArithmeticType V> Derived & operator/= (const V & rhs) division std::vector< float > toFloatVector () const convert this to float vector (Property::VECTOR) VectorBase (const std::vector< float > & v) Construct a new Vector Base object with std::vector (Property::VECTOR) decltype(auto) x () const get the first element decltype(auto) x () get the first element decltype(auto) y () const get the second element decltype(auto) y () get the second element decltype(auto) z () const get the third element decltype(auto) z () get the fourth element decltype(auto) w () const get the fourth element decltype(auto) w () get the third element size_t maxElementIndex () const get the index of the max element decltype(auto) maxElement () const get the max element in the vector decltype(auto) begin () decltype(auto) begin () const decltype(auto) end () decltype(auto) end () const decltype(auto) normalized () const normalized vector Derived & normalize () normalize this template <typename OtherDerived > decltype(auto) dot (const VectorBase < T, S, OtherDerived > & rhs) const dot product between two vectors decltype(auto) squaredNorm () const squared norm decltype(auto) norm () const norm decltype(auto) length () const length Derived cross (const Derived & rhs) const cross product bool isZero () const check whether all components are zero operator std::span< T, S > () operator std::span< const T, S > () const","title":"Public Functions"},{"location":"Classes/classdakku_1_1VectorBase/#protected-attributes","text":"Name std::array< T, S > _data vector base data","title":"Protected Attributes"},{"location":"Classes/classdakku_1_1VectorBase/#friends","text":"Name std::ostream & operator<< (std::ostream & os, const VectorBase & vec) output the vector Derived operator+ (const Derived & a, const Derived & b) addition Derived operator+ (const Derived & a, const U & b) addition Derived operator+ (const U & a, const Derived & b) addition Derived operator- (const Derived & a, const U & b) subtraction Derived operator- (const U & a, const Derived & b) subtraction Derived operator* (const Derived & a, const Derived & b) multiplication Derived operator* (const Derived & a, const U & b) multiplication Derived operator* (const U & a, const Derived & b) multiplication Derived operator/ (const Derived & a, const Derived & b) division Derived operator/ (const Derived & a, const U & b) division Derived operator/ (const U & a, const Derived & b) division bool operator== (const Derived & a, const Derived & b) a == b (element wise) bool operator!= (const Derived & a, const Derived & b) a != b (element wise) Derived max (const Derived & v1, const Derived & v2) element wise max Derived min (const Derived & v1, const Derived & v2) element wise min Derived normalize (const Derived & v) normalized vector decltype(auto) distance (const Derived & a, const Derived & b) the distance decltype(auto) abs (const Derived & v) abs Derived sqrt (const Derived & v) element-wise sqrt Derived pow (const Derived & v, E e) element-wise power Derived exp (const Derived & v) element-wise exp Derived floor (const Derived & v) element-wise floor Derived ceil (const Derived & v) element-wise ceil Derived lerp (const Derived & a, const Derived & b, T t) element-wise linear interpolation","title":"Friends"},{"location":"Classes/classdakku_1_1VectorBase/#detailed-description","text":"template < ArithmeticType T , size_t S , typename Derived > class dakku :: VectorBase ; vector base class Template Parameters : T type size dimension of the vector Derived derived class type","title":"Detailed Description"},{"location":"Classes/classdakku_1_1VectorBase/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Classes/classdakku_1_1VectorBase/#function-vectorbase","text":"inline explicit VectorBase () Construct a new Vector Base object with all components initialized to zero.","title":"function VectorBase"},{"location":"Classes/classdakku_1_1VectorBase/#function-vectorbase_1","text":"template < ArithmeticType Arg > inline VectorBase ( Arg value ) Construct a new Vector Base object with all components initialized to value Parameters : value init value Template Parameters : Arg value type","title":"function VectorBase"},{"location":"Classes/classdakku_1_1VectorBase/#function-vectorbase_2","text":"template < ArithmeticType Other , typename OtherDerived > inline explicit VectorBase ( const VectorBase < Other , S , OtherDerived > & other ) Construct a new Vector Base object with a vector expression. Parameters : expr the given expression Template Parameters : Other OtherDerived Expr","title":"function VectorBase"},{"location":"Classes/classdakku_1_1VectorBase/#function-vectorbase_3","text":"inline VectorBase ( const VectorBase & other )","title":"function VectorBase"},{"location":"Classes/classdakku_1_1VectorBase/#function-vectorbase_4","text":"inline VectorBase ( VectorBase && other )","title":"function VectorBase"},{"location":"Classes/classdakku_1_1VectorBase/#function-operator","text":"inline VectorBase & operator = ( const VectorBase & other )","title":"function operator="},{"location":"Classes/classdakku_1_1VectorBase/#function-operator_1","text":"inline VectorBase & operator = ( VectorBase && other )","title":"function operator="},{"location":"Classes/classdakku_1_1VectorBase/#function-set","text":"template < ArithmeticType Arg > inline void set ( Arg value ) Construct a new Vector Base object with given values. Parameters : args init values value the given value Template Parameters : Args value types Arg value type set all components to value","title":"function set"},{"location":"Classes/classdakku_1_1VectorBase/#function-setbyindex","text":"template < ArithmeticType Arg > inline void setByIndex ( size_t index , Arg value ) set data[index] to value Parameters : index the index of the component value the given value Template Parameters : Arg value type","title":"function setByIndex"},{"location":"Classes/classdakku_1_1VectorBase/#function-set_1","text":"template < ArithmeticType ... Args , size_t ... Is > inline void set ( std :: index_sequence < Is ... > , Args && ... args ) set data to args Parameters : args values Template Parameters : Args value types Is indices (generated by std::index_sequence_for)","title":"function set"},{"location":"Classes/classdakku_1_1VectorBase/#function-set_2","text":"template < ArithmeticType ... Args > inline void set ( Args && ... args ) set data to args Parameters : args values Template Parameters : Args value types","title":"function set"},{"location":"Classes/classdakku_1_1VectorBase/#function-set_3","text":"template < ArithmeticType Other , typename OtherDerived > inline void set ( const VectorBase < Other , S , OtherDerived > & rhs ) set data by rhs 's data Parameters : rhs the given vector Template Parameters : Other rhs type OtherDerived rhs derived type","title":"function set"},{"location":"Classes/classdakku_1_1VectorBase/#function-hasnans","text":"inline bool hasNaNs () const check whether there are nan components Return : true vector contains nan false vector does not contain nans","title":"function hasNaNs"},{"location":"Classes/classdakku_1_1VectorBase/#function-get","text":"inline const T & get ( size_t i ) const get i'th component Parameters : i the index Return : the value","title":"function get"},{"location":"Classes/classdakku_1_1VectorBase/#function-tostring","text":"inline std :: string toString () const convert vector to string Return : the converted string","title":"function toString"},{"location":"Classes/classdakku_1_1VectorBase/#function-size","text":"inline size_t size () const size of the vector Return : size","title":"function size"},{"location":"Classes/classdakku_1_1VectorBase/#function-operator_2","text":"inline const T & operator []( size_t i ) const get i'th value Parameters : i index Return : value","title":"function operator[]"},{"location":"Classes/classdakku_1_1VectorBase/#function-operator_3","text":"inline T & operator []( size_t i ) get i'th value Parameters : i index Return : value","title":"function operator[]"},{"location":"Classes/classdakku_1_1VectorBase/#function-operator-","text":"inline Derived operator - () const negation of the vector Return : \\(-\\vec v\\)","title":"function operator-"},{"location":"Classes/classdakku_1_1VectorBase/#function-derived","text":"inline const Derived & derived () const get derived class","title":"function derived"},{"location":"Classes/classdakku_1_1VectorBase/#function-derived_1","text":"inline Derived & derived () get derived class","title":"function derived"},{"location":"Classes/classdakku_1_1VectorBase/#function-operator_4","text":"inline Derived & operator += ( const Derived & rhs ) addition Parameters : rhs another vector Return : this","title":"function operator+="},{"location":"Classes/classdakku_1_1VectorBase/#function-operator_5","text":"template < ArithmeticType V > inline Derived & operator += ( const V & rhs ) addition Parameters : rhs scalar Return : this","title":"function operator+="},{"location":"Classes/classdakku_1_1VectorBase/#function-operator-_1","text":"inline Derived & operator -= ( const Derived & rhs ) subtraction Parameters : rhs another vector Return : this","title":"function operator-="},{"location":"Classes/classdakku_1_1VectorBase/#function-operator-_2","text":"template < ArithmeticType V > inline Derived & operator -= ( const V & rhs ) subtraction Parameters : rhs scalar Return : this","title":"function operator-="},{"location":"Classes/classdakku_1_1VectorBase/#function-operator_6","text":"inline Derived & operator *= ( const Derived & rhs ) multiplication Parameters : rhs another vector Return : this","title":"function operator*="},{"location":"Classes/classdakku_1_1VectorBase/#function-operator_7","text":"template < ArithmeticType V > inline Derived & operator *= ( const V & rhs ) multiplication Parameters : rhs scalar Return : this","title":"function operator*="},{"location":"Classes/classdakku_1_1VectorBase/#function-operator_8","text":"inline Derived & operator /= ( const Derived & rhs ) division Parameters : rhs another vector Return : this","title":"function operator/="},{"location":"Classes/classdakku_1_1VectorBase/#function-operator_9","text":"template < ArithmeticType V > inline Derived & operator /= ( const V & rhs ) division Parameters : rhs scalar Return : this","title":"function operator/="},{"location":"Classes/classdakku_1_1VectorBase/#function-tofloatvector","text":"inline std :: vector < float > toFloatVector () const convert this to float vector (Property::VECTOR) Return : the float vector","title":"function toFloatVector"},{"location":"Classes/classdakku_1_1VectorBase/#function-vectorbase_5","text":"inline VectorBase ( const std :: vector < float > & v ) Construct a new Vector Base object with std::vector (Property::VECTOR) Parameters : v the float vector","title":"function VectorBase"},{"location":"Classes/classdakku_1_1VectorBase/#function-x","text":"inline decltype ( auto ) x () const get the first element","title":"function x"},{"location":"Classes/classdakku_1_1VectorBase/#function-x_1","text":"inline decltype ( auto ) x () get the first element","title":"function x"},{"location":"Classes/classdakku_1_1VectorBase/#function-y","text":"inline decltype ( auto ) y () const get the second element","title":"function y"},{"location":"Classes/classdakku_1_1VectorBase/#function-y_1","text":"inline decltype ( auto ) y () get the second element","title":"function y"},{"location":"Classes/classdakku_1_1VectorBase/#function-z","text":"inline decltype ( auto ) z () const get the third element","title":"function z"},{"location":"Classes/classdakku_1_1VectorBase/#function-z_1","text":"inline decltype ( auto ) z () get the fourth element","title":"function z"},{"location":"Classes/classdakku_1_1VectorBase/#function-w","text":"inline decltype ( auto ) w () const get the fourth element","title":"function w"},{"location":"Classes/classdakku_1_1VectorBase/#function-w_1","text":"inline decltype ( auto ) w () get the third element","title":"function w"},{"location":"Classes/classdakku_1_1VectorBase/#function-maxelementindex","text":"inline size_t maxElementIndex () const get the index of the max element Return : the index","title":"function maxElementIndex"},{"location":"Classes/classdakku_1_1VectorBase/#function-maxelement","text":"inline decltype ( auto ) maxElement () const get the max element in the vector Return : the max value","title":"function maxElement"},{"location":"Classes/classdakku_1_1VectorBase/#function-begin","text":"inline decltype ( auto ) begin ()","title":"function begin"},{"location":"Classes/classdakku_1_1VectorBase/#function-begin_1","text":"inline decltype ( auto ) begin () const","title":"function begin"},{"location":"Classes/classdakku_1_1VectorBase/#function-end","text":"inline decltype ( auto ) end ()","title":"function end"},{"location":"Classes/classdakku_1_1VectorBase/#function-end_1","text":"inline decltype ( auto ) end () const","title":"function end"},{"location":"Classes/classdakku_1_1VectorBase/#function-normalized","text":"inline decltype ( auto ) normalized () const normalized vector","title":"function normalized"},{"location":"Classes/classdakku_1_1VectorBase/#function-normalize","text":"inline Derived & normalize () normalize this","title":"function normalize"},{"location":"Classes/classdakku_1_1VectorBase/#function-dot","text":"template < typename OtherDerived > inline decltype ( auto ) dot ( const VectorBase < T , S , OtherDerived > & rhs ) const dot product between two vectors Return : \\(\\vec a \\cdot \\vec b\\)","title":"function dot"},{"location":"Classes/classdakku_1_1VectorBase/#function-squarednorm","text":"inline decltype ( auto ) squaredNorm () const squared norm Return : \\(||v|| ^ 2\\)","title":"function squaredNorm"},{"location":"Classes/classdakku_1_1VectorBase/#function-norm","text":"inline decltype ( auto ) norm () const norm Return : \\(||v||\\)","title":"function norm"},{"location":"Classes/classdakku_1_1VectorBase/#function-length","text":"inline decltype ( auto ) length () const length Return : \\(||v||\\)","title":"function length"},{"location":"Classes/classdakku_1_1VectorBase/#function-cross","text":"inline Derived cross ( const Derived & rhs ) const cross product","title":"function cross"},{"location":"Classes/classdakku_1_1VectorBase/#function-iszero","text":"inline bool isZero () const check whether all components are zero","title":"function isZero"},{"location":"Classes/classdakku_1_1VectorBase/#function-operator-stdspan-t-s","text":"inline operator std :: span < T , S > ()","title":"function operator std::span&lt; T, S &gt;"},{"location":"Classes/classdakku_1_1VectorBase/#function-operator-stdspan-const-t-s","text":"inline operator std :: span < const T , S > () const","title":"function operator std::span&lt; const T, S &gt;"},{"location":"Classes/classdakku_1_1VectorBase/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"Classes/classdakku_1_1VectorBase/#variable-_data","text":"std :: array < T , S > _data ; vector base data","title":"variable _data"},{"location":"Classes/classdakku_1_1VectorBase/#friends_1","text":"","title":"Friends"},{"location":"Classes/classdakku_1_1VectorBase/#friend-operator","text":"friend std :: ostream & operator << ( std :: ostream & os , const VectorBase & vec ); output the vector Parameters : os ostream vec the vector to output Return : ostream","title":"friend operator&lt;&lt;"},{"location":"Classes/classdakku_1_1VectorBase/#friend-operator_1","text":"friend Derived operator + ( const Derived & a , const Derived & b ); addition Parameters : a vector \\(\\vec a\\) b vector \\(\\vec b\\) Return : \\(\\vec a + \\vec b\\)","title":"friend operator+"},{"location":"Classes/classdakku_1_1VectorBase/#friend-operator_2","text":"friend Derived operator + ( const Derived & a , const U & b ); addition Parameters : a \\(\\vec a\\) b \\(bb\\) Return : elementwise add b","title":"friend operator+"},{"location":"Classes/classdakku_1_1VectorBase/#friend-operator_3","text":"friend Derived operator + ( const U & a , const Derived & b ); addition Parameters : a \\(aa\\) b \\(\\vec b\\) Return : elementwise add a","title":"friend operator+"},{"location":"Classes/classdakku_1_1VectorBase/#friend-operator-","text":"friend Derived operator - ( const Derived & a , const U & b ); subtraction Parameters : a \\(\\vec a\\) b \\(bb\\) Return : elementwise sub","title":"friend operator-"},{"location":"Classes/classdakku_1_1VectorBase/#friend-operator-_1","text":"friend Derived operator - ( const U & a , const Derived & b ); subtraction Parameters : a \\(aa\\) b \\(\\vec b\\) Return : elementwise sub","title":"friend operator-"},{"location":"Classes/classdakku_1_1VectorBase/#friend-operator_4","text":"friend Derived operator * ( const Derived & a , const Derived & b ); multiplication Parameters : a vector \\(\\vec a\\) b vector \\(\\vec b\\) Return : elementwise mul","title":"friend operator*"},{"location":"Classes/classdakku_1_1VectorBase/#friend-operator_5","text":"friend Derived operator * ( const Derived & a , const U & b ); multiplication Parameters : a \\(\\vec a\\) b \\(bb\\) Return : \\(b\\vec a\\)","title":"friend operator*"},{"location":"Classes/classdakku_1_1VectorBase/#friend-operator_6","text":"friend Derived operator * ( const U & a , const Derived & b ); multiplication Parameters : a \\(aa\\) b \\(\\vec b\\) Return : elementwise mul","title":"friend operator*"},{"location":"Classes/classdakku_1_1VectorBase/#friend-operator_7","text":"friend Derived operator / ( const Derived & a , const Derived & b ); division Parameters : a vector \\(\\vec a\\) b vector \\(\\vec b\\) Return : elementwise div","title":"friend operator/"},{"location":"Classes/classdakku_1_1VectorBase/#friend-operator_8","text":"friend Derived operator / ( const Derived & a , const U & b ); division Parameters : a \\(\\vec a\\) b \\(bb\\) Return : \\(\\vec a / b\\)","title":"friend operator/"},{"location":"Classes/classdakku_1_1VectorBase/#friend-operator_9","text":"friend Derived operator / ( const U & a , const Derived & b ); division Parameters : a \\(aa\\) b \\(\\vec b\\) Return : elementwise div (broad cast \\(a\\) )","title":"friend operator/"},{"location":"Classes/classdakku_1_1VectorBase/#friend-operator_10","text":"friend bool operator == ( const Derived & a , const Derived & b ); a == b (element wise)","title":"friend operator=="},{"location":"Classes/classdakku_1_1VectorBase/#friend-operator_11","text":"friend bool operator != ( const Derived & a , const Derived & b ); a != b (element wise)","title":"friend operator!="},{"location":"Classes/classdakku_1_1VectorBase/#friend-max","text":"friend Derived max ( const Derived & v1 , const Derived & v2 ); element wise max","title":"friend max"},{"location":"Classes/classdakku_1_1VectorBase/#friend-min","text":"friend Derived min ( const Derived & v1 , const Derived & v2 ); element wise min","title":"friend min"},{"location":"Classes/classdakku_1_1VectorBase/#friend-normalize","text":"friend Derived normalize ( const Derived & v ); normalized vector","title":"friend normalize"},{"location":"Classes/classdakku_1_1VectorBase/#friend-distance","text":"friend decltype ( auto ) distance ( const Derived & a , const Derived & b ); the distance","title":"friend distance"},{"location":"Classes/classdakku_1_1VectorBase/#friend-abs","text":"friend decltype ( auto ) abs ( const Derived & v ); abs","title":"friend abs"},{"location":"Classes/classdakku_1_1VectorBase/#friend-sqrt","text":"friend Derived sqrt ( const Derived & v ); element-wise sqrt","title":"friend sqrt"},{"location":"Classes/classdakku_1_1VectorBase/#friend-pow","text":"friend Derived pow ( const Derived & v , E e ); element-wise power","title":"friend pow"},{"location":"Classes/classdakku_1_1VectorBase/#friend-exp","text":"friend Derived exp ( const Derived & v ); element-wise exp","title":"friend exp"},{"location":"Classes/classdakku_1_1VectorBase/#friend-floor","text":"friend Derived floor ( const Derived & v ); element-wise floor","title":"friend floor"},{"location":"Classes/classdakku_1_1VectorBase/#friend-ceil","text":"friend Derived ceil ( const Derived & v ); element-wise ceil","title":"friend ceil"},{"location":"Classes/classdakku_1_1VectorBase/#friend-lerp","text":"friend Derived lerp ( const Derived & a , const Derived & b , T t ); element-wise linear interpolation Updated on 2022-04-11 at 15:27:23 +0000","title":"friend lerp"},{"location":"Classes/structdakku_1_1Class_1_1Metadata/","text":"dakku::Class::Metadata Public Attributes Name std::add_pointer_t< Object *(const Property &)> constructor std::string parent Public Attributes Documentation variable constructor std :: add_pointer_t < Object * ( const Property & ) > constructor ; variable parent std :: string parent ; Updated on 2022-04-11 at 15:27:23 +0000","title":"dakku::Class::Metadata"},{"location":"Classes/structdakku_1_1Class_1_1Metadata/#dakkuclassmetadata","text":"","title":"dakku::Class::Metadata"},{"location":"Classes/structdakku_1_1Class_1_1Metadata/#public-attributes","text":"Name std::add_pointer_t< Object *(const Property &)> constructor std::string parent","title":"Public Attributes"},{"location":"Classes/structdakku_1_1Class_1_1Metadata/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"Classes/structdakku_1_1Class_1_1Metadata/#variable-constructor","text":"std :: add_pointer_t < Object * ( const Property & ) > constructor ;","title":"variable constructor"},{"location":"Classes/structdakku_1_1Class_1_1Metadata/#variable-parent","text":"std :: string parent ; Updated on 2022-04-11 at 15:27:23 +0000","title":"variable parent"},{"location":"Classes/structdakku_1_1FilmTilePixel/","text":"dakku::FilmTilePixel film tile pixel #include <film.h> Public Attributes Name Spectrum contribSum radiance contribution sum float filterWeightSum sum of filter weights Public Attributes Documentation variable contribSum Spectrum contribSum ; radiance contribution sum variable filterWeightSum float filterWeightSum ; sum of filter weights Updated on 2022-04-11 at 15:27:23 +0000","title":"dakku::FilmTilePixel"},{"location":"Classes/structdakku_1_1FilmTilePixel/#dakkufilmtilepixel","text":"film tile pixel #include <film.h>","title":"dakku::FilmTilePixel"},{"location":"Classes/structdakku_1_1FilmTilePixel/#public-attributes","text":"Name Spectrum contribSum radiance contribution sum float filterWeightSum sum of filter weights","title":"Public Attributes"},{"location":"Classes/structdakku_1_1FilmTilePixel/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"Classes/structdakku_1_1FilmTilePixel/#variable-contribsum","text":"Spectrum contribSum ; radiance contribution sum","title":"variable contribSum"},{"location":"Classes/structdakku_1_1FilmTilePixel/#variable-filterweightsum","text":"float filterWeightSum ; sum of filter weights Updated on 2022-04-11 at 15:27:23 +0000","title":"variable filterWeightSum"},{"location":"Classes/structdakku_1_1Film_1_1Pixel/","text":"dakku::Film::Pixel pixel struct Public Attributes Name float xyz color data (in xyz) float filterWeightSum sum of the filter weight std::atomic< float > splatXyz splat values to pixels, needed by bidirectional methods float _padding Public Attributes Documentation variable xyz float xyz ; color data (in xyz) variable filterWeightSum float filterWeightSum ; sum of the filter weight variable splatXyz std :: atomic < float > splatXyz ; splat values to pixels, needed by bidirectional methods variable _padding float _padding ; Updated on 2022-04-11 at 15:27:23 +0000","title":"dakku::Film::Pixel"},{"location":"Classes/structdakku_1_1Film_1_1Pixel/#dakkufilmpixel","text":"pixel struct","title":"dakku::Film::Pixel"},{"location":"Classes/structdakku_1_1Film_1_1Pixel/#public-attributes","text":"Name float xyz color data (in xyz) float filterWeightSum sum of the filter weight std::atomic< float > splatXyz splat values to pixels, needed by bidirectional methods float _padding","title":"Public Attributes"},{"location":"Classes/structdakku_1_1Film_1_1Pixel/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"Classes/structdakku_1_1Film_1_1Pixel/#variable-xyz","text":"float xyz ; color data (in xyz)","title":"variable xyz"},{"location":"Classes/structdakku_1_1Film_1_1Pixel/#variable-filterweightsum","text":"float filterWeightSum ; sum of the filter weight","title":"variable filterWeightSum"},{"location":"Classes/structdakku_1_1Film_1_1Pixel/#variable-splatxyz","text":"std :: atomic < float > splatXyz ; splat values to pixels, needed by bidirectional methods","title":"variable splatXyz"},{"location":"Classes/structdakku_1_1Film_1_1Pixel/#variable-_padding","text":"float _padding ; Updated on 2022-04-11 at 15:27:23 +0000","title":"variable _padding"},{"location":"Classes/structdakku_1_1Interaction/","text":"dakku::Interaction interaction #include <interaction.h> Inherited by dakku::SurfaceInteraction Public Functions Name Interaction () =default Interaction ( Point3f p, const Vector3f & wo, Normal3f n) bool isSurfaceInteraction () const check whether the interaction is surface interaction surface interaction contains non-zero normal \\(\\vec n\\) bool isMediumInteraction () const check whether the interaction is medium interaction Ray spawnRay (const Vector3f & d) const spawn a ray to the given direction Ray spawnRayTo (const Point3f & q) const spawn ray \\(p \\rightarrow q\\) Ray spawnRayTo (const Interaction & it) const spawn ray \\(p \\rightarrow it.p\\) Public Attributes Name Point3f p interaction point Vector3f wo outgoing direction Normal3f n normal Public Functions Documentation function Interaction Interaction () = default function Interaction inline Interaction ( Point3f p , const Vector3f & wo , Normal3f n ) function isSurfaceInteraction inline bool isSurfaceInteraction () const check whether the interaction is surface interaction surface interaction contains non-zero normal \\(\\vec n\\) function isMediumInteraction inline bool isMediumInteraction () const check whether the interaction is medium interaction function spawnRay inline Ray spawnRay ( const Vector3f & d ) const spawn a ray to the given direction Parameters : d the direction Return : the ray toward d after origin offset function spawnRayTo inline Ray spawnRayTo ( const Point3f & q ) const spawn ray \\(p \\rightarrow q\\) Parameters : q the target point function spawnRayTo inline Ray spawnRayTo ( const Interaction & it ) const spawn ray \\(p \\rightarrow it.p\\) Parameters : it the given target interaction Public Attributes Documentation variable p Point3f p ; interaction point variable wo Vector3f wo ; outgoing direction variable n Normal3f n ; normal Updated on 2022-04-11 at 15:27:23 +0000","title":"dakku::Interaction"},{"location":"Classes/structdakku_1_1Interaction/#dakkuinteraction","text":"interaction #include <interaction.h> Inherited by dakku::SurfaceInteraction","title":"dakku::Interaction"},{"location":"Classes/structdakku_1_1Interaction/#public-functions","text":"Name Interaction () =default Interaction ( Point3f p, const Vector3f & wo, Normal3f n) bool isSurfaceInteraction () const check whether the interaction is surface interaction surface interaction contains non-zero normal \\(\\vec n\\) bool isMediumInteraction () const check whether the interaction is medium interaction Ray spawnRay (const Vector3f & d) const spawn a ray to the given direction Ray spawnRayTo (const Point3f & q) const spawn ray \\(p \\rightarrow q\\) Ray spawnRayTo (const Interaction & it) const spawn ray \\(p \\rightarrow it.p\\)","title":"Public Functions"},{"location":"Classes/structdakku_1_1Interaction/#public-attributes","text":"Name Point3f p interaction point Vector3f wo outgoing direction Normal3f n normal","title":"Public Attributes"},{"location":"Classes/structdakku_1_1Interaction/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Classes/structdakku_1_1Interaction/#function-interaction","text":"Interaction () = default","title":"function Interaction"},{"location":"Classes/structdakku_1_1Interaction/#function-interaction_1","text":"inline Interaction ( Point3f p , const Vector3f & wo , Normal3f n )","title":"function Interaction"},{"location":"Classes/structdakku_1_1Interaction/#function-issurfaceinteraction","text":"inline bool isSurfaceInteraction () const check whether the interaction is surface interaction surface interaction contains non-zero normal \\(\\vec n\\)","title":"function isSurfaceInteraction"},{"location":"Classes/structdakku_1_1Interaction/#function-ismediuminteraction","text":"inline bool isMediumInteraction () const check whether the interaction is medium interaction","title":"function isMediumInteraction"},{"location":"Classes/structdakku_1_1Interaction/#function-spawnray","text":"inline Ray spawnRay ( const Vector3f & d ) const spawn a ray to the given direction Parameters : d the direction Return : the ray toward d after origin offset","title":"function spawnRay"},{"location":"Classes/structdakku_1_1Interaction/#function-spawnrayto","text":"inline Ray spawnRayTo ( const Point3f & q ) const spawn ray \\(p \\rightarrow q\\) Parameters : q the target point","title":"function spawnRayTo"},{"location":"Classes/structdakku_1_1Interaction/#function-spawnrayto_1","text":"inline Ray spawnRayTo ( const Interaction & it ) const spawn ray \\(p \\rightarrow it.p\\) Parameters : it the given target interaction","title":"function spawnRayTo"},{"location":"Classes/structdakku_1_1Interaction/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"Classes/structdakku_1_1Interaction/#variable-p","text":"Point3f p ; interaction point","title":"variable p"},{"location":"Classes/structdakku_1_1Interaction/#variable-wo","text":"Vector3f wo ; outgoing direction","title":"variable wo"},{"location":"Classes/structdakku_1_1Interaction/#variable-n","text":"Normal3f n ; normal Updated on 2022-04-11 at 15:27:23 +0000","title":"variable n"},{"location":"Classes/structdakku_1_1Matrix4x4/","text":"dakku::Matrix4x4 4x4 matrix #include <transform.h> Public Functions Name Matrix4x4 () Construct a new Matrix 4 x 4 object (default identity matrix) Matrix4x4 (float t00, float t01, float t02, float t03, float t10, float t11, float t12, float t13, float t20, float t21, float t22, float t23, float t30, float t31, float t32, float t33) Construct a new Matrix 4 x 4 object. Matrix4x4 (const std::vector< float > & v) Construct a new Matrix 4 x 4 object with row major float vector. decltype(auto) operator[] (size_t i) const decltype(auto) operator[] (size_t i) decltype(auto) operator() (size_t i, size_t j) decltype(auto) operator() (size_t i, size_t j) const void setIdentity () set identity bool operator== (const Matrix4x4 & rhs) const bool operator!= (const Matrix4x4 & rhs) const Matrix4x4 operator* (const Matrix4x4 & rhs) const Matrix4x4 operator*= (const Matrix4x4 & rhs) bool isIdentity () const check whether this is an identity matrix std::string toString () const std::vector< float > toFloatVector () const row major float vector Matrix4x4 mul (const Matrix4x4 & a, const Matrix4x4 & b) Public Attributes Name std::array< std::array< float, 4 >, 4 > m matrix data Friends Name Matrix4x4 DAKKU_EXPORT_CORE transpose (const Matrix4x4 & m) transpose of the matrix Matrix4x4 DAKKU_EXPORT_CORE inverse (const Matrix4x4 & m) get the inverse matrix std::ostream & operator<< (std::ostream & os, const Matrix4x4 & m) Public Functions Documentation function Matrix4x4 inline Matrix4x4 () Construct a new Matrix 4 x 4 object (default identity matrix) function Matrix4x4 inline Matrix4x4 ( float t00 , float t01 , float t02 , float t03 , float t10 , float t11 , float t12 , float t13 , float t20 , float t21 , float t22 , float t23 , float t30 , float t31 , float t32 , float t33 ) Construct a new Matrix 4 x 4 object. function Matrix4x4 inline Matrix4x4 ( const std :: vector < float > & v ) Construct a new Matrix 4 x 4 object with row major float vector. function operator[] inline decltype ( auto ) operator []( size_t i ) const function operator[] inline decltype ( auto ) operator []( size_t i ) function operator() inline decltype ( auto ) operator ()( size_t i , size_t j ) function operator() inline decltype ( auto ) operator ()( size_t i , size_t j ) const function setIdentity inline void setIdentity () set identity function operator== inline bool operator == ( const Matrix4x4 & rhs ) const function operator!= inline bool operator != ( const Matrix4x4 & rhs ) const function operator* inline Matrix4x4 operator * ( const Matrix4x4 & rhs ) const function operator*= inline Matrix4x4 operator *= ( const Matrix4x4 & rhs ) function isIdentity inline bool isIdentity () const check whether this is an identity matrix function toString inline std :: string toString () const function toFloatVector inline std :: vector < float > toFloatVector () const row major float vector function mul static Matrix4x4 mul ( const Matrix4x4 & a , const Matrix4x4 & b ) Public Attributes Documentation variable m std :: array < std :: array < float , 4 > , 4 > m ; matrix data Friends friend transpose friend Matrix4x4DAKKU_EXPORT_CORE transpose ( const Matrix4x4 & m ); transpose of the matrix friend inverse friend Matrix4x4DAKKU_EXPORT_CORE inverse ( const Matrix4x4 & m ); get the inverse matrix friend operator<< friend std :: ostream & operator << ( std :: ostream & os , const Matrix4x4 & m ); Updated on 2022-04-11 at 15:27:23 +0000","title":"dakku::Matrix4x4"},{"location":"Classes/structdakku_1_1Matrix4x4/#dakkumatrix4x4","text":"4x4 matrix #include <transform.h>","title":"dakku::Matrix4x4"},{"location":"Classes/structdakku_1_1Matrix4x4/#public-functions","text":"Name Matrix4x4 () Construct a new Matrix 4 x 4 object (default identity matrix) Matrix4x4 (float t00, float t01, float t02, float t03, float t10, float t11, float t12, float t13, float t20, float t21, float t22, float t23, float t30, float t31, float t32, float t33) Construct a new Matrix 4 x 4 object. Matrix4x4 (const std::vector< float > & v) Construct a new Matrix 4 x 4 object with row major float vector. decltype(auto) operator[] (size_t i) const decltype(auto) operator[] (size_t i) decltype(auto) operator() (size_t i, size_t j) decltype(auto) operator() (size_t i, size_t j) const void setIdentity () set identity bool operator== (const Matrix4x4 & rhs) const bool operator!= (const Matrix4x4 & rhs) const Matrix4x4 operator* (const Matrix4x4 & rhs) const Matrix4x4 operator*= (const Matrix4x4 & rhs) bool isIdentity () const check whether this is an identity matrix std::string toString () const std::vector< float > toFloatVector () const row major float vector Matrix4x4 mul (const Matrix4x4 & a, const Matrix4x4 & b)","title":"Public Functions"},{"location":"Classes/structdakku_1_1Matrix4x4/#public-attributes","text":"Name std::array< std::array< float, 4 >, 4 > m matrix data","title":"Public Attributes"},{"location":"Classes/structdakku_1_1Matrix4x4/#friends","text":"Name Matrix4x4 DAKKU_EXPORT_CORE transpose (const Matrix4x4 & m) transpose of the matrix Matrix4x4 DAKKU_EXPORT_CORE inverse (const Matrix4x4 & m) get the inverse matrix std::ostream & operator<< (std::ostream & os, const Matrix4x4 & m)","title":"Friends"},{"location":"Classes/structdakku_1_1Matrix4x4/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Classes/structdakku_1_1Matrix4x4/#function-matrix4x4","text":"inline Matrix4x4 () Construct a new Matrix 4 x 4 object (default identity matrix)","title":"function Matrix4x4"},{"location":"Classes/structdakku_1_1Matrix4x4/#function-matrix4x4_1","text":"inline Matrix4x4 ( float t00 , float t01 , float t02 , float t03 , float t10 , float t11 , float t12 , float t13 , float t20 , float t21 , float t22 , float t23 , float t30 , float t31 , float t32 , float t33 ) Construct a new Matrix 4 x 4 object.","title":"function Matrix4x4"},{"location":"Classes/structdakku_1_1Matrix4x4/#function-matrix4x4_2","text":"inline Matrix4x4 ( const std :: vector < float > & v ) Construct a new Matrix 4 x 4 object with row major float vector.","title":"function Matrix4x4"},{"location":"Classes/structdakku_1_1Matrix4x4/#function-operator","text":"inline decltype ( auto ) operator []( size_t i ) const","title":"function operator[]"},{"location":"Classes/structdakku_1_1Matrix4x4/#function-operator_1","text":"inline decltype ( auto ) operator []( size_t i )","title":"function operator[]"},{"location":"Classes/structdakku_1_1Matrix4x4/#function-operator_2","text":"inline decltype ( auto ) operator ()( size_t i , size_t j )","title":"function operator()"},{"location":"Classes/structdakku_1_1Matrix4x4/#function-operator_3","text":"inline decltype ( auto ) operator ()( size_t i , size_t j ) const","title":"function operator()"},{"location":"Classes/structdakku_1_1Matrix4x4/#function-setidentity","text":"inline void setIdentity () set identity","title":"function setIdentity"},{"location":"Classes/structdakku_1_1Matrix4x4/#function-operator_4","text":"inline bool operator == ( const Matrix4x4 & rhs ) const","title":"function operator=="},{"location":"Classes/structdakku_1_1Matrix4x4/#function-operator_5","text":"inline bool operator != ( const Matrix4x4 & rhs ) const","title":"function operator!="},{"location":"Classes/structdakku_1_1Matrix4x4/#function-operator_6","text":"inline Matrix4x4 operator * ( const Matrix4x4 & rhs ) const","title":"function operator*"},{"location":"Classes/structdakku_1_1Matrix4x4/#function-operator_7","text":"inline Matrix4x4 operator *= ( const Matrix4x4 & rhs )","title":"function operator*="},{"location":"Classes/structdakku_1_1Matrix4x4/#function-isidentity","text":"inline bool isIdentity () const check whether this is an identity matrix","title":"function isIdentity"},{"location":"Classes/structdakku_1_1Matrix4x4/#function-tostring","text":"inline std :: string toString () const","title":"function toString"},{"location":"Classes/structdakku_1_1Matrix4x4/#function-tofloatvector","text":"inline std :: vector < float > toFloatVector () const row major float vector","title":"function toFloatVector"},{"location":"Classes/structdakku_1_1Matrix4x4/#function-mul","text":"static Matrix4x4 mul ( const Matrix4x4 & a , const Matrix4x4 & b )","title":"function mul"},{"location":"Classes/structdakku_1_1Matrix4x4/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"Classes/structdakku_1_1Matrix4x4/#variable-m","text":"std :: array < std :: array < float , 4 > , 4 > m ; matrix data","title":"variable m"},{"location":"Classes/structdakku_1_1Matrix4x4/#friends_1","text":"","title":"Friends"},{"location":"Classes/structdakku_1_1Matrix4x4/#friend-transpose","text":"friend Matrix4x4DAKKU_EXPORT_CORE transpose ( const Matrix4x4 & m ); transpose of the matrix","title":"friend transpose"},{"location":"Classes/structdakku_1_1Matrix4x4/#friend-inverse","text":"friend Matrix4x4DAKKU_EXPORT_CORE inverse ( const Matrix4x4 & m ); get the inverse matrix","title":"friend inverse"},{"location":"Classes/structdakku_1_1Matrix4x4/#friend-operator","text":"friend std :: ostream & operator << ( std :: ostream & os , const Matrix4x4 & m ); Updated on 2022-04-11 at 15:27:23 +0000","title":"friend operator&lt;&lt;"},{"location":"Classes/structdakku_1_1ResampleWeight/","text":"dakku::ResampleWeight resample weight of the four nearby (continuous) texels #include <mipmap.h> Public Attributes Name int firstTexel first texel index float weight resample weight of the four texels Public Attributes Documentation variable firstTexel int firstTexel ; first texel index variable weight float weight ; resample weight of the four texels Updated on 2022-04-11 at 15:27:23 +0000","title":"dakku::ResampleWeight"},{"location":"Classes/structdakku_1_1ResampleWeight/#dakkuresampleweight","text":"resample weight of the four nearby (continuous) texels #include <mipmap.h>","title":"dakku::ResampleWeight"},{"location":"Classes/structdakku_1_1ResampleWeight/#public-attributes","text":"Name int firstTexel first texel index float weight resample weight of the four texels","title":"Public Attributes"},{"location":"Classes/structdakku_1_1ResampleWeight/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"Classes/structdakku_1_1ResampleWeight/#variable-firsttexel","text":"int firstTexel ; first texel index","title":"variable firstTexel"},{"location":"Classes/structdakku_1_1ResampleWeight/#variable-weight","text":"float weight ; resample weight of the four texels Updated on 2022-04-11 at 15:27:23 +0000","title":"variable weight"},{"location":"Examples/","text":"Examples Updated on 2022-04-11 at 15:27:24 +0000","title":"Examples"},{"location":"Examples/#examples","text":"Updated on 2022-04-11 at 15:27:24 +0000","title":"Examples"},{"location":"Files/","text":"Files dir src file src/platform.h dir src/core file src/core/api.h this must be include only once in source file src/core/blocked_array.h file src/core/bounds.h file src/core/class.h file src/core/film.h file src/core/filter.h file src/core/fwd.h file src/core/interaction.h file src/core/logger.h file src/core/memory.h file src/core/mipmap.h file src/core/object.h file src/core/property.h file src/core/ray.h file src/core/relative.h file src/core/serialization.h file src/core/shape.h file src/core/spectrum.h file src/core/stream.h file src/core/texture.h file src/core/transform.h file src/core/vector.h file src/core/vector_base.h dir src/filters file src/filters/api.h file src/filters/box.h file src/filters/fwd.h file src/filters/triangle.h dir src/gui file src/gui/engine.h file src/gui/film.h dir src/imageio file src/imageio/fwd.h file src/imageio/imageio.h dir src/stream file src/stream/api.h this must be include only once in source file src/stream/fstream.h file src/stream/fwd.h dir src/textures file src/textures/api.h this must be include only once in source file src/textures/constant.h file src/textures/fwd.h file src/textures/image.h Updated on 2022-04-11 at 15:27:24 +0000","title":"Files"},{"location":"Files/#files","text":"dir src file src/platform.h dir src/core file src/core/api.h this must be include only once in source file src/core/blocked_array.h file src/core/bounds.h file src/core/class.h file src/core/film.h file src/core/filter.h file src/core/fwd.h file src/core/interaction.h file src/core/logger.h file src/core/memory.h file src/core/mipmap.h file src/core/object.h file src/core/property.h file src/core/ray.h file src/core/relative.h file src/core/serialization.h file src/core/shape.h file src/core/spectrum.h file src/core/stream.h file src/core/texture.h file src/core/transform.h file src/core/vector.h file src/core/vector_base.h dir src/filters file src/filters/api.h file src/filters/box.h file src/filters/fwd.h file src/filters/triangle.h dir src/gui file src/gui/engine.h file src/gui/film.h dir src/imageio file src/imageio/fwd.h file src/imageio/imageio.h dir src/stream file src/stream/api.h this must be include only once in source file src/stream/fstream.h file src/stream/fwd.h dir src/textures file src/textures/api.h this must be include only once in source file src/textures/constant.h file src/textures/fwd.h file src/textures/image.h Updated on 2022-04-11 at 15:27:24 +0000","title":"Files"},{"location":"Files/blocked__array_8h/","text":"src/core/blocked_array.h Namespaces Name dakku dakku namespace Classes Name class dakku::BlockedArray blocked array \\(s \\times s\\) elements are layout together (linear), where \\(s\\) is the block size, then block by block linear layout block size \\(s\\) is power of \\(2\\) This improves the performance for looking up nearby elements (for texture) Source code #ifndef DAKKU_CORE_BLOCKED_ARRAY_H_ #define DAKKU_CORE_BLOCKED_ARRAY_H_ #include <core/fwd.h> #include <span> #include <oneapi/tbb/cache_aligned_allocator.h> namespace dakku { template < typename T , int logBlockSize = 2 > class BlockedArray { public : explicit BlockedArray ( int uRes , int vRes , std :: span < const T > d = {}) : uRes ( uRes ), vRes ( vRes ), uBlocks ( roundUp ( uRes ) >> logBlockSize ) { int nAlloc = roundUp ( uRes ) * roundUp ( vRes ); data = oneapi :: tbb :: cache_aligned_allocator < T > (). allocate ( nAlloc ); if ( ! d . empty ()) { for ( int v = 0 ; v < vRes ; ++ v ) for ( int u = 0 ; u < uRes ; ++ u ) ( * this )( u , v ) = d [ v * uRes + u ]; } } ~ BlockedArray () { int nAlloc = roundUp ( uRes ) * roundUp ( vRes ); oneapi :: tbb :: cache_aligned_allocator < T > (). deallocate ( data , nAlloc ); } [[ nodiscard ]] int blockIdx ( int i ) const { return i >> logBlockSize ; } [[ nodiscard ]] int offset ( int i ) const { return i & ( blockSize () - 1 ); } [[ nodiscard ]] constexpr int blockSize () const { return 1 << logBlockSize ; } [[ nodiscard ]] int roundUp ( int x ) const { return ( x + blockSize () - 1 ) & ~ ( blockSize () - 1 ); } [[ nodiscard ]] int uSize () const { return uRes ; } [[ nodiscard ]] int vSize () const { return vRes ; } const T & operator ()( int u , int v ) const { int bu = blockIdx ( u ), bv = blockIdx ( v ); int ou = offset ( u ), ov = offset ( v ); int off = blockSize () * blockSize () * ( uBlocks * bv + bu ) + blockSize () * ov + ou ; return data [ off ]; } T & operator ()( int u , int v ) { return const_cast < T &> ( static_cast < const BlockedArray &> ( * this )( u , v )); } void toLinearArray ( std :: span < T > a ) { int idx = 0 ; for ( int v = 0 ; v < vRes ; ++ v ) for ( int u = 0 ; u < uRes ; ++ u ) a [ idx ++ ] = ( * this )( u , v ); } private : T * data ; const int uRes ; const int vRes ; const int uBlocks ; }; } // namespace dakku #endif Updated on 2022-04-11 at 15:27:23 +0000","title":"src/core/blocked_array.h"},{"location":"Files/blocked__array_8h/#srccoreblocked_arrayh","text":"","title":"src/core/blocked_array.h"},{"location":"Files/blocked__array_8h/#namespaces","text":"Name dakku dakku namespace","title":"Namespaces"},{"location":"Files/blocked__array_8h/#classes","text":"Name class dakku::BlockedArray blocked array \\(s \\times s\\) elements are layout together (linear), where \\(s\\) is the block size, then block by block linear layout block size \\(s\\) is power of \\(2\\) This improves the performance for looking up nearby elements (for texture)","title":"Classes"},{"location":"Files/blocked__array_8h/#source-code","text":"#ifndef DAKKU_CORE_BLOCKED_ARRAY_H_ #define DAKKU_CORE_BLOCKED_ARRAY_H_ #include <core/fwd.h> #include <span> #include <oneapi/tbb/cache_aligned_allocator.h> namespace dakku { template < typename T , int logBlockSize = 2 > class BlockedArray { public : explicit BlockedArray ( int uRes , int vRes , std :: span < const T > d = {}) : uRes ( uRes ), vRes ( vRes ), uBlocks ( roundUp ( uRes ) >> logBlockSize ) { int nAlloc = roundUp ( uRes ) * roundUp ( vRes ); data = oneapi :: tbb :: cache_aligned_allocator < T > (). allocate ( nAlloc ); if ( ! d . empty ()) { for ( int v = 0 ; v < vRes ; ++ v ) for ( int u = 0 ; u < uRes ; ++ u ) ( * this )( u , v ) = d [ v * uRes + u ]; } } ~ BlockedArray () { int nAlloc = roundUp ( uRes ) * roundUp ( vRes ); oneapi :: tbb :: cache_aligned_allocator < T > (). deallocate ( data , nAlloc ); } [[ nodiscard ]] int blockIdx ( int i ) const { return i >> logBlockSize ; } [[ nodiscard ]] int offset ( int i ) const { return i & ( blockSize () - 1 ); } [[ nodiscard ]] constexpr int blockSize () const { return 1 << logBlockSize ; } [[ nodiscard ]] int roundUp ( int x ) const { return ( x + blockSize () - 1 ) & ~ ( blockSize () - 1 ); } [[ nodiscard ]] int uSize () const { return uRes ; } [[ nodiscard ]] int vSize () const { return vRes ; } const T & operator ()( int u , int v ) const { int bu = blockIdx ( u ), bv = blockIdx ( v ); int ou = offset ( u ), ov = offset ( v ); int off = blockSize () * blockSize () * ( uBlocks * bv + bu ) + blockSize () * ov + ou ; return data [ off ]; } T & operator ()( int u , int v ) { return const_cast < T &> ( static_cast < const BlockedArray &> ( * this )( u , v )); } void toLinearArray ( std :: span < T > a ) { int idx = 0 ; for ( int v = 0 ; v < vRes ; ++ v ) for ( int u = 0 ; u < uRes ; ++ u ) a [ idx ++ ] = ( * this )( u , v ); } private : T * data ; const int uRes ; const int vRes ; const int uBlocks ; }; } // namespace dakku #endif Updated on 2022-04-11 at 15:27:23 +0000","title":"Source code"},{"location":"Files/bounds_8h/","text":"src/core/bounds.h Namespaces Name dakku dakku namespace Classes Name class dakku::BoundsBase bounding box base class dakku::Bounds2 2d bounding box class dakku::Bounds3 3d bounding box class dakku::Bounds2iIterator 2d integer bounds iterator, iterate all pixels inside Source code #ifndef DAKKU_CORE_BOUNDS_H_ #define DAKKU_CORE_BOUNDS_H_ #include <core/vector.h> #include <iterator> #include <utility> namespace dakku { template < ArithmeticType T , size_t S > class BoundsBase { public : BoundsBase () = default ; explicit BoundsBase ( const Point < T , S > & p ) : pMin ( p ), pMax ( p ) {} template < ArithmeticType U > explicit BoundsBase ( const BoundsBase < U , S > & b ) : pMin ( Point < T , S > ( b . pMin )), pMax ( Point < T , S > ( b . pMax )) {} BoundsBase ( const Point < T , S > & p1 , const Point < T , S > & p2 ) : pMin ( min ( p1 , p2 )), pMax ( max ( p1 , p2 )) {} [[ nodiscard ]] Vector < T , S > diagonal () const { return pMax - pMin ; } [[ nodiscard ]] size_t maxExtent () const { return this -> diagonal (). maxElementIndex (); } bool operator == ( const BoundsBase & rhs ) const { return pMin == rhs . pMin && pMax == rhs . pMax ; } bool operator != ( const BoundsBase & rhs ) const { return pMin != rhs . pMin || pMax != rhs . pMax ; } [[ nodiscard ]] Point < T , S > lerp ( const Point < float , S > & t ) const { Point < T , S > ret ; for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = std :: lerp ( pMin [ i ], pMax [ i ], t [ i ]); return ret ; } [[ nodiscard ]] Vector < T , S > offset ( const Point < T , S > & p ) const { Vector < T , S > o = p - pMin ; for ( size_t i = 0 ; i < S ; ++ i ) if ( pMax [ i ] > pMin [ i ]) o [ i ] /= pMax [ i ] - pMin [ i ]; return o ; } friend bool overlaps ( const BoundsBase & a , const BoundsBase & b ) { for ( size_t i = 0 ; i < S ; ++ i ) if ( ! ( a . pMax [ i ] >= b . pMin [ i ] && a . pMin [ i ] <= b . pMax [ i ])) return false ; return true ; } friend bool inside ( const Point < T , S > & p , const BoundsBase & b ) { for ( size_t i = 0 ; i < S ; ++ i ) if ( ! ( p [ i ] >= b . pMin [ i ] && p [ i ] <= b . pMax [ i ])) return false ; return true ; } friend bool insideExclusive ( const Point < T , S > & p , const BoundsBase & b ) { for ( size_t i = 0 ; i < S ; ++ i ) if ( ! ( p [ i ] >= b . pMin [ i ] && p [ i ] < b . pMax [ i ])) return false ; return true ; } friend decltype ( auto ) distanceSquared ( const Point < T , S > & p , const BoundsBase & b ) { return max ( Vector < T , S > {}, max ( b . pMin - p , p - b . pMax )). squaredNorm (); } friend decltype ( auto ) distance ( const Point < T , S > & p , const BoundsBase & b ) { return std :: sqrt ( distanceSquared ( p , b )); } void boundingSphere ( Point < T , S > & center , float & rad ) { center = ( pMin + pMax ) / 2 ; rad = inside ( center , * this ) ? distance ( center , pMax ) : 0 ; } friend BoundsBase operator | ( const BoundsBase & a , const BoundsBase & b ) { BoundsBase ret ; ret . pMin = min ( a . pMin , b . pMin ); ret . pMax = max ( a . pMax , b . pMax ); return ret ; } friend BoundsBase operator | ( const BoundsBase & b , const Point < T , S > & p ) { BoundsBase ret ; ret . pMin = min ( b . pMin , p ); ret . pMax = max ( b . Pmax , p ); return ret ; } friend BoundsBase operator & ( const BoundsBase & a , const BoundsBase & b ) { BoundsBase ret ; // important: assign to pMin/pMax directly and don't run the BoundsBase() // constructor, since it takes min/max of the points passed to it. In // turn, that breaks returning an invalid bound for the case where we // intersect non-overlapping bounds (as we'd like to happen). ret . pMin = max ( a . pMin , b . pMin ); ret . pMax = min ( a . pMax , b . pMax ); return ret ; } [[ nodiscard ]] std :: string toString () const { return \"[\" + pMin . toString () + \", \" + pMax . toString () + \"]\" ; } friend std :: ostream & operator << ( std :: ostream & os , const BoundsBase & b ) { return os << b . toString (); } Point < T , S > pMin { std :: numeric_limits < T >:: max ()}; Point < T , S > pMax { std :: numeric_limits < T >:: lowest ()}; }; template < ArithmeticType T > class Bounds2 : public BoundsBase < T , 2 > { public : using BoundsBase < T , 2 >:: BoundsBase ; Bounds2 ( const BoundsBase < T , 2 > & base ) : BoundsBase < T , 2 > ( base ) {} [[ nodiscard ]] decltype ( auto ) area () const { auto d = this -> diagonal (); return d . x () * d . y (); } }; using Bounds2f = Bounds2 < float > ; using Bounds2i = Bounds2 < int > ; template < ArithmeticType T > class Bounds3 : public BoundsBase < T , 3 > { public : using BoundsBase < T , 3 >:: BoundsBase ; Bounds3 ( const BoundsBase < T , 3 > & base ) : BoundsBase < T , 3 > ( base ) {} }; using Bounds3f = Bounds3 < float > ; class Bounds2iIterator : public std :: forward_iterator_tag { public : explicit Bounds2iIterator ( const Bounds2i & b , Point2i p ) : b ( b ), p ( std :: move ( p )) {} Bounds2iIterator operator ++ () { advance (); return * this ; } Bounds2iIterator operator ++ ( int ) { Bounds2iIterator ret = * this ; advance (); return ret ; } bool operator == ( const Bounds2iIterator & rhs ) const { return p == rhs . p && ( & b == & rhs . b ); } bool operator != ( const Bounds2iIterator & rhs ) const { return p != rhs . p || ( & b != & rhs . b ); } Point2i operator * () const { return p ; } private : void advance () { ++ p . x (); if ( p . x () == b . pMax . x ()) { p . x () = b . pMin . x (); ++ p . y (); } } const Bounds2i & b ; Point2i p ; }; inline Bounds2iIterator begin ( const Bounds2i & b ) { return Bounds2iIterator { b , b . pMin }; } inline Bounds2iIterator end ( const Bounds2i & b ) { // normally, the ending point is at the minimum x value and one past // the last valid y value. Point2i pEnd ( b . pMin . x (), b . pMax . y ()); // however, if the bounds are degenerate, override the end point to // equal the start point so that any attempt to iterate over the bounds // exits out immediately. if ( b . pMin . x () >= b . pMax . x () || b . pMin . y () >= b . pMax . y ()) pEnd = b . pMin ; return Bounds2iIterator { b , pEnd }; } } // namespace dakku #endif Updated on 2022-04-11 at 15:27:23 +0000","title":"src/core/bounds.h"},{"location":"Files/bounds_8h/#srccoreboundsh","text":"","title":"src/core/bounds.h"},{"location":"Files/bounds_8h/#namespaces","text":"Name dakku dakku namespace","title":"Namespaces"},{"location":"Files/bounds_8h/#classes","text":"Name class dakku::BoundsBase bounding box base class dakku::Bounds2 2d bounding box class dakku::Bounds3 3d bounding box class dakku::Bounds2iIterator 2d integer bounds iterator, iterate all pixels inside","title":"Classes"},{"location":"Files/bounds_8h/#source-code","text":"#ifndef DAKKU_CORE_BOUNDS_H_ #define DAKKU_CORE_BOUNDS_H_ #include <core/vector.h> #include <iterator> #include <utility> namespace dakku { template < ArithmeticType T , size_t S > class BoundsBase { public : BoundsBase () = default ; explicit BoundsBase ( const Point < T , S > & p ) : pMin ( p ), pMax ( p ) {} template < ArithmeticType U > explicit BoundsBase ( const BoundsBase < U , S > & b ) : pMin ( Point < T , S > ( b . pMin )), pMax ( Point < T , S > ( b . pMax )) {} BoundsBase ( const Point < T , S > & p1 , const Point < T , S > & p2 ) : pMin ( min ( p1 , p2 )), pMax ( max ( p1 , p2 )) {} [[ nodiscard ]] Vector < T , S > diagonal () const { return pMax - pMin ; } [[ nodiscard ]] size_t maxExtent () const { return this -> diagonal (). maxElementIndex (); } bool operator == ( const BoundsBase & rhs ) const { return pMin == rhs . pMin && pMax == rhs . pMax ; } bool operator != ( const BoundsBase & rhs ) const { return pMin != rhs . pMin || pMax != rhs . pMax ; } [[ nodiscard ]] Point < T , S > lerp ( const Point < float , S > & t ) const { Point < T , S > ret ; for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = std :: lerp ( pMin [ i ], pMax [ i ], t [ i ]); return ret ; } [[ nodiscard ]] Vector < T , S > offset ( const Point < T , S > & p ) const { Vector < T , S > o = p - pMin ; for ( size_t i = 0 ; i < S ; ++ i ) if ( pMax [ i ] > pMin [ i ]) o [ i ] /= pMax [ i ] - pMin [ i ]; return o ; } friend bool overlaps ( const BoundsBase & a , const BoundsBase & b ) { for ( size_t i = 0 ; i < S ; ++ i ) if ( ! ( a . pMax [ i ] >= b . pMin [ i ] && a . pMin [ i ] <= b . pMax [ i ])) return false ; return true ; } friend bool inside ( const Point < T , S > & p , const BoundsBase & b ) { for ( size_t i = 0 ; i < S ; ++ i ) if ( ! ( p [ i ] >= b . pMin [ i ] && p [ i ] <= b . pMax [ i ])) return false ; return true ; } friend bool insideExclusive ( const Point < T , S > & p , const BoundsBase & b ) { for ( size_t i = 0 ; i < S ; ++ i ) if ( ! ( p [ i ] >= b . pMin [ i ] && p [ i ] < b . pMax [ i ])) return false ; return true ; } friend decltype ( auto ) distanceSquared ( const Point < T , S > & p , const BoundsBase & b ) { return max ( Vector < T , S > {}, max ( b . pMin - p , p - b . pMax )). squaredNorm (); } friend decltype ( auto ) distance ( const Point < T , S > & p , const BoundsBase & b ) { return std :: sqrt ( distanceSquared ( p , b )); } void boundingSphere ( Point < T , S > & center , float & rad ) { center = ( pMin + pMax ) / 2 ; rad = inside ( center , * this ) ? distance ( center , pMax ) : 0 ; } friend BoundsBase operator | ( const BoundsBase & a , const BoundsBase & b ) { BoundsBase ret ; ret . pMin = min ( a . pMin , b . pMin ); ret . pMax = max ( a . pMax , b . pMax ); return ret ; } friend BoundsBase operator | ( const BoundsBase & b , const Point < T , S > & p ) { BoundsBase ret ; ret . pMin = min ( b . pMin , p ); ret . pMax = max ( b . Pmax , p ); return ret ; } friend BoundsBase operator & ( const BoundsBase & a , const BoundsBase & b ) { BoundsBase ret ; // important: assign to pMin/pMax directly and don't run the BoundsBase() // constructor, since it takes min/max of the points passed to it. In // turn, that breaks returning an invalid bound for the case where we // intersect non-overlapping bounds (as we'd like to happen). ret . pMin = max ( a . pMin , b . pMin ); ret . pMax = min ( a . pMax , b . pMax ); return ret ; } [[ nodiscard ]] std :: string toString () const { return \"[\" + pMin . toString () + \", \" + pMax . toString () + \"]\" ; } friend std :: ostream & operator << ( std :: ostream & os , const BoundsBase & b ) { return os << b . toString (); } Point < T , S > pMin { std :: numeric_limits < T >:: max ()}; Point < T , S > pMax { std :: numeric_limits < T >:: lowest ()}; }; template < ArithmeticType T > class Bounds2 : public BoundsBase < T , 2 > { public : using BoundsBase < T , 2 >:: BoundsBase ; Bounds2 ( const BoundsBase < T , 2 > & base ) : BoundsBase < T , 2 > ( base ) {} [[ nodiscard ]] decltype ( auto ) area () const { auto d = this -> diagonal (); return d . x () * d . y (); } }; using Bounds2f = Bounds2 < float > ; using Bounds2i = Bounds2 < int > ; template < ArithmeticType T > class Bounds3 : public BoundsBase < T , 3 > { public : using BoundsBase < T , 3 >:: BoundsBase ; Bounds3 ( const BoundsBase < T , 3 > & base ) : BoundsBase < T , 3 > ( base ) {} }; using Bounds3f = Bounds3 < float > ; class Bounds2iIterator : public std :: forward_iterator_tag { public : explicit Bounds2iIterator ( const Bounds2i & b , Point2i p ) : b ( b ), p ( std :: move ( p )) {} Bounds2iIterator operator ++ () { advance (); return * this ; } Bounds2iIterator operator ++ ( int ) { Bounds2iIterator ret = * this ; advance (); return ret ; } bool operator == ( const Bounds2iIterator & rhs ) const { return p == rhs . p && ( & b == & rhs . b ); } bool operator != ( const Bounds2iIterator & rhs ) const { return p != rhs . p || ( & b != & rhs . b ); } Point2i operator * () const { return p ; } private : void advance () { ++ p . x (); if ( p . x () == b . pMax . x ()) { p . x () = b . pMin . x (); ++ p . y (); } } const Bounds2i & b ; Point2i p ; }; inline Bounds2iIterator begin ( const Bounds2i & b ) { return Bounds2iIterator { b , b . pMin }; } inline Bounds2iIterator end ( const Bounds2i & b ) { // normally, the ending point is at the minimum x value and one past // the last valid y value. Point2i pEnd ( b . pMin . x (), b . pMax . y ()); // however, if the bounds are degenerate, override the end point to // equal the start point so that any attempt to iterate over the bounds // exits out immediately. if ( b . pMin . x () >= b . pMax . x () || b . pMin . y () >= b . pMax . y ()) pEnd = b . pMin ; return Bounds2iIterator { b , pEnd }; } } // namespace dakku #endif Updated on 2022-04-11 at 15:27:23 +0000","title":"Source code"},{"location":"Files/box_8h/","text":"src/filters/box.h Namespaces Name dakku dakku namespace Classes Name class dakku::BoxFilter box filter the box filter is simple, just return \\(1\\) for all values Source code #ifndef DAKKU_FILTERS_BOX_H_ #define DAKKU_FILTERS_BOX_H_ #include <filters/fwd.h> #include <core/filter.h> namespace dakku { class DAKKU_EXPORT_FILTERS BoxFilter : public Filter { public : DAKKU_DECLARE_OBJECT ( BoxFilter , Filter ); using Filter :: Filter ; [[ nodiscard ]] float evaluate ( const Point2f & p ) const override ; }; } // namespace dakku #endif Updated on 2022-04-11 at 15:27:24 +0000","title":"src/filters/box.h"},{"location":"Files/box_8h/#srcfiltersboxh","text":"","title":"src/filters/box.h"},{"location":"Files/box_8h/#namespaces","text":"Name dakku dakku namespace","title":"Namespaces"},{"location":"Files/box_8h/#classes","text":"Name class dakku::BoxFilter box filter the box filter is simple, just return \\(1\\) for all values","title":"Classes"},{"location":"Files/box_8h/#source-code","text":"#ifndef DAKKU_FILTERS_BOX_H_ #define DAKKU_FILTERS_BOX_H_ #include <filters/fwd.h> #include <core/filter.h> namespace dakku { class DAKKU_EXPORT_FILTERS BoxFilter : public Filter { public : DAKKU_DECLARE_OBJECT ( BoxFilter , Filter ); using Filter :: Filter ; [[ nodiscard ]] float evaluate ( const Point2f & p ) const override ; }; } // namespace dakku #endif Updated on 2022-04-11 at 15:27:24 +0000","title":"Source code"},{"location":"Files/class_8h/","text":"src/core/class.h Namespaces Name dakku dakku namespace Classes Name class dakku::Class RTTI support. Source code #ifndef DAKKU_CORE_CLASS_H_ #define DAKKU_CORE_CLASS_H_ #include <core/fwd.h> #include <core/logger.h> #include <core/property.h> #include <string> #include <map> #include <string_view> namespace dakku { class DAKKU_EXPORT_CORE Class final { public : static Class & instance (); template < ObjectType T > void registerClass (); [[ nodiscard ]] bool isDerivedFrom ( std :: string_view cur , std :: string_view from ) const ; [[ nodiscard ]] bool isBaseof ( std :: string_view cur , std :: string_view other ) const ; [[ nodiscard ]] bool contains ( std :: string_view name ) const ; Object * create ( std :: string_view name , const Property & = {}); private : explicit Class () = default ; template < typename T > static Object * constructor ( const Property & ); struct Metadata { std :: add_pointer_t < Object * ( const Property & ) > constructor ; std :: string parent ; }; #if defined(_MSC_VER) #pragma warning(push) #pragma warning(disable : 4251) #endif std :: map < std :: string , Metadata , std :: less <>> _classMap ; #if defined(_MSC_VER) #pragma warning(pop) #endif }; template < ObjectType T > void Class :: registerClass () { if ( ! _classMap . contains ( T :: getClassNameStatic ())) { DAKKU_INFO ( \"register class: {}, parent: {}\" , T :: getClassNameStatic (), T :: getParentNameStatic ()); _classMap [ T :: getClassNameStatic ()] = { & constructor < T > , T :: getParentNameStatic ()}; } else { DAKKU_WARN ( \"class {} has already been registered\" , T :: getClassNameStatic ()); } } template < typename T > Object * Class :: constructor ( const Property & property ) { if constexpr ( std :: is_default_constructible_v < T > ) { return new T { property }; } else { DAKKU_ERR ( \"cannot construct {}\" , T :: getClassNameStatic ()); return nullptr ; } } } // namespace dakku #endif Updated on 2022-04-11 at 15:27:24 +0000","title":"src/core/class.h"},{"location":"Files/class_8h/#srccoreclassh","text":"","title":"src/core/class.h"},{"location":"Files/class_8h/#namespaces","text":"Name dakku dakku namespace","title":"Namespaces"},{"location":"Files/class_8h/#classes","text":"Name class dakku::Class RTTI support.","title":"Classes"},{"location":"Files/class_8h/#source-code","text":"#ifndef DAKKU_CORE_CLASS_H_ #define DAKKU_CORE_CLASS_H_ #include <core/fwd.h> #include <core/logger.h> #include <core/property.h> #include <string> #include <map> #include <string_view> namespace dakku { class DAKKU_EXPORT_CORE Class final { public : static Class & instance (); template < ObjectType T > void registerClass (); [[ nodiscard ]] bool isDerivedFrom ( std :: string_view cur , std :: string_view from ) const ; [[ nodiscard ]] bool isBaseof ( std :: string_view cur , std :: string_view other ) const ; [[ nodiscard ]] bool contains ( std :: string_view name ) const ; Object * create ( std :: string_view name , const Property & = {}); private : explicit Class () = default ; template < typename T > static Object * constructor ( const Property & ); struct Metadata { std :: add_pointer_t < Object * ( const Property & ) > constructor ; std :: string parent ; }; #if defined(_MSC_VER) #pragma warning(push) #pragma warning(disable : 4251) #endif std :: map < std :: string , Metadata , std :: less <>> _classMap ; #if defined(_MSC_VER) #pragma warning(pop) #endif }; template < ObjectType T > void Class :: registerClass () { if ( ! _classMap . contains ( T :: getClassNameStatic ())) { DAKKU_INFO ( \"register class: {}, parent: {}\" , T :: getClassNameStatic (), T :: getParentNameStatic ()); _classMap [ T :: getClassNameStatic ()] = { & constructor < T > , T :: getParentNameStatic ()}; } else { DAKKU_WARN ( \"class {} has already been registered\" , T :: getClassNameStatic ()); } } template < typename T > Object * Class :: constructor ( const Property & property ) { if constexpr ( std :: is_default_constructible_v < T > ) { return new T { property }; } else { DAKKU_ERR ( \"cannot construct {}\" , T :: getClassNameStatic ()); return nullptr ; } } } // namespace dakku #endif Updated on 2022-04-11 at 15:27:24 +0000","title":"Source code"},{"location":"Files/constant_8h/","text":"src/textures/constant.h Namespaces Name dakku dakku namespace Classes Name class dakku::ConstantTexture Source code #ifndef DAKKU_TEXTURES_CONSTANT_H_ #define DAKKU_TEXTURES_CONSTANT_H_ #include <textures/fwd.h> #include <core/spectrum.h> namespace dakku { class DAKKU_EXPORT_TEXTURES ConstantTexture : public Texture { public : DAKKU_DECLARE_OBJECT ( ConstantTexture , Texture ); explicit ConstantTexture ( float v ); explicit ConstantTexture ( Spectrum v ); [[ nodiscard ]] Spectrum evaluate ( const SurfaceInteraction & ) const override ; private : #if defined(_MSC_VER) #pragma warning(push) #pragma warning(disable : 4251) #endif Spectrum value ; #if defined(_MSC_VER) #pragma warning(pop) #endif }; } // namespace dakku #endif Updated on 2022-04-11 at 15:27:24 +0000","title":"src/textures/constant.h"},{"location":"Files/constant_8h/#srctexturesconstanth","text":"","title":"src/textures/constant.h"},{"location":"Files/constant_8h/#namespaces","text":"Name dakku dakku namespace","title":"Namespaces"},{"location":"Files/constant_8h/#classes","text":"Name class dakku::ConstantTexture","title":"Classes"},{"location":"Files/constant_8h/#source-code","text":"#ifndef DAKKU_TEXTURES_CONSTANT_H_ #define DAKKU_TEXTURES_CONSTANT_H_ #include <textures/fwd.h> #include <core/spectrum.h> namespace dakku { class DAKKU_EXPORT_TEXTURES ConstantTexture : public Texture { public : DAKKU_DECLARE_OBJECT ( ConstantTexture , Texture ); explicit ConstantTexture ( float v ); explicit ConstantTexture ( Spectrum v ); [[ nodiscard ]] Spectrum evaluate ( const SurfaceInteraction & ) const override ; private : #if defined(_MSC_VER) #pragma warning(push) #pragma warning(disable : 4251) #endif Spectrum value ; #if defined(_MSC_VER) #pragma warning(pop) #endif }; } // namespace dakku #endif Updated on 2022-04-11 at 15:27:24 +0000","title":"Source code"},{"location":"Files/core_2api_8h/","text":"src/core/api.h this must be include only once in source Namespaces Name dakku dakku namespace Source code #ifndef DAKKU_CORE_API_H_ #define DAKKU_CORE_API_H_ #include <core/object.h> #include <core/serialization.h> #include <core/filter.h> #include <core/film.h> #include <core/texture.h> namespace dakku { DAKKU_EXPORT_OBJECTS ( Core , Object , InputStream , OutputStream , SerializableObject , Filter , Film , Texture ); } // namespace dakku #endif Updated on 2022-04-11 at 15:27:23 +0000","title":"src/core/api.h"},{"location":"Files/core_2api_8h/#srccoreapih","text":"this must be include only once in source","title":"src/core/api.h"},{"location":"Files/core_2api_8h/#namespaces","text":"Name dakku dakku namespace","title":"Namespaces"},{"location":"Files/core_2api_8h/#source-code","text":"#ifndef DAKKU_CORE_API_H_ #define DAKKU_CORE_API_H_ #include <core/object.h> #include <core/serialization.h> #include <core/filter.h> #include <core/film.h> #include <core/texture.h> namespace dakku { DAKKU_EXPORT_OBJECTS ( Core , Object , InputStream , OutputStream , SerializableObject , Filter , Film , Texture ); } // namespace dakku #endif Updated on 2022-04-11 at 15:27:23 +0000","title":"Source code"},{"location":"Files/core_2film_8h/","text":"src/core/film.h Namespaces Name dakku dakku namespace Classes Name struct dakku::FilmTilePixel film tile pixel class dakku::Film film class class dakku::FilmTile film tile Source code #ifndef DAKKU_CORE_FILM_H_ #define DAKKU_CORE_FILM_H_ #include <core/serialization.h> #include <core/bounds.h> #include <core/spectrum.h> #include <core/memory.h> #include <mutex> namespace dakku { struct FilmTilePixel { Spectrum contribSum ; float filterWeightSum ; }; class DAKKU_EXPORT_CORE Film : public SerializableObject { public : DAKKU_DECLARE_OBJECT ( Film , SerializableObject ); explicit Film ( const Point2i & fullResolution , const Bounds2f & cropWindow , std :: unique_ptr < Filter > filter , std :: string fileName , float scale , float maxSampleLuminance = INF ); [[ nodiscard ]] Bounds2i getSampleBounds () const ; std :: unique_ptr < FilmTile > getFilmTile ( const Bounds2i & sampleBounds ); void mergeFilmTile ( std :: unique_ptr < FilmTile > tile ); void writeImage ( float splatScale = 1 ) const ; void writeImageTo ( std :: span < float > buffer , float splatScale = 1 ) const ; void writeImageTo ( std :: vector < std :: uint8_t > & buffer , float splatScale = 1 ) const ; void serialize ( OutputStream * stream ) const override ; void deserialize ( InputStream * stream ) override ; [[ nodiscard ]] Bounds2i getCroppedPixelBounds () const ; private : #if defined(_MSC_VER) #pragma warning(push) #pragma warning(disable : 4251) #endif struct Pixel { float xyz [ 3 ]; float filterWeightSum ; std :: atomic < float > splatXyz [ 3 ]; float _padding ; }; std :: unique_ptr < Pixel [] > pixels {}; Point2i fullResolution ; std :: unique_ptr < Filter > filter {}; const std :: string fileName ; Bounds2i croppedPixelBounds ; static constexpr size_t filterTableWidth = 16 ; std :: array < float , filterTableWidth * filterTableWidth > filterTable {}; std :: mutex mutex ; const float scale ; const float maxSampleLuminance ; #if defined(_MSC_VER) #pragma warning(pop) #endif Pixel & getPixel ( const Point2i & p ) { return const_cast < Pixel &> ( static_cast < const Film &> ( * this ). getPixel ( p )); } [[ nodiscard ]] const Pixel & getPixel ( const Point2i & p ) const { DAKKU_CHECK ( insideExclusive ( p , croppedPixelBounds ), \"index out of range\" ); int width = croppedPixelBounds . pMax . x () - croppedPixelBounds . pMin . x (); int offset = ( p . x () - croppedPixelBounds . pMin . x ()) + ( p . y () - croppedPixelBounds . pMin . y ()) * width ; return pixels [ offset ]; } }; class FilmTile { public : explicit FilmTile ( const Bounds2i & pixelBounds , const Vector2f & filterRadius , std :: span < const float > filterTable , int filterTableSize , float maxSampleLuminance = INF ) : pixelBounds ( pixelBounds ), filterRadius ( filterRadius ), invFilterRadius ( 1 / filterRadius . x (), 1 / filterRadius . y ()), filterTable ( filterTable ), filterTableSize ( filterTableSize ), maxSampleLuminance ( maxSampleLuminance ) { pixels . resize ( std :: max ( 0 , pixelBounds . area ())); } FilmTilePixel & getPixel ( const Point2i & p ) { return const_cast < FilmTilePixel &> ( static_cast < const FilmTile &> ( * this ). getPixel ( p )); } [[ nodiscard ]] const FilmTilePixel & getPixel ( const Point2i & p ) const { DAKKU_CHECK ( insideExclusive ( p , pixelBounds ), \"index out of range: {}\" , p ); int width = pixelBounds . pMax . x () - pixelBounds . pMin . x (); int offset = ( p . x () - pixelBounds . pMin . x ()) + ( p . y () - pixelBounds . pMin . y ()) * width ; return pixels [ offset ]; } [[ nodiscard ]] Bounds2i getPixelBounds () const { return pixelBounds ; } void addSample ( const Point2f & pFilm , Spectrum L , float sampleWeight = 1 ) { if ( L . y () > maxSampleLuminance ) L *= maxSampleLuminance / L . y (); // compute sample's raster bounds Point2f pFilmDiscrete = pFilm - Vector2f ( 0.5 , 0.5 ); Point2i p0 = Point2i ( ceil ( pFilmDiscrete - filterRadius )); Point2i p1 = Point2i ( floor ( pFilmDiscrete + filterRadius )) + Point2i ( 1 , 1 ); p0 = max ( p0 , pixelBounds . pMin ); p1 = min ( p1 , pixelBounds . pMax ); // Loop over filter support and add sample to pixel arrays // recompute x and y filter table offsets int * ifx = DAKKU_ALLOCA ( int , p1 . x () - p0 . x ()); for ( int x = p0 . x (); x < p1 . x (); ++ x ) { float fx = std :: abs (( static_cast < float > ( x ) - pFilmDiscrete . x ()) * invFilterRadius . x () * static_cast < float > ( filterTableSize )); ifx [ x - p0 . x ()] = std :: min ( static_cast < int > ( std :: floor ( fx )), filterTableSize - 1 ); } int * ify = DAKKU_ALLOCA ( int , p1 . y () - p0 . y ()); for ( int y = p0 . y (); y < p1 . y (); ++ y ) { float fy = std :: abs (( static_cast < float > ( y ) - pFilmDiscrete . y ()) * invFilterRadius . y () * static_cast < float > ( filterTableSize )); ify [ y - p0 . y ()] = std :: min ( static_cast < int > ( std :: floor ( fy )), filterTableSize - 1 ); } for ( int y = p0 . y (); y < p1 . y (); ++ y ) { for ( int x = p0 . x (); x < p1 . x (); ++ x ) { // evaluate filter value at (x, y) pixel int offset = ify [ y - p0 . y ()] * filterTableSize + ifx [ x - p0 . x ()]; float filterWeight = filterTable [ offset ]; // update pixel values with filtered sample contribution FilmTilePixel & pixel = getPixel ( Point2i ( x , y )); pixel . contribSum += L * sampleWeight * filterWeight ; pixel . filterWeightSum += filterWeight ; } } } private : const Bounds2i pixelBounds ; const Vector2f filterRadius , invFilterRadius ; std :: span < const float > filterTable ; const int filterTableSize ; std :: vector < FilmTilePixel > pixels ; const float maxSampleLuminance ; friend class Film ; }; } // namespace dakku #endif Updated on 2022-04-11 at 15:27:24 +0000","title":"src/core/film.h"},{"location":"Files/core_2film_8h/#srccorefilmh","text":"","title":"src/core/film.h"},{"location":"Files/core_2film_8h/#namespaces","text":"Name dakku dakku namespace","title":"Namespaces"},{"location":"Files/core_2film_8h/#classes","text":"Name struct dakku::FilmTilePixel film tile pixel class dakku::Film film class class dakku::FilmTile film tile","title":"Classes"},{"location":"Files/core_2film_8h/#source-code","text":"#ifndef DAKKU_CORE_FILM_H_ #define DAKKU_CORE_FILM_H_ #include <core/serialization.h> #include <core/bounds.h> #include <core/spectrum.h> #include <core/memory.h> #include <mutex> namespace dakku { struct FilmTilePixel { Spectrum contribSum ; float filterWeightSum ; }; class DAKKU_EXPORT_CORE Film : public SerializableObject { public : DAKKU_DECLARE_OBJECT ( Film , SerializableObject ); explicit Film ( const Point2i & fullResolution , const Bounds2f & cropWindow , std :: unique_ptr < Filter > filter , std :: string fileName , float scale , float maxSampleLuminance = INF ); [[ nodiscard ]] Bounds2i getSampleBounds () const ; std :: unique_ptr < FilmTile > getFilmTile ( const Bounds2i & sampleBounds ); void mergeFilmTile ( std :: unique_ptr < FilmTile > tile ); void writeImage ( float splatScale = 1 ) const ; void writeImageTo ( std :: span < float > buffer , float splatScale = 1 ) const ; void writeImageTo ( std :: vector < std :: uint8_t > & buffer , float splatScale = 1 ) const ; void serialize ( OutputStream * stream ) const override ; void deserialize ( InputStream * stream ) override ; [[ nodiscard ]] Bounds2i getCroppedPixelBounds () const ; private : #if defined(_MSC_VER) #pragma warning(push) #pragma warning(disable : 4251) #endif struct Pixel { float xyz [ 3 ]; float filterWeightSum ; std :: atomic < float > splatXyz [ 3 ]; float _padding ; }; std :: unique_ptr < Pixel [] > pixels {}; Point2i fullResolution ; std :: unique_ptr < Filter > filter {}; const std :: string fileName ; Bounds2i croppedPixelBounds ; static constexpr size_t filterTableWidth = 16 ; std :: array < float , filterTableWidth * filterTableWidth > filterTable {}; std :: mutex mutex ; const float scale ; const float maxSampleLuminance ; #if defined(_MSC_VER) #pragma warning(pop) #endif Pixel & getPixel ( const Point2i & p ) { return const_cast < Pixel &> ( static_cast < const Film &> ( * this ). getPixel ( p )); } [[ nodiscard ]] const Pixel & getPixel ( const Point2i & p ) const { DAKKU_CHECK ( insideExclusive ( p , croppedPixelBounds ), \"index out of range\" ); int width = croppedPixelBounds . pMax . x () - croppedPixelBounds . pMin . x (); int offset = ( p . x () - croppedPixelBounds . pMin . x ()) + ( p . y () - croppedPixelBounds . pMin . y ()) * width ; return pixels [ offset ]; } }; class FilmTile { public : explicit FilmTile ( const Bounds2i & pixelBounds , const Vector2f & filterRadius , std :: span < const float > filterTable , int filterTableSize , float maxSampleLuminance = INF ) : pixelBounds ( pixelBounds ), filterRadius ( filterRadius ), invFilterRadius ( 1 / filterRadius . x (), 1 / filterRadius . y ()), filterTable ( filterTable ), filterTableSize ( filterTableSize ), maxSampleLuminance ( maxSampleLuminance ) { pixels . resize ( std :: max ( 0 , pixelBounds . area ())); } FilmTilePixel & getPixel ( const Point2i & p ) { return const_cast < FilmTilePixel &> ( static_cast < const FilmTile &> ( * this ). getPixel ( p )); } [[ nodiscard ]] const FilmTilePixel & getPixel ( const Point2i & p ) const { DAKKU_CHECK ( insideExclusive ( p , pixelBounds ), \"index out of range: {}\" , p ); int width = pixelBounds . pMax . x () - pixelBounds . pMin . x (); int offset = ( p . x () - pixelBounds . pMin . x ()) + ( p . y () - pixelBounds . pMin . y ()) * width ; return pixels [ offset ]; } [[ nodiscard ]] Bounds2i getPixelBounds () const { return pixelBounds ; } void addSample ( const Point2f & pFilm , Spectrum L , float sampleWeight = 1 ) { if ( L . y () > maxSampleLuminance ) L *= maxSampleLuminance / L . y (); // compute sample's raster bounds Point2f pFilmDiscrete = pFilm - Vector2f ( 0.5 , 0.5 ); Point2i p0 = Point2i ( ceil ( pFilmDiscrete - filterRadius )); Point2i p1 = Point2i ( floor ( pFilmDiscrete + filterRadius )) + Point2i ( 1 , 1 ); p0 = max ( p0 , pixelBounds . pMin ); p1 = min ( p1 , pixelBounds . pMax ); // Loop over filter support and add sample to pixel arrays // recompute x and y filter table offsets int * ifx = DAKKU_ALLOCA ( int , p1 . x () - p0 . x ()); for ( int x = p0 . x (); x < p1 . x (); ++ x ) { float fx = std :: abs (( static_cast < float > ( x ) - pFilmDiscrete . x ()) * invFilterRadius . x () * static_cast < float > ( filterTableSize )); ifx [ x - p0 . x ()] = std :: min ( static_cast < int > ( std :: floor ( fx )), filterTableSize - 1 ); } int * ify = DAKKU_ALLOCA ( int , p1 . y () - p0 . y ()); for ( int y = p0 . y (); y < p1 . y (); ++ y ) { float fy = std :: abs (( static_cast < float > ( y ) - pFilmDiscrete . y ()) * invFilterRadius . y () * static_cast < float > ( filterTableSize )); ify [ y - p0 . y ()] = std :: min ( static_cast < int > ( std :: floor ( fy )), filterTableSize - 1 ); } for ( int y = p0 . y (); y < p1 . y (); ++ y ) { for ( int x = p0 . x (); x < p1 . x (); ++ x ) { // evaluate filter value at (x, y) pixel int offset = ify [ y - p0 . y ()] * filterTableSize + ifx [ x - p0 . x ()]; float filterWeight = filterTable [ offset ]; // update pixel values with filtered sample contribution FilmTilePixel & pixel = getPixel ( Point2i ( x , y )); pixel . contribSum += L * sampleWeight * filterWeight ; pixel . filterWeightSum += filterWeight ; } } } private : const Bounds2i pixelBounds ; const Vector2f filterRadius , invFilterRadius ; std :: span < const float > filterTable ; const int filterTableSize ; std :: vector < FilmTilePixel > pixels ; const float maxSampleLuminance ; friend class Film ; }; } // namespace dakku #endif Updated on 2022-04-11 at 15:27:24 +0000","title":"Source code"},{"location":"Files/core_2fwd_8h/","text":"src/core/fwd.h Namespaces Name dakku dakku namespace Defines Name DAKKU_EXPORT_CORE Macros Documentation define DAKKU_EXPORT_CORE #define DAKKU_EXPORT_CORE DAKKU_EXPORT Source code #ifndef DAKKU_CORE_FWD_H_ #define DAKKU_CORE_FWD_H_ #include <platform.h> #include <type_traits> #include <limits> #include <numbers> #include <cmath> #include <cstdint> #include <bit> namespace dakku { #if DAKKU_BUILD_MODULE != DAKKU_CORE_MODULE #define DAKKU_EXPORT_CORE DAKKU_IMPORT #else #define DAKKU_EXPORT_CORE DAKKU_EXPORT #endif static constexpr float INF = std :: numeric_limits < float >:: infinity (); static constexpr float PI = std :: numbers :: pi_v < float > ; static constexpr size_t L1_CACHE_LINE_SIZE = 64 ; static constexpr float SHADOW_EPS = 1e-4f ; template < typename T > concept ArithmeticType = std :: is_arithmetic_v < std :: decay_t < T >> ; template < typename T > requires std :: is_floating_point_v < T > DAKKU_INLINE bool isNaN ( T x ) { return std :: isnan ( x ); } template < typename T > requires std :: is_integral_v < T > DAKKU_INLINE bool isNaN ( T ) { return false ; } inline float radians ( float deg ) { return PI / 180.0f * deg ; } inline float degrees ( float rad ) { return 180.0f / PI * rad ; } template < typename T > requires std :: is_integral_v < T > inline constexpr bool isPowerOf2 ( T v ) { return v && ! ( v & ( v - 1 )); } inline std :: int32_t roundUpPow2 ( std :: int32_t v ) { -- v ; v |= v >> 1 ; v |= v >> 2 ; v |= v >> 4 ; v |= v >> 8 ; v |= v >> 16 ; return v + 1 ; } inline float evalLanczos ( float x , float tau = 2 ) { x = std :: abs ( x ); if ( x < 1e-5f ) return 1 ; if ( x > 1.0f ) return 0 ; x *= PI ; float s = std :: sin ( x * tau ) / ( x * tau ); float lanczos = std :: sin ( x ) / x ; return s * lanczos ; } inline int log2Int ( std :: int32_t v ) { return 31 - std :: countl_zero ( static_cast < std :: uint32_t > ( v )); } inline int log2Int ( std :: int64_t v ) { return 63 - std :: countl_zero ( static_cast < std :: uint64_t > ( v )); } template < ArithmeticType T > inline T lerp ( T a , T b , T t ) { return std :: lerp ( a , b , t ); } class DAKKU_EXPORT_CORE RelativeRoot ; class DAKKU_EXPORT_CORE InputStream ; class DAKKU_EXPORT_CORE OutputStream ; enum class PropertyType ; class DAKKU_EXPORT_CORE Property ; class DAKKU_EXPORT_CORE Class ; class DAKKU_EXPORT_CORE Object ; struct DAKKU_EXPORT_CORE Matrix4x4 ; template < typename T > concept ObjectType = std :: is_base_of_v < Object , T > ; class Transform ; class Ray ; class RayDifferential ; class DAKKU_EXPORT_CORE Filter ; class DAKKU_EXPORT_CORE Film ; class FilmTile ; template < size_t S , typename Derived > class CoefficientSpectrum ; class RgbSpectrum ; using Spectrum = RgbSpectrum ; struct Interaction ; class SurfaceInteraction ; class DAKKU_EXPORT_CORE Shape ; class DAKKU_EXPORT_CORE Texture ; } // namespace dakku #endif Updated on 2022-04-11 at 15:27:24 +0000","title":"src/core/fwd.h"},{"location":"Files/core_2fwd_8h/#srccorefwdh","text":"","title":"src/core/fwd.h"},{"location":"Files/core_2fwd_8h/#namespaces","text":"Name dakku dakku namespace","title":"Namespaces"},{"location":"Files/core_2fwd_8h/#defines","text":"Name DAKKU_EXPORT_CORE","title":"Defines"},{"location":"Files/core_2fwd_8h/#macros-documentation","text":"","title":"Macros Documentation"},{"location":"Files/core_2fwd_8h/#define-dakku_export_core","text":"#define DAKKU_EXPORT_CORE DAKKU_EXPORT","title":"define DAKKU_EXPORT_CORE"},{"location":"Files/core_2fwd_8h/#source-code","text":"#ifndef DAKKU_CORE_FWD_H_ #define DAKKU_CORE_FWD_H_ #include <platform.h> #include <type_traits> #include <limits> #include <numbers> #include <cmath> #include <cstdint> #include <bit> namespace dakku { #if DAKKU_BUILD_MODULE != DAKKU_CORE_MODULE #define DAKKU_EXPORT_CORE DAKKU_IMPORT #else #define DAKKU_EXPORT_CORE DAKKU_EXPORT #endif static constexpr float INF = std :: numeric_limits < float >:: infinity (); static constexpr float PI = std :: numbers :: pi_v < float > ; static constexpr size_t L1_CACHE_LINE_SIZE = 64 ; static constexpr float SHADOW_EPS = 1e-4f ; template < typename T > concept ArithmeticType = std :: is_arithmetic_v < std :: decay_t < T >> ; template < typename T > requires std :: is_floating_point_v < T > DAKKU_INLINE bool isNaN ( T x ) { return std :: isnan ( x ); } template < typename T > requires std :: is_integral_v < T > DAKKU_INLINE bool isNaN ( T ) { return false ; } inline float radians ( float deg ) { return PI / 180.0f * deg ; } inline float degrees ( float rad ) { return 180.0f / PI * rad ; } template < typename T > requires std :: is_integral_v < T > inline constexpr bool isPowerOf2 ( T v ) { return v && ! ( v & ( v - 1 )); } inline std :: int32_t roundUpPow2 ( std :: int32_t v ) { -- v ; v |= v >> 1 ; v |= v >> 2 ; v |= v >> 4 ; v |= v >> 8 ; v |= v >> 16 ; return v + 1 ; } inline float evalLanczos ( float x , float tau = 2 ) { x = std :: abs ( x ); if ( x < 1e-5f ) return 1 ; if ( x > 1.0f ) return 0 ; x *= PI ; float s = std :: sin ( x * tau ) / ( x * tau ); float lanczos = std :: sin ( x ) / x ; return s * lanczos ; } inline int log2Int ( std :: int32_t v ) { return 31 - std :: countl_zero ( static_cast < std :: uint32_t > ( v )); } inline int log2Int ( std :: int64_t v ) { return 63 - std :: countl_zero ( static_cast < std :: uint64_t > ( v )); } template < ArithmeticType T > inline T lerp ( T a , T b , T t ) { return std :: lerp ( a , b , t ); } class DAKKU_EXPORT_CORE RelativeRoot ; class DAKKU_EXPORT_CORE InputStream ; class DAKKU_EXPORT_CORE OutputStream ; enum class PropertyType ; class DAKKU_EXPORT_CORE Property ; class DAKKU_EXPORT_CORE Class ; class DAKKU_EXPORT_CORE Object ; struct DAKKU_EXPORT_CORE Matrix4x4 ; template < typename T > concept ObjectType = std :: is_base_of_v < Object , T > ; class Transform ; class Ray ; class RayDifferential ; class DAKKU_EXPORT_CORE Filter ; class DAKKU_EXPORT_CORE Film ; class FilmTile ; template < size_t S , typename Derived > class CoefficientSpectrum ; class RgbSpectrum ; using Spectrum = RgbSpectrum ; struct Interaction ; class SurfaceInteraction ; class DAKKU_EXPORT_CORE Shape ; class DAKKU_EXPORT_CORE Texture ; } // namespace dakku #endif Updated on 2022-04-11 at 15:27:24 +0000","title":"Source code"},{"location":"Files/dir_090521d29e73b40f7fc0a63254d8965e/","text":"src/stream Files Name src/stream/api.h this must be include only once in source src/stream/fstream.h src/stream/fwd.h Updated on 2022-04-11 at 15:27:24 +0000","title":"src/stream"},{"location":"Files/dir_090521d29e73b40f7fc0a63254d8965e/#srcstream","text":"","title":"src/stream"},{"location":"Files/dir_090521d29e73b40f7fc0a63254d8965e/#files","text":"Name src/stream/api.h this must be include only once in source src/stream/fstream.h src/stream/fwd.h Updated on 2022-04-11 at 15:27:24 +0000","title":"Files"},{"location":"Files/dir_0a15cfbbecb5f97b1f4d0d4d1ae63ab7/","text":"src/textures Files Name src/textures/api.h this must be include only once in source src/textures/constant.h src/textures/fwd.h src/textures/image.h Updated on 2022-04-11 at 15:27:24 +0000","title":"src/textures"},{"location":"Files/dir_0a15cfbbecb5f97b1f4d0d4d1ae63ab7/#srctextures","text":"","title":"src/textures"},{"location":"Files/dir_0a15cfbbecb5f97b1f4d0d4d1ae63ab7/#files","text":"Name src/textures/api.h this must be include only once in source src/textures/constant.h src/textures/fwd.h src/textures/image.h Updated on 2022-04-11 at 15:27:24 +0000","title":"Files"},{"location":"Files/dir_1bc13244e26df1e1f069a1fd18e36da3/","text":"src/filters Files Name src/filters/api.h src/filters/box.h src/filters/fwd.h src/filters/triangle.h Updated on 2022-04-11 at 15:27:24 +0000","title":"src/filters"},{"location":"Files/dir_1bc13244e26df1e1f069a1fd18e36da3/#srcfilters","text":"","title":"src/filters"},{"location":"Files/dir_1bc13244e26df1e1f069a1fd18e36da3/#files","text":"Name src/filters/api.h src/filters/box.h src/filters/fwd.h src/filters/triangle.h Updated on 2022-04-11 at 15:27:24 +0000","title":"Files"},{"location":"Files/dir_68267d1309a1af8e8297ef4c3efbcdba/","text":"src Directories Name src/core src/filters src/gui src/imageio src/stream src/textures Files Name src/platform.h Updated on 2022-04-11 at 15:27:23 +0000","title":"src"},{"location":"Files/dir_68267d1309a1af8e8297ef4c3efbcdba/#src","text":"","title":"src"},{"location":"Files/dir_68267d1309a1af8e8297ef4c3efbcdba/#directories","text":"Name src/core src/filters src/gui src/imageio src/stream src/textures","title":"Directories"},{"location":"Files/dir_68267d1309a1af8e8297ef4c3efbcdba/#files","text":"Name src/platform.h Updated on 2022-04-11 at 15:27:23 +0000","title":"Files"},{"location":"Files/dir_99d0482cf009f9d97a0877749b817f19/","text":"src/gui Files Name src/gui/engine.h src/gui/film.h Updated on 2022-04-11 at 15:27:24 +0000","title":"src/gui"},{"location":"Files/dir_99d0482cf009f9d97a0877749b817f19/#srcgui","text":"","title":"src/gui"},{"location":"Files/dir_99d0482cf009f9d97a0877749b817f19/#files","text":"Name src/gui/engine.h src/gui/film.h Updated on 2022-04-11 at 15:27:24 +0000","title":"Files"},{"location":"Files/dir_a0ac0340ed7c73c764f7b19b1e0fdeee/","text":"src/imageio Files Name src/imageio/fwd.h src/imageio/imageio.h Updated on 2022-04-11 at 15:27:24 +0000","title":"src/imageio"},{"location":"Files/dir_a0ac0340ed7c73c764f7b19b1e0fdeee/#srcimageio","text":"","title":"src/imageio"},{"location":"Files/dir_a0ac0340ed7c73c764f7b19b1e0fdeee/#files","text":"Name src/imageio/fwd.h src/imageio/imageio.h Updated on 2022-04-11 at 15:27:24 +0000","title":"Files"},{"location":"Files/dir_aebb8dcc11953d78e620bbef0b9e2183/","text":"src/core Files Name src/core/api.h this must be include only once in source src/core/blocked_array.h src/core/bounds.h src/core/class.h src/core/film.h src/core/filter.h src/core/fwd.h src/core/interaction.h src/core/logger.h src/core/memory.h src/core/mipmap.h src/core/object.h src/core/property.h src/core/ray.h src/core/relative.h src/core/serialization.h src/core/shape.h src/core/spectrum.h src/core/stream.h src/core/texture.h src/core/transform.h src/core/vector.h src/core/vector_base.h Updated on 2022-04-11 at 15:27:23 +0000","title":"src/core"},{"location":"Files/dir_aebb8dcc11953d78e620bbef0b9e2183/#srccore","text":"","title":"src/core"},{"location":"Files/dir_aebb8dcc11953d78e620bbef0b9e2183/#files","text":"Name src/core/api.h this must be include only once in source src/core/blocked_array.h src/core/bounds.h src/core/class.h src/core/film.h src/core/filter.h src/core/fwd.h src/core/interaction.h src/core/logger.h src/core/memory.h src/core/mipmap.h src/core/object.h src/core/property.h src/core/ray.h src/core/relative.h src/core/serialization.h src/core/shape.h src/core/spectrum.h src/core/stream.h src/core/texture.h src/core/transform.h src/core/vector.h src/core/vector_base.h Updated on 2022-04-11 at 15:27:23 +0000","title":"Files"},{"location":"Files/engine_8h/","text":"src/gui/engine.h Namespaces Name dakku dakku namespace Classes Name class dakku::GuiEngine Source code #ifndef DAKKU_GUI_ENGINE_H_ #define DAKKU_GUI_ENGINE_H_ #include <QQmlApplicationEngine> #include <gui/film.h> #include <thread> #include <chrono> namespace dakku { class GuiEngine : public QQmlApplicationEngine { Q_OBJECT public : GuiEngine (); [[ nodiscard ]] FilmImageProvider * getProvider () const ; public Q_SLOTS : void updateFilmImage ( int id ); private : FilmImageProvider * filmImageProvider {}; }; } // namespace dakku #endif Updated on 2022-04-11 at 15:27:24 +0000","title":"src/gui/engine.h"},{"location":"Files/engine_8h/#srcguiengineh","text":"","title":"src/gui/engine.h"},{"location":"Files/engine_8h/#namespaces","text":"Name dakku dakku namespace","title":"Namespaces"},{"location":"Files/engine_8h/#classes","text":"Name class dakku::GuiEngine","title":"Classes"},{"location":"Files/engine_8h/#source-code","text":"#ifndef DAKKU_GUI_ENGINE_H_ #define DAKKU_GUI_ENGINE_H_ #include <QQmlApplicationEngine> #include <gui/film.h> #include <thread> #include <chrono> namespace dakku { class GuiEngine : public QQmlApplicationEngine { Q_OBJECT public : GuiEngine (); [[ nodiscard ]] FilmImageProvider * getProvider () const ; public Q_SLOTS : void updateFilmImage ( int id ); private : FilmImageProvider * filmImageProvider {}; }; } // namespace dakku #endif Updated on 2022-04-11 at 15:27:24 +0000","title":"Source code"},{"location":"Files/filter_8h/","text":"src/core/filter.h Namespaces Name dakku dakku namespace Classes Name class dakku::Filter filter class all filters are centered at origin \\((0, 0)\\) and defined a radius beyond which they have a value of \\(0\\) this width may be different in the \\(x\\) and \\(y\\) directions Source code #ifndef DAKKU_CORE_FILTER_H_ #define DAKKU_CORE_FILTER_H_ #include <core/object.h> namespace dakku { class DAKKU_EXPORT_CORE Filter : public Object { public : DAKKU_DECLARE_OBJECT ( Filter , Object ); explicit Filter ( const Vector2f & radius ); [[ nodiscard ]] virtual float evaluate ( const Point2f & p ) const = 0 ; #if defined(_MSC_VER) #pragma warning(push) #pragma warning(disable : 4251) #endif const Vector2f radius ; const Vector2f invRadius ; #if defined(_MSC_VER) #pragma warning(pop) #endif }; } // namespace dakku #endif Updated on 2022-04-11 at 15:27:24 +0000","title":"src/core/filter.h"},{"location":"Files/filter_8h/#srccorefilterh","text":"","title":"src/core/filter.h"},{"location":"Files/filter_8h/#namespaces","text":"Name dakku dakku namespace","title":"Namespaces"},{"location":"Files/filter_8h/#classes","text":"Name class dakku::Filter filter class all filters are centered at origin \\((0, 0)\\) and defined a radius beyond which they have a value of \\(0\\) this width may be different in the \\(x\\) and \\(y\\) directions","title":"Classes"},{"location":"Files/filter_8h/#source-code","text":"#ifndef DAKKU_CORE_FILTER_H_ #define DAKKU_CORE_FILTER_H_ #include <core/object.h> namespace dakku { class DAKKU_EXPORT_CORE Filter : public Object { public : DAKKU_DECLARE_OBJECT ( Filter , Object ); explicit Filter ( const Vector2f & radius ); [[ nodiscard ]] virtual float evaluate ( const Point2f & p ) const = 0 ; #if defined(_MSC_VER) #pragma warning(push) #pragma warning(disable : 4251) #endif const Vector2f radius ; const Vector2f invRadius ; #if defined(_MSC_VER) #pragma warning(pop) #endif }; } // namespace dakku #endif Updated on 2022-04-11 at 15:27:24 +0000","title":"Source code"},{"location":"Files/filters_2api_8h/","text":"src/filters/api.h Namespaces Name dakku dakku namespace Source code #ifndef DAKKU_FILTERS_API_H_ #define DAKKU_FILTERS_API_H_ #include <filters/box.h> #include <filters/triangle.h> namespace dakku { DAKKU_EXPORT_OBJECTS ( Filters , BoxFilter , TriangleFilter ); } #endif Updated on 2022-04-11 at 15:27:24 +0000","title":"src/filters/api.h"},{"location":"Files/filters_2api_8h/#srcfiltersapih","text":"","title":"src/filters/api.h"},{"location":"Files/filters_2api_8h/#namespaces","text":"Name dakku dakku namespace","title":"Namespaces"},{"location":"Files/filters_2api_8h/#source-code","text":"#ifndef DAKKU_FILTERS_API_H_ #define DAKKU_FILTERS_API_H_ #include <filters/box.h> #include <filters/triangle.h> namespace dakku { DAKKU_EXPORT_OBJECTS ( Filters , BoxFilter , TriangleFilter ); } #endif Updated on 2022-04-11 at 15:27:24 +0000","title":"Source code"},{"location":"Files/filters_2fwd_8h/","text":"src/filters/fwd.h Namespaces Name dakku dakku namespace Defines Name DAKKU_EXPORT_FILTERS Macros Documentation define DAKKU_EXPORT_FILTERS #define DAKKU_EXPORT_FILTERS DAKKU_EXPORT Source code #ifndef DAKKU_FILTERS_FWD_H_ #define DAKKU_FILTERS_FWD_H_ #include <core/serialization.h> namespace dakku { #if DAKKU_BUILD_MODULE != DAKKU_FILTERS_MODULE #define DAKKU_EXPORT_FILTERS DAKKU_IMPORT #else #define DAKKU_EXPORT_FILTERS DAKKU_EXPORT #endif } // namespace dakku #endif Updated on 2022-04-11 at 15:27:24 +0000","title":"src/filters/fwd.h"},{"location":"Files/filters_2fwd_8h/#srcfiltersfwdh","text":"","title":"src/filters/fwd.h"},{"location":"Files/filters_2fwd_8h/#namespaces","text":"Name dakku dakku namespace","title":"Namespaces"},{"location":"Files/filters_2fwd_8h/#defines","text":"Name DAKKU_EXPORT_FILTERS","title":"Defines"},{"location":"Files/filters_2fwd_8h/#macros-documentation","text":"","title":"Macros Documentation"},{"location":"Files/filters_2fwd_8h/#define-dakku_export_filters","text":"#define DAKKU_EXPORT_FILTERS DAKKU_EXPORT","title":"define DAKKU_EXPORT_FILTERS"},{"location":"Files/filters_2fwd_8h/#source-code","text":"#ifndef DAKKU_FILTERS_FWD_H_ #define DAKKU_FILTERS_FWD_H_ #include <core/serialization.h> namespace dakku { #if DAKKU_BUILD_MODULE != DAKKU_FILTERS_MODULE #define DAKKU_EXPORT_FILTERS DAKKU_IMPORT #else #define DAKKU_EXPORT_FILTERS DAKKU_EXPORT #endif } // namespace dakku #endif Updated on 2022-04-11 at 15:27:24 +0000","title":"Source code"},{"location":"Files/fstream_8h/","text":"src/stream/fstream.h Namespaces Name dakku dakku namespace Classes Name class dakku::FileInputStream file input stream class dakku::FileOutputStream file output stream Source code #ifndef DAKKU_STREAM_FSTREAM_H_ #define DAKKU_STREAM_FSTREAM_H_ #include <stream/fwd.h> #include <filesystem> #include <fstream> namespace dakku { class DAKKU_EXPORT_STREAM FileInputStream : public InputStream { public : DAKKU_DECLARE_OBJECT ( FileInputStream , InputStream ); explicit FileInputStream ( const std :: filesystem :: path & path ); std :: uint8_t readByte () override ; size_t readBytes ( void * ptr , size_t size ) override ; protected : #if defined(_MSC_VER) #pragma warning(push) #pragma warning(disable : 4251) #endif std :: ifstream stream ; #if defined(_MSC_VER) #pragma warning(pop) #endif }; class DAKKU_EXPORT_STREAM FileOutputStream : public OutputStream { public : DAKKU_DECLARE_OBJECT ( FileOutputStream , OutputStream ); explicit FileOutputStream ( const std :: filesystem :: path & path ); void writeByte ( std :: uint8_t value ) override ; size_t writeBytes ( const void * ptr , size_t size ) override ; protected : #if defined(_MSC_VER) #pragma warning(push) #pragma warning(disable : 4251) #endif std :: ofstream stream ; #if defined(_MSC_VER) #pragma warning(pop) #endif }; } // namespace dakku #endif Updated on 2022-04-11 at 15:27:24 +0000","title":"src/stream/fstream.h"},{"location":"Files/fstream_8h/#srcstreamfstreamh","text":"","title":"src/stream/fstream.h"},{"location":"Files/fstream_8h/#namespaces","text":"Name dakku dakku namespace","title":"Namespaces"},{"location":"Files/fstream_8h/#classes","text":"Name class dakku::FileInputStream file input stream class dakku::FileOutputStream file output stream","title":"Classes"},{"location":"Files/fstream_8h/#source-code","text":"#ifndef DAKKU_STREAM_FSTREAM_H_ #define DAKKU_STREAM_FSTREAM_H_ #include <stream/fwd.h> #include <filesystem> #include <fstream> namespace dakku { class DAKKU_EXPORT_STREAM FileInputStream : public InputStream { public : DAKKU_DECLARE_OBJECT ( FileInputStream , InputStream ); explicit FileInputStream ( const std :: filesystem :: path & path ); std :: uint8_t readByte () override ; size_t readBytes ( void * ptr , size_t size ) override ; protected : #if defined(_MSC_VER) #pragma warning(push) #pragma warning(disable : 4251) #endif std :: ifstream stream ; #if defined(_MSC_VER) #pragma warning(pop) #endif }; class DAKKU_EXPORT_STREAM FileOutputStream : public OutputStream { public : DAKKU_DECLARE_OBJECT ( FileOutputStream , OutputStream ); explicit FileOutputStream ( const std :: filesystem :: path & path ); void writeByte ( std :: uint8_t value ) override ; size_t writeBytes ( const void * ptr , size_t size ) override ; protected : #if defined(_MSC_VER) #pragma warning(push) #pragma warning(disable : 4251) #endif std :: ofstream stream ; #if defined(_MSC_VER) #pragma warning(pop) #endif }; } // namespace dakku #endif Updated on 2022-04-11 at 15:27:24 +0000","title":"Source code"},{"location":"Files/gui_2film_8h/","text":"src/gui/film.h Namespaces Name dakku dakku namespace Classes Name class dakku::FilmImageProvider Source code #ifndef DAKKU_GUI_FILM_H_ #define DAKKU_GUI_FILM_H_ #include <core/fwd.h> #include <QQuickImageProvider> #include <span> namespace dakku { class FilmImageProvider : public QQuickImageProvider { Q_OBJECT public : FilmImageProvider () : QQuickImageProvider ( QQuickImageProvider :: Pixmap ) {} QPixmap requestPixmap ( const QString & , QSize * size , const QSize & requestedSize ) override ; void setImage ( const Film & film ); void setImage ( std :: span < const float > data , int width , int height ); Q_SIGNALS : void updateGui ( int id ); private : QImage image ; QPixmap pixmap ; int width {}; int height {}; int currentIndex {}; }; } // namespace dakku #endif Updated on 2022-04-11 at 15:27:24 +0000","title":"src/gui/film.h"},{"location":"Files/gui_2film_8h/#srcguifilmh","text":"","title":"src/gui/film.h"},{"location":"Files/gui_2film_8h/#namespaces","text":"Name dakku dakku namespace","title":"Namespaces"},{"location":"Files/gui_2film_8h/#classes","text":"Name class dakku::FilmImageProvider","title":"Classes"},{"location":"Files/gui_2film_8h/#source-code","text":"#ifndef DAKKU_GUI_FILM_H_ #define DAKKU_GUI_FILM_H_ #include <core/fwd.h> #include <QQuickImageProvider> #include <span> namespace dakku { class FilmImageProvider : public QQuickImageProvider { Q_OBJECT public : FilmImageProvider () : QQuickImageProvider ( QQuickImageProvider :: Pixmap ) {} QPixmap requestPixmap ( const QString & , QSize * size , const QSize & requestedSize ) override ; void setImage ( const Film & film ); void setImage ( std :: span < const float > data , int width , int height ); Q_SIGNALS : void updateGui ( int id ); private : QImage image ; QPixmap pixmap ; int width {}; int height {}; int currentIndex {}; }; } // namespace dakku #endif Updated on 2022-04-11 at 15:27:24 +0000","title":"Source code"},{"location":"Files/image_8h/","text":"src/textures/image.h Namespaces Name dakku dakku namespace Classes Name class dakku::ImageTexture Source code #ifndef DAKKU_TEXTURES_IMAGE_H_ #define DAKKU_TEXTURES_IMAGE_H_ #include <textures/fwd.h> #include <core/mipmap.h> #include <filesystem> namespace dakku { class ImageTexture : public Texture { public : DAKKU_DECLARE_OBJECT ( ImageTexture , Texture ); explicit ImageTexture ( std :: unique_ptr < TextureMapping2D > m , const std :: filesystem :: path & fileName , bool doTrilinear , float maxAnisotropy , ImageWrapMode mode , float scale , bool gamma , bool floatType = false ); [[ nodiscard ]] Spectrum evaluate ( const SurfaceInteraction & si ) const override ; private : std :: unique_ptr < TextureMapping2D > mapping ; std :: variant < std :: unique_ptr < MipMap < float >> , std :: unique_ptr < MipMap < Spectrum >>> mipmap ; }; } // namespace dakku #endif Updated on 2022-04-11 at 15:27:24 +0000","title":"src/textures/image.h"},{"location":"Files/image_8h/#srctexturesimageh","text":"","title":"src/textures/image.h"},{"location":"Files/image_8h/#namespaces","text":"Name dakku dakku namespace","title":"Namespaces"},{"location":"Files/image_8h/#classes","text":"Name class dakku::ImageTexture","title":"Classes"},{"location":"Files/image_8h/#source-code","text":"#ifndef DAKKU_TEXTURES_IMAGE_H_ #define DAKKU_TEXTURES_IMAGE_H_ #include <textures/fwd.h> #include <core/mipmap.h> #include <filesystem> namespace dakku { class ImageTexture : public Texture { public : DAKKU_DECLARE_OBJECT ( ImageTexture , Texture ); explicit ImageTexture ( std :: unique_ptr < TextureMapping2D > m , const std :: filesystem :: path & fileName , bool doTrilinear , float maxAnisotropy , ImageWrapMode mode , float scale , bool gamma , bool floatType = false ); [[ nodiscard ]] Spectrum evaluate ( const SurfaceInteraction & si ) const override ; private : std :: unique_ptr < TextureMapping2D > mapping ; std :: variant < std :: unique_ptr < MipMap < float >> , std :: unique_ptr < MipMap < Spectrum >>> mipmap ; }; } // namespace dakku #endif Updated on 2022-04-11 at 15:27:24 +0000","title":"Source code"},{"location":"Files/imageio_2fwd_8h/","text":"src/imageio/fwd.h Namespaces Name dakku dakku namespace Defines Name DAKKU_EXPORT_IMAGEIO Macros Documentation define DAKKU_EXPORT_IMAGEIO #define DAKKU_EXPORT_IMAGEIO DAKKU_EXPORT Source code #ifndef DAKKU_IMAGEIO_FWD_H_ #define DAKKU_IMAGEIO_FWD_H_ #include <platform.h> #include <cmath> namespace dakku { #if DAKKU_BUILD_MODULE != DAKKU_IMAGEIO_MODULE #define DAKKU_EXPORT_IMAGEIO DAKKU_IMPORT #else #define DAKKU_EXPORT_IMAGEIO DAKKU_EXPORT #endif inline float gammaCorrect ( float value ) { if ( value <= 0.0031308f ) return 12.92f * value ; return 1.055f * std :: pow ( value , 1.0f / 2.4f ) - 0.055f ; } inline float inverseGammaCorrect ( float value ) { if ( value <= 0.04045f ) return value / 12.92f ; return std :: pow (( value + 0.055f ) / 1.055f , 2.4f ); } } // namespace dakku #endif Updated on 2022-04-11 at 15:27:24 +0000","title":"src/imageio/fwd.h"},{"location":"Files/imageio_2fwd_8h/#srcimageiofwdh","text":"","title":"src/imageio/fwd.h"},{"location":"Files/imageio_2fwd_8h/#namespaces","text":"Name dakku dakku namespace","title":"Namespaces"},{"location":"Files/imageio_2fwd_8h/#defines","text":"Name DAKKU_EXPORT_IMAGEIO","title":"Defines"},{"location":"Files/imageio_2fwd_8h/#macros-documentation","text":"","title":"Macros Documentation"},{"location":"Files/imageio_2fwd_8h/#define-dakku_export_imageio","text":"#define DAKKU_EXPORT_IMAGEIO DAKKU_EXPORT","title":"define DAKKU_EXPORT_IMAGEIO"},{"location":"Files/imageio_2fwd_8h/#source-code","text":"#ifndef DAKKU_IMAGEIO_FWD_H_ #define DAKKU_IMAGEIO_FWD_H_ #include <platform.h> #include <cmath> namespace dakku { #if DAKKU_BUILD_MODULE != DAKKU_IMAGEIO_MODULE #define DAKKU_EXPORT_IMAGEIO DAKKU_IMPORT #else #define DAKKU_EXPORT_IMAGEIO DAKKU_EXPORT #endif inline float gammaCorrect ( float value ) { if ( value <= 0.0031308f ) return 12.92f * value ; return 1.055f * std :: pow ( value , 1.0f / 2.4f ) - 0.055f ; } inline float inverseGammaCorrect ( float value ) { if ( value <= 0.04045f ) return value / 12.92f ; return std :: pow (( value + 0.055f ) / 1.055f , 2.4f ); } } // namespace dakku #endif Updated on 2022-04-11 at 15:27:24 +0000","title":"Source code"},{"location":"Files/imageio_8h/","text":"src/imageio/imageio.h Namespaces Name dakku dakku namespace Source code #ifndef DAKKU_IMAGEIO_IMAGEIO_H_ #define DAKKU_IMAGEIO_IMAGEIO_H_ #include <imageio/fwd.h> #include <filesystem> #include <memory> namespace dakku { DAKKU_EXPORT_IMAGEIO bool writeImage ( const std :: filesystem :: path & path , const float * rgb , int totalResX , int totalResY , int outBoundsMinX = 0 , int outBoundsMinY = 0 , int outBoundsMaxX = -1 , int outBoundsMaxY = -1 ); DAKKU_EXPORT_IMAGEIO float * readImage ( const std :: filesystem :: path & path , int & resX , int & resY , bool flipVertical = true , int gamma = -1 , float scale = 1 ); } // namespace dakku #endif Updated on 2022-04-11 at 15:27:24 +0000","title":"src/imageio/imageio.h"},{"location":"Files/imageio_8h/#srcimageioimageioh","text":"","title":"src/imageio/imageio.h"},{"location":"Files/imageio_8h/#namespaces","text":"Name dakku dakku namespace","title":"Namespaces"},{"location":"Files/imageio_8h/#source-code","text":"#ifndef DAKKU_IMAGEIO_IMAGEIO_H_ #define DAKKU_IMAGEIO_IMAGEIO_H_ #include <imageio/fwd.h> #include <filesystem> #include <memory> namespace dakku { DAKKU_EXPORT_IMAGEIO bool writeImage ( const std :: filesystem :: path & path , const float * rgb , int totalResX , int totalResY , int outBoundsMinX = 0 , int outBoundsMinY = 0 , int outBoundsMaxX = -1 , int outBoundsMaxY = -1 ); DAKKU_EXPORT_IMAGEIO float * readImage ( const std :: filesystem :: path & path , int & resX , int & resY , bool flipVertical = true , int gamma = -1 , float scale = 1 ); } // namespace dakku #endif Updated on 2022-04-11 at 15:27:24 +0000","title":"Source code"},{"location":"Files/interaction_8h/","text":"src/core/interaction.h Namespaces Name dakku dakku namespace Classes Name struct dakku::Interaction interaction class dakku::SurfaceInteraction surface interaction Source code #ifndef DAKKU_CORE_INTERACTION_H_ #define DAKKU_CORE_INTERACTION_H_ #include <core/vector.h> #include <core/ray.h> #include <utility> namespace dakku { struct Interaction { Interaction () = default ; Interaction ( Point3f p , const Vector3f & wo , Normal3f n ) : p ( std :: move ( p )), wo ( wo . normalized ()), n ( std :: move ( n )) {} [[ nodiscard ]] bool isSurfaceInteraction () const { return n != Normal3f {}; } [[ nodiscard ]] bool isMediumInteraction () const { return ! isSurfaceInteraction (); } [[ nodiscard ]] Ray spawnRay ( const Vector3f & d ) const { Point3f o = offsetRayOrigin ( p , n , d ); return Ray ( o , d , INF ); } [[ nodiscard ]] Ray spawnRayTo ( const Point3f & q ) const { Point3f origin = offsetRayOrigin ( p , n , q - p ); Vector3f d = q - p ; return Ray ( origin , d , 1 - SHADOW_EPS ); } [[ nodiscard ]] Ray spawnRayTo ( const Interaction & it ) const { Point3f origin = offsetRayOrigin ( p , n , it . p - p ); Point3f target = offsetRayOrigin ( it . p , it . n , origin - it . p ); Vector3f d = target - origin ; return Ray ( origin , d , 1 - SHADOW_EPS ); } Point3f p ; Vector3f wo ; Normal3f n ; }; class SurfaceInteraction : public Interaction { public : Point2f uv ; mutable float dudx = 0 , dvdx = 0 , dudy = 0 , dvdy = 0 ; }; } // namespace dakku #endif Updated on 2022-04-11 at 15:27:24 +0000","title":"src/core/interaction.h"},{"location":"Files/interaction_8h/#srccoreinteractionh","text":"","title":"src/core/interaction.h"},{"location":"Files/interaction_8h/#namespaces","text":"Name dakku dakku namespace","title":"Namespaces"},{"location":"Files/interaction_8h/#classes","text":"Name struct dakku::Interaction interaction class dakku::SurfaceInteraction surface interaction","title":"Classes"},{"location":"Files/interaction_8h/#source-code","text":"#ifndef DAKKU_CORE_INTERACTION_H_ #define DAKKU_CORE_INTERACTION_H_ #include <core/vector.h> #include <core/ray.h> #include <utility> namespace dakku { struct Interaction { Interaction () = default ; Interaction ( Point3f p , const Vector3f & wo , Normal3f n ) : p ( std :: move ( p )), wo ( wo . normalized ()), n ( std :: move ( n )) {} [[ nodiscard ]] bool isSurfaceInteraction () const { return n != Normal3f {}; } [[ nodiscard ]] bool isMediumInteraction () const { return ! isSurfaceInteraction (); } [[ nodiscard ]] Ray spawnRay ( const Vector3f & d ) const { Point3f o = offsetRayOrigin ( p , n , d ); return Ray ( o , d , INF ); } [[ nodiscard ]] Ray spawnRayTo ( const Point3f & q ) const { Point3f origin = offsetRayOrigin ( p , n , q - p ); Vector3f d = q - p ; return Ray ( origin , d , 1 - SHADOW_EPS ); } [[ nodiscard ]] Ray spawnRayTo ( const Interaction & it ) const { Point3f origin = offsetRayOrigin ( p , n , it . p - p ); Point3f target = offsetRayOrigin ( it . p , it . n , origin - it . p ); Vector3f d = target - origin ; return Ray ( origin , d , 1 - SHADOW_EPS ); } Point3f p ; Vector3f wo ; Normal3f n ; }; class SurfaceInteraction : public Interaction { public : Point2f uv ; mutable float dudx = 0 , dvdx = 0 , dudy = 0 , dvdy = 0 ; }; } // namespace dakku #endif Updated on 2022-04-11 at 15:27:24 +0000","title":"Source code"},{"location":"Files/logger_8h/","text":"src/core/logger.h Namespaces Name dakku dakku namespace Classes Name class dakku::Logger logger class Defines Name DAKKU_ERR (...) log error message DAKKU_INFO (...) log info message DAKKU_WARN (...) log warning message DAKKU_DEBUG (...) log debug message DAKKU_CHECK (...) check whether the condition val is true, if not log error messages Macros Documentation define DAKKU_ERR #define DAKKU_ERR( ... ) SPDLOG_LOGGER_CALL ( Logger :: get (). handle (), spdlog :: level :: err , __VA_ARGS__ ) log error message define DAKKU_INFO #define DAKKU_INFO( ... ) SPDLOG_LOGGER_CALL ( Logger :: get (). handle (), spdlog :: level :: info , __VA_ARGS__ ) log info message define DAKKU_WARN #define DAKKU_WARN( ... ) SPDLOG_LOGGER_CALL ( Logger :: get (). handle (), spdlog :: level :: warn , __VA_ARGS__ ) log warning message define DAKKU_DEBUG #define DAKKU_DEBUG( ... ) static_cast < void > ( 0 ) log debug message define DAKKU_CHECK #define DAKKU_CHECK( ... ) static_cast < void > ( 0 ) check whether the condition val is true, if not log error messages Source code #ifndef DAKKU_CORE_LOGGER_H_ #define DAKKU_CORE_LOGGER_H_ #include <core/fwd.h> #include <spdlog/spdlog.h> #include <spdlog/fmt/ostr.h> #include <cstdlib> namespace dakku { class DAKKU_EXPORT_CORE Logger { public : static const Logger & get (); [[ nodiscard ]] spdlog :: logger * handle () const { return _logger . get (); } private : explicit Logger ( std :: shared_ptr < spdlog :: logger > _logger ); #if defined(_MSC_VER) #pragma warning(push) #pragma warning(disable : 4251) #endif std :: shared_ptr < spdlog :: logger > _logger ; #if defined(_MSC_VER) #pragma warning(pop) #endif }; #define DAKKU_ERR(...) \\ SPDLOG_LOGGER_CALL(Logger::get().handle(), spdlog::level::err, __VA_ARGS__) #define DAKKU_INFO(...) \\ SPDLOG_LOGGER_CALL(Logger::get().handle(), spdlog::level::info, __VA_ARGS__) #define DAKKU_WARN(...) \\ SPDLOG_LOGGER_CALL(Logger::get().handle(), spdlog::level::warn, __VA_ARGS__) #ifdef DAKKU_BUILD_DEBUG #define DAKKU_DEBUG(...) \\ SPDLOG_LOGGER_CALL(Logger::get().handle(), spdlog::level::debug, __VA_ARGS__) #else #define DAKKU_DEBUG(...) static_cast<void>(0) #endif #ifdef DAKKU_BUILD_CHECK #define DAKKU_CHECK(val, ...) \\ do { \\ if (!(val)) { \\ DAKKU_ERR(__VA_ARGS__); \\ std::exit(-1); \\ } \\ } while (0) #else #define DAKKU_CHECK(...) static_cast<void>(0) #endif } // namespace dakku #endif Updated on 2022-04-11 at 15:27:24 +0000","title":"src/core/logger.h"},{"location":"Files/logger_8h/#srccoreloggerh","text":"","title":"src/core/logger.h"},{"location":"Files/logger_8h/#namespaces","text":"Name dakku dakku namespace","title":"Namespaces"},{"location":"Files/logger_8h/#classes","text":"Name class dakku::Logger logger class","title":"Classes"},{"location":"Files/logger_8h/#defines","text":"Name DAKKU_ERR (...) log error message DAKKU_INFO (...) log info message DAKKU_WARN (...) log warning message DAKKU_DEBUG (...) log debug message DAKKU_CHECK (...) check whether the condition val is true, if not log error messages","title":"Defines"},{"location":"Files/logger_8h/#macros-documentation","text":"","title":"Macros Documentation"},{"location":"Files/logger_8h/#define-dakku_err","text":"#define DAKKU_ERR( ... ) SPDLOG_LOGGER_CALL ( Logger :: get (). handle (), spdlog :: level :: err , __VA_ARGS__ ) log error message","title":"define DAKKU_ERR"},{"location":"Files/logger_8h/#define-dakku_info","text":"#define DAKKU_INFO( ... ) SPDLOG_LOGGER_CALL ( Logger :: get (). handle (), spdlog :: level :: info , __VA_ARGS__ ) log info message","title":"define DAKKU_INFO"},{"location":"Files/logger_8h/#define-dakku_warn","text":"#define DAKKU_WARN( ... ) SPDLOG_LOGGER_CALL ( Logger :: get (). handle (), spdlog :: level :: warn , __VA_ARGS__ ) log warning message","title":"define DAKKU_WARN"},{"location":"Files/logger_8h/#define-dakku_debug","text":"#define DAKKU_DEBUG( ... ) static_cast < void > ( 0 ) log debug message","title":"define DAKKU_DEBUG"},{"location":"Files/logger_8h/#define-dakku_check","text":"#define DAKKU_CHECK( ... ) static_cast < void > ( 0 ) check whether the condition val is true, if not log error messages","title":"define DAKKU_CHECK"},{"location":"Files/logger_8h/#source-code","text":"#ifndef DAKKU_CORE_LOGGER_H_ #define DAKKU_CORE_LOGGER_H_ #include <core/fwd.h> #include <spdlog/spdlog.h> #include <spdlog/fmt/ostr.h> #include <cstdlib> namespace dakku { class DAKKU_EXPORT_CORE Logger { public : static const Logger & get (); [[ nodiscard ]] spdlog :: logger * handle () const { return _logger . get (); } private : explicit Logger ( std :: shared_ptr < spdlog :: logger > _logger ); #if defined(_MSC_VER) #pragma warning(push) #pragma warning(disable : 4251) #endif std :: shared_ptr < spdlog :: logger > _logger ; #if defined(_MSC_VER) #pragma warning(pop) #endif }; #define DAKKU_ERR(...) \\ SPDLOG_LOGGER_CALL(Logger::get().handle(), spdlog::level::err, __VA_ARGS__) #define DAKKU_INFO(...) \\ SPDLOG_LOGGER_CALL(Logger::get().handle(), spdlog::level::info, __VA_ARGS__) #define DAKKU_WARN(...) \\ SPDLOG_LOGGER_CALL(Logger::get().handle(), spdlog::level::warn, __VA_ARGS__) #ifdef DAKKU_BUILD_DEBUG #define DAKKU_DEBUG(...) \\ SPDLOG_LOGGER_CALL(Logger::get().handle(), spdlog::level::debug, __VA_ARGS__) #else #define DAKKU_DEBUG(...) static_cast<void>(0) #endif #ifdef DAKKU_BUILD_CHECK #define DAKKU_CHECK(val, ...) \\ do { \\ if (!(val)) { \\ DAKKU_ERR(__VA_ARGS__); \\ std::exit(-1); \\ } \\ } while (0) #else #define DAKKU_CHECK(...) static_cast<void>(0) #endif } // namespace dakku #endif Updated on 2022-04-11 at 15:27:24 +0000","title":"Source code"},{"location":"Files/memory_8h/","text":"src/core/memory.h Namespaces Name dakku dakku namespace Classes Name class dakku::L1CacheLineAlignedResource memory resource that at least aligned with L1 cache line size class dakku::MemoryArena memory arena Defines Name DAKKU_ALLOCA (type, count) allocated memory from stack Macros Documentation define DAKKU_ALLOCA #define DAKKU_ALLOCA( type , count ) ( reinterpret_cast < type *> ( alloca (( count ) * sizeof ( type )))) allocated memory from stack Parameters : type type that needs to allocate count the number of [type]s Source code #ifndef DAKKU_CORE_MEMORY_H_ #define DAKKU_CORE_MEMORY_H_ #include <core/logger.h> #if __has_include(<malloc.h>) #include <malloc.h> #endif #if __has_include(<alloca.h>) #include <alloca.h> #endif #include <memory_resource> #include <oneapi/tbb.h> #include <oneapi/tbb/scalable_allocator.h> namespace dakku { #define DAKKU_ALLOCA(type, count) \\ (reinterpret_cast<type *>(alloca((count) * sizeof(type)))) class L1CacheLineAlignedResource : public std :: pmr :: memory_resource { public : explicit L1CacheLineAlignedResource ( std :: pmr :: memory_resource * upStream = std :: pmr :: get_default_resource ()) : upStream ( upStream ) {} void * do_allocate ( size_t bytes , size_t align ) override { DAKKU_DEBUG ( \"allocate pool of {} bytes\" , bytes ); return upStream -> allocate ( bytes , std :: max ( align , L1_CACHE_LINE_SIZE )); } void do_deallocate ( void * ptr , size_t bytes , size_t align ) override { DAKKU_DEBUG ( \"deallocate pool of {} bytes\" , bytes ); upStream -> deallocate ( ptr , bytes , std :: max ( align , L1_CACHE_LINE_SIZE )); } [[ nodiscard ]] bool do_is_equal ( const memory_resource & rhs ) const noexcept override { return this == & rhs ; } private : std :: pmr :: memory_resource * upStream ; }; class MemoryArena { public : explicit MemoryArena () = default ; explicit MemoryArena ( std :: pmr :: memory_resource * buffer ) : upStream ( buffer ), resource ( & upStream ) {} template < typename T , typename ... Args > T * allocObject ( Args && ... args ) { return std :: pmr :: polymorphic_allocator < T > { & resource }. template new_object < T > ( std :: forward < Args > ( args )...); } void release () { resource . release (); } private : oneapi :: tbb :: cache_aligned_resource upStream { oneapi :: tbb :: scalable_memory_resource ()}; std :: pmr :: unsynchronized_pool_resource resource { & upStream }; }; } // namespace dakku #endif Updated on 2022-04-11 at 15:27:24 +0000","title":"src/core/memory.h"},{"location":"Files/memory_8h/#srccorememoryh","text":"","title":"src/core/memory.h"},{"location":"Files/memory_8h/#namespaces","text":"Name dakku dakku namespace","title":"Namespaces"},{"location":"Files/memory_8h/#classes","text":"Name class dakku::L1CacheLineAlignedResource memory resource that at least aligned with L1 cache line size class dakku::MemoryArena memory arena","title":"Classes"},{"location":"Files/memory_8h/#defines","text":"Name DAKKU_ALLOCA (type, count) allocated memory from stack","title":"Defines"},{"location":"Files/memory_8h/#macros-documentation","text":"","title":"Macros Documentation"},{"location":"Files/memory_8h/#define-dakku_alloca","text":"#define DAKKU_ALLOCA( type , count ) ( reinterpret_cast < type *> ( alloca (( count ) * sizeof ( type )))) allocated memory from stack Parameters : type type that needs to allocate count the number of [type]s","title":"define DAKKU_ALLOCA"},{"location":"Files/memory_8h/#source-code","text":"#ifndef DAKKU_CORE_MEMORY_H_ #define DAKKU_CORE_MEMORY_H_ #include <core/logger.h> #if __has_include(<malloc.h>) #include <malloc.h> #endif #if __has_include(<alloca.h>) #include <alloca.h> #endif #include <memory_resource> #include <oneapi/tbb.h> #include <oneapi/tbb/scalable_allocator.h> namespace dakku { #define DAKKU_ALLOCA(type, count) \\ (reinterpret_cast<type *>(alloca((count) * sizeof(type)))) class L1CacheLineAlignedResource : public std :: pmr :: memory_resource { public : explicit L1CacheLineAlignedResource ( std :: pmr :: memory_resource * upStream = std :: pmr :: get_default_resource ()) : upStream ( upStream ) {} void * do_allocate ( size_t bytes , size_t align ) override { DAKKU_DEBUG ( \"allocate pool of {} bytes\" , bytes ); return upStream -> allocate ( bytes , std :: max ( align , L1_CACHE_LINE_SIZE )); } void do_deallocate ( void * ptr , size_t bytes , size_t align ) override { DAKKU_DEBUG ( \"deallocate pool of {} bytes\" , bytes ); upStream -> deallocate ( ptr , bytes , std :: max ( align , L1_CACHE_LINE_SIZE )); } [[ nodiscard ]] bool do_is_equal ( const memory_resource & rhs ) const noexcept override { return this == & rhs ; } private : std :: pmr :: memory_resource * upStream ; }; class MemoryArena { public : explicit MemoryArena () = default ; explicit MemoryArena ( std :: pmr :: memory_resource * buffer ) : upStream ( buffer ), resource ( & upStream ) {} template < typename T , typename ... Args > T * allocObject ( Args && ... args ) { return std :: pmr :: polymorphic_allocator < T > { & resource }. template new_object < T > ( std :: forward < Args > ( args )...); } void release () { resource . release (); } private : oneapi :: tbb :: cache_aligned_resource upStream { oneapi :: tbb :: scalable_memory_resource ()}; std :: pmr :: unsynchronized_pool_resource resource { & upStream }; }; } // namespace dakku #endif Updated on 2022-04-11 at 15:27:24 +0000","title":"Source code"},{"location":"Files/mipmap_8h/","text":"src/core/mipmap.h Namespaces Name dakku dakku namespace Classes Name struct dakku::ResampleWeight resample weight of the four nearby (continuous) texels class dakku::MipMap mipmap class Source code #ifndef DAKKU_CORE_MIPMAP_H_ #define DAKKU_CORE_MIPMAP_H_ #include <core/blocked_array.h> #include <core/vector.h> #include <core/spectrum.h> #include <oneapi/tbb.h> #include <utility> namespace dakku { enum class ImageWrapMode { REPEAT , BLACK , CLAMP }; struct ResampleWeight { int firstTexel ; float weight [ 4 ]; }; template < typename T > requires ( std :: is_same_v < T , float > || std :: is_same_v < T , Spectrum > ) class MipMap { public : explicit MipMap ( Point2i resolution , std :: span < const T > data , bool doTrilinear = true , float maxAnisotropy = 8.0f , ImageWrapMode wrapMode = ImageWrapMode :: REPEAT ); [[ nodiscard ]] int width () const { return resolution . x (); } [[ nodiscard ]] int height () const { return resolution . y (); } [[ nodiscard ]] int levels () const { return static_cast < int > ( pyramid . size ()); } const T & texel ( int level , int s , int t ) const ; T lookup ( const Point2f & st , float width ) const ; T lookup ( const Point2f & st , Vector2f dst0 , Vector2f dst1 ) const ; private : const bool doTrilinear ; const float maxAnisotropy ; const ImageWrapMode wrapMode ; Point2i resolution ; std :: vector < std :: unique_ptr < BlockedArray < T >>> pyramid ; std :: unique_ptr < ResampleWeight [] > resampleWeights ( int oldRes , int newRes ) { DAKKU_CHECK ( newRes >= oldRes , \"invalid new resolution, expected: {} >= {}\" , newRes , oldRes ); std :: unique_ptr < ResampleWeight [] > wt = std :: make_unique < ResampleWeight [] > ( newRes ); float filterWidth = 2.0f ; for ( int i = 0 ; i < newRes ; ++ i ) { float center = ( static_cast < float > ( i ) + 0.5f ) / static_cast < float > ( newRes ) * static_cast < float > ( oldRes ); wt [ i ]. firstTexel = static_cast < int > ( std :: floor (( center - filterWidth ) * 0.5f )); // nearby four texels for ( int j = 0 ; j < 4 ; ++ j ) { float pos = static_cast < float > ( wt [ i ]. firstTexel + j ) + 0.5f ; wt [ i ]. weight [ j ] = evalLanczos (( pos - center ) / filterWidth ); } // normalize filter weights for texel resampling float inv = 1 / ( wt [ i ]. weight [ 0 ] + wt [ i ]. weight [ 1 ] + wt [ i ]. weight [ 2 ] + wt [ i ]. weight [ 3 ]); for ( float & j : wt [ i ]. weight ) j *= inv ; } return wt ; } float clamp ( float v ) { return std :: clamp ( v , 0.0f , INF ); } T triangle ( int level , const Point2f & st ) const ; RgbSpectrum clamp ( const RgbSpectrum & v ) { return v . clamp (); } }; template < typename T > requires ( std :: is_same_v < T , float > || std :: is_same_v < T , Spectrum > ) MipMap < T >:: MipMap ( Point2i resolution , std :: span < const T > img , bool doTrilinear , float maxAnisotropy , ImageWrapMode wrapMode ) : resolution ( std :: move ( resolution )), doTrilinear ( doTrilinear ), maxAnisotropy ( maxAnisotropy ), wrapMode ( wrapMode ) { std :: unique_ptr < T [] > resampledImage {}; if ( ! isPowerOf2 ( resolution . x ()) || ! isPowerOf2 ( resolution . y ())) { // not power of 2, resample image to the with the size to the nearest 2 ^ k Point2i resPow2 ( roundUpPow2 ( resolution . x ()), roundUpPow2 ( resolution . y ())); DAKKU_INFO ( \"resampling mipmap from {} to {}\" , resolution , resPow2 ); std :: unique_ptr < ResampleWeight [] > sWeights = resampleWeights ( resolution . x (), resPow2 . x ()); resampledImage = std :: make_unique < T [] > ( resPow2 . x () * resPow2 . y ()); // apply sWeights to zoom in $s$ direction oneapi :: tbb :: parallel_for ( size_t { 0 }, static_cast < size_t > ( resolution . y ()), [ & ]( size_t t ) { size_t end = resPow2 . x (); for ( size_t s = 0 ; s < end ; ++ s ) { // compute texel $(s, t)$ in $s$-zoomed image resampledImage [ t * resPow2 [ 0 ] + s ] = 0.f ; for ( int j = 0 ; j < 4 ; ++ j ) { int origS = sWeights [ s ]. firstTexel + j ; if ( wrapMode == ImageWrapMode :: REPEAT ) { origS = origS % resolution [ 0 ]; } else if ( wrapMode == ImageWrapMode :: CLAMP ) { origS = std :: clamp ( origS , 0 , resolution [ 0 ] - 1 ); } if ( origS >= 0 && origS < ( int ) resolution [ 0 ]) { resampledImage [ t * resPow2 [ 0 ] + s ] += sWeights [ s ]. weight [ j ] * img [ t * resolution [ 0 ] + origS ]; } } } }); // resample image in $t$ direction std :: unique_ptr < ResampleWeight [] > tWeights = resampleWeights ( resolution . y (), resPow2 . y ()); std :: vector < T *> resampleBufs ; int nThreads = oneapi :: tbb :: this_task_arena :: max_concurrency (); for ( int i = 0 ; i < nThreads ; ++ i ) resampleBufs . push_back ( new T [ resPow2 [ 1 ]]); oneapi :: tbb :: parallel_for ( size_t { 0 }, static_cast < size_t > ( resolution . x ()), [ & ]( size_t s ) { T * workData = resampleBufs [ oneapi :: tbb :: this_task_arena :: current_thread_index ()]; for ( int t = 0 ; t < resPow2 [ 1 ]; ++ t ) { workData [ t ] = 0.f ; for ( int j = 0 ; j < 4 ; ++ j ) { int offset = tWeights [ t ]. firstTexel + j ; if ( wrapMode == ImageWrapMode :: REPEAT ) { offset = offset % resolution [ 1 ]; } else if ( wrapMode == ImageWrapMode :: CLAMP ) { offset = std :: clamp ( offset , 0 , resolution [ 1 ] - 1 ); } if ( offset >= 0 && offset < resolution [ 1 ]) { workData [ t ] += tWeights [ t ]. weight [ j ] * resampledImage [ offset * resPow2 [ 0 ] + s ]; } } } for ( int t = 0 ; t < resPow2 [ 1 ]; ++ t ) resampledImage [ t * resPow2 [ 0 ] + s ] = clamp ( workData [ t ]); }); for ( auto ptr : resampleBufs ) delete [] ptr ; resolution = resPow2 ; } // initialize levels of mipmap from image int nLevels = 1 + log2Int ( std :: max ( resolution [ 0 ], resolution [ 1 ])); pyramid . resize ( nLevels ); // initialize the bottom level (most detailed) pyramid [ 0 ] = std :: make_unique < BlockedArray < T >> ( resolution [ 0 ], resolution [ 1 ], std :: span < const T > { resampledImage ? resampledImage . get () : img . data (), static_cast < size_t > ( resolution . x () * resolution . y ())}); for ( int i = 1 ; i < nLevels ; ++ i ) { // next level: / 2 int sRes = std :: max ( 1 , pyramid [ i - 1 ] -> uSize () / 2 ); int tRes = std :: max ( 1 , pyramid [ i - 1 ] -> vSize () / 2 ); pyramid [ i ] = std :: make_unique < BlockedArray < T >> ( sRes , tRes ); // filter four texels from finer level of pyramid oneapi :: tbb :: parallel_for ( 0 , tRes , [ & ]( int t ) { for ( int s = 0 ; s < sRes ; ++ s ) { ( * pyramid [ i ])( s , t ) = 0.25f * ( texel ( i - 1 , 2 * s , 2 * t ) + texel ( i - 1 , 2 * s + 1 , 2 * t ) + texel ( i - 1 , 2 * s , 2 * t + 1 ) + texel ( i - 1 , 2 * s + 1 , 2 * t + 1 )); } }); } // TODO: EWA } template < typename T > requires ( std :: is_same_v < T , float > || std :: is_same_v < T , Spectrum > ) const T & MipMap < T >:: texel ( int level , int s , int t ) const { DAKKU_CHECK ( level < pyramid . size (), \"level out of range: {} >= {}\" , level , pyramid . size ()); const BlockedArray < T > & l = * pyramid [ level ]; switch ( wrapMode ) { case ImageWrapMode :: REPEAT : s %= l . uSize (); t %= l . vSize (); break ; case ImageWrapMode :: CLAMP : s = std :: clamp ( s , 0 , l . uSize () - 1 ); t = std :: clamp ( t , 0 , l . vSize () - 1 ); break ; case ImageWrapMode :: BLACK : { static const T black { 0.0f }; if ( s < 0 || s >= l . uSize () || t < 0 || t >= l . vSize ()) return black ; break ; } } return l ( s , t ); } template < typename T > requires ( std :: is_same_v < T , float > || std :: is_same_v < T , Spectrum > ) T MipMap < T >:: lookup ( const Point2f & st , float width ) const { // compute mipmap level for trilinear filtering float level = levels () - 1 + std :: log2 ( std :: max ( width , 1e-8f )); if ( level < 0 ) { return triangle ( 0 , st ); } else if ( level >= levels () - 1 ) { return texel ( levels () - 1 , 0 , 0 ); } else { int floorLevel = static_cast < int > ( std :: floor ( level )); float delta = level - static_cast < float > ( floorLevel ); return lerp ( triangle ( floorLevel , st ), triangle ( floorLevel + 1 , st ), delta ); } } template < typename T > requires ( std :: is_same_v < T , float > || std :: is_same_v < T , Spectrum > ) T MipMap < T >:: triangle ( int level , const Point2f & st ) const { level = std :: clamp ( level , 0 , levels () - 1 ); float s = st [ 0 ] * pyramid [ level ] -> uSize () - 0.5f ; float t = st [ 1 ] * pyramid [ level ] -> vSize () - 0.5f ; int s0 = static_cast < int > ( std :: floor ( s )), t0 = static_cast < int > ( std :: floor ( t )); float ds = s - static_cast < float > ( s0 ), dt = t - static_cast < float > ( t0 ); return ( 1 - ds ) * ( 1 - dt ) * texel ( level , s0 , t0 ) + ( 1 - ds ) * dt * texel ( level , s0 , t0 + 1 ) + ds * ( 1 - dt ) * texel ( level , s0 + 1 , t0 ) + ds * dt * texel ( level , s0 + 1 , t0 + 1 ); } template < typename T > requires ( std :: is_same_v < T , float > || std :: is_same_v < T , Spectrum > ) T MipMap < T >:: lookup ( const Point2f & st , Vector2f dst0 , Vector2f dst1 ) const { if ( doTrilinear ) { float width = std :: max ( std :: max ( std :: abs ( dst0 [ 0 ]), std :: abs ( dst0 [ 1 ])), std :: max ( std :: abs ( dst1 [ 0 ]), std :: abs ( dst1 [ 1 ]))); return lookup ( st , width ); } DAKKU_ERR ( \"EWA unimplemented\" ); return T {}; } } // namespace dakku #endif Updated on 2022-04-11 at 15:27:24 +0000","title":"src/core/mipmap.h"},{"location":"Files/mipmap_8h/#srccoremipmaph","text":"","title":"src/core/mipmap.h"},{"location":"Files/mipmap_8h/#namespaces","text":"Name dakku dakku namespace","title":"Namespaces"},{"location":"Files/mipmap_8h/#classes","text":"Name struct dakku::ResampleWeight resample weight of the four nearby (continuous) texels class dakku::MipMap mipmap class","title":"Classes"},{"location":"Files/mipmap_8h/#source-code","text":"#ifndef DAKKU_CORE_MIPMAP_H_ #define DAKKU_CORE_MIPMAP_H_ #include <core/blocked_array.h> #include <core/vector.h> #include <core/spectrum.h> #include <oneapi/tbb.h> #include <utility> namespace dakku { enum class ImageWrapMode { REPEAT , BLACK , CLAMP }; struct ResampleWeight { int firstTexel ; float weight [ 4 ]; }; template < typename T > requires ( std :: is_same_v < T , float > || std :: is_same_v < T , Spectrum > ) class MipMap { public : explicit MipMap ( Point2i resolution , std :: span < const T > data , bool doTrilinear = true , float maxAnisotropy = 8.0f , ImageWrapMode wrapMode = ImageWrapMode :: REPEAT ); [[ nodiscard ]] int width () const { return resolution . x (); } [[ nodiscard ]] int height () const { return resolution . y (); } [[ nodiscard ]] int levels () const { return static_cast < int > ( pyramid . size ()); } const T & texel ( int level , int s , int t ) const ; T lookup ( const Point2f & st , float width ) const ; T lookup ( const Point2f & st , Vector2f dst0 , Vector2f dst1 ) const ; private : const bool doTrilinear ; const float maxAnisotropy ; const ImageWrapMode wrapMode ; Point2i resolution ; std :: vector < std :: unique_ptr < BlockedArray < T >>> pyramid ; std :: unique_ptr < ResampleWeight [] > resampleWeights ( int oldRes , int newRes ) { DAKKU_CHECK ( newRes >= oldRes , \"invalid new resolution, expected: {} >= {}\" , newRes , oldRes ); std :: unique_ptr < ResampleWeight [] > wt = std :: make_unique < ResampleWeight [] > ( newRes ); float filterWidth = 2.0f ; for ( int i = 0 ; i < newRes ; ++ i ) { float center = ( static_cast < float > ( i ) + 0.5f ) / static_cast < float > ( newRes ) * static_cast < float > ( oldRes ); wt [ i ]. firstTexel = static_cast < int > ( std :: floor (( center - filterWidth ) * 0.5f )); // nearby four texels for ( int j = 0 ; j < 4 ; ++ j ) { float pos = static_cast < float > ( wt [ i ]. firstTexel + j ) + 0.5f ; wt [ i ]. weight [ j ] = evalLanczos (( pos - center ) / filterWidth ); } // normalize filter weights for texel resampling float inv = 1 / ( wt [ i ]. weight [ 0 ] + wt [ i ]. weight [ 1 ] + wt [ i ]. weight [ 2 ] + wt [ i ]. weight [ 3 ]); for ( float & j : wt [ i ]. weight ) j *= inv ; } return wt ; } float clamp ( float v ) { return std :: clamp ( v , 0.0f , INF ); } T triangle ( int level , const Point2f & st ) const ; RgbSpectrum clamp ( const RgbSpectrum & v ) { return v . clamp (); } }; template < typename T > requires ( std :: is_same_v < T , float > || std :: is_same_v < T , Spectrum > ) MipMap < T >:: MipMap ( Point2i resolution , std :: span < const T > img , bool doTrilinear , float maxAnisotropy , ImageWrapMode wrapMode ) : resolution ( std :: move ( resolution )), doTrilinear ( doTrilinear ), maxAnisotropy ( maxAnisotropy ), wrapMode ( wrapMode ) { std :: unique_ptr < T [] > resampledImage {}; if ( ! isPowerOf2 ( resolution . x ()) || ! isPowerOf2 ( resolution . y ())) { // not power of 2, resample image to the with the size to the nearest 2 ^ k Point2i resPow2 ( roundUpPow2 ( resolution . x ()), roundUpPow2 ( resolution . y ())); DAKKU_INFO ( \"resampling mipmap from {} to {}\" , resolution , resPow2 ); std :: unique_ptr < ResampleWeight [] > sWeights = resampleWeights ( resolution . x (), resPow2 . x ()); resampledImage = std :: make_unique < T [] > ( resPow2 . x () * resPow2 . y ()); // apply sWeights to zoom in $s$ direction oneapi :: tbb :: parallel_for ( size_t { 0 }, static_cast < size_t > ( resolution . y ()), [ & ]( size_t t ) { size_t end = resPow2 . x (); for ( size_t s = 0 ; s < end ; ++ s ) { // compute texel $(s, t)$ in $s$-zoomed image resampledImage [ t * resPow2 [ 0 ] + s ] = 0.f ; for ( int j = 0 ; j < 4 ; ++ j ) { int origS = sWeights [ s ]. firstTexel + j ; if ( wrapMode == ImageWrapMode :: REPEAT ) { origS = origS % resolution [ 0 ]; } else if ( wrapMode == ImageWrapMode :: CLAMP ) { origS = std :: clamp ( origS , 0 , resolution [ 0 ] - 1 ); } if ( origS >= 0 && origS < ( int ) resolution [ 0 ]) { resampledImage [ t * resPow2 [ 0 ] + s ] += sWeights [ s ]. weight [ j ] * img [ t * resolution [ 0 ] + origS ]; } } } }); // resample image in $t$ direction std :: unique_ptr < ResampleWeight [] > tWeights = resampleWeights ( resolution . y (), resPow2 . y ()); std :: vector < T *> resampleBufs ; int nThreads = oneapi :: tbb :: this_task_arena :: max_concurrency (); for ( int i = 0 ; i < nThreads ; ++ i ) resampleBufs . push_back ( new T [ resPow2 [ 1 ]]); oneapi :: tbb :: parallel_for ( size_t { 0 }, static_cast < size_t > ( resolution . x ()), [ & ]( size_t s ) { T * workData = resampleBufs [ oneapi :: tbb :: this_task_arena :: current_thread_index ()]; for ( int t = 0 ; t < resPow2 [ 1 ]; ++ t ) { workData [ t ] = 0.f ; for ( int j = 0 ; j < 4 ; ++ j ) { int offset = tWeights [ t ]. firstTexel + j ; if ( wrapMode == ImageWrapMode :: REPEAT ) { offset = offset % resolution [ 1 ]; } else if ( wrapMode == ImageWrapMode :: CLAMP ) { offset = std :: clamp ( offset , 0 , resolution [ 1 ] - 1 ); } if ( offset >= 0 && offset < resolution [ 1 ]) { workData [ t ] += tWeights [ t ]. weight [ j ] * resampledImage [ offset * resPow2 [ 0 ] + s ]; } } } for ( int t = 0 ; t < resPow2 [ 1 ]; ++ t ) resampledImage [ t * resPow2 [ 0 ] + s ] = clamp ( workData [ t ]); }); for ( auto ptr : resampleBufs ) delete [] ptr ; resolution = resPow2 ; } // initialize levels of mipmap from image int nLevels = 1 + log2Int ( std :: max ( resolution [ 0 ], resolution [ 1 ])); pyramid . resize ( nLevels ); // initialize the bottom level (most detailed) pyramid [ 0 ] = std :: make_unique < BlockedArray < T >> ( resolution [ 0 ], resolution [ 1 ], std :: span < const T > { resampledImage ? resampledImage . get () : img . data (), static_cast < size_t > ( resolution . x () * resolution . y ())}); for ( int i = 1 ; i < nLevels ; ++ i ) { // next level: / 2 int sRes = std :: max ( 1 , pyramid [ i - 1 ] -> uSize () / 2 ); int tRes = std :: max ( 1 , pyramid [ i - 1 ] -> vSize () / 2 ); pyramid [ i ] = std :: make_unique < BlockedArray < T >> ( sRes , tRes ); // filter four texels from finer level of pyramid oneapi :: tbb :: parallel_for ( 0 , tRes , [ & ]( int t ) { for ( int s = 0 ; s < sRes ; ++ s ) { ( * pyramid [ i ])( s , t ) = 0.25f * ( texel ( i - 1 , 2 * s , 2 * t ) + texel ( i - 1 , 2 * s + 1 , 2 * t ) + texel ( i - 1 , 2 * s , 2 * t + 1 ) + texel ( i - 1 , 2 * s + 1 , 2 * t + 1 )); } }); } // TODO: EWA } template < typename T > requires ( std :: is_same_v < T , float > || std :: is_same_v < T , Spectrum > ) const T & MipMap < T >:: texel ( int level , int s , int t ) const { DAKKU_CHECK ( level < pyramid . size (), \"level out of range: {} >= {}\" , level , pyramid . size ()); const BlockedArray < T > & l = * pyramid [ level ]; switch ( wrapMode ) { case ImageWrapMode :: REPEAT : s %= l . uSize (); t %= l . vSize (); break ; case ImageWrapMode :: CLAMP : s = std :: clamp ( s , 0 , l . uSize () - 1 ); t = std :: clamp ( t , 0 , l . vSize () - 1 ); break ; case ImageWrapMode :: BLACK : { static const T black { 0.0f }; if ( s < 0 || s >= l . uSize () || t < 0 || t >= l . vSize ()) return black ; break ; } } return l ( s , t ); } template < typename T > requires ( std :: is_same_v < T , float > || std :: is_same_v < T , Spectrum > ) T MipMap < T >:: lookup ( const Point2f & st , float width ) const { // compute mipmap level for trilinear filtering float level = levels () - 1 + std :: log2 ( std :: max ( width , 1e-8f )); if ( level < 0 ) { return triangle ( 0 , st ); } else if ( level >= levels () - 1 ) { return texel ( levels () - 1 , 0 , 0 ); } else { int floorLevel = static_cast < int > ( std :: floor ( level )); float delta = level - static_cast < float > ( floorLevel ); return lerp ( triangle ( floorLevel , st ), triangle ( floorLevel + 1 , st ), delta ); } } template < typename T > requires ( std :: is_same_v < T , float > || std :: is_same_v < T , Spectrum > ) T MipMap < T >:: triangle ( int level , const Point2f & st ) const { level = std :: clamp ( level , 0 , levels () - 1 ); float s = st [ 0 ] * pyramid [ level ] -> uSize () - 0.5f ; float t = st [ 1 ] * pyramid [ level ] -> vSize () - 0.5f ; int s0 = static_cast < int > ( std :: floor ( s )), t0 = static_cast < int > ( std :: floor ( t )); float ds = s - static_cast < float > ( s0 ), dt = t - static_cast < float > ( t0 ); return ( 1 - ds ) * ( 1 - dt ) * texel ( level , s0 , t0 ) + ( 1 - ds ) * dt * texel ( level , s0 , t0 + 1 ) + ds * ( 1 - dt ) * texel ( level , s0 + 1 , t0 ) + ds * dt * texel ( level , s0 + 1 , t0 + 1 ); } template < typename T > requires ( std :: is_same_v < T , float > || std :: is_same_v < T , Spectrum > ) T MipMap < T >:: lookup ( const Point2f & st , Vector2f dst0 , Vector2f dst1 ) const { if ( doTrilinear ) { float width = std :: max ( std :: max ( std :: abs ( dst0 [ 0 ]), std :: abs ( dst0 [ 1 ])), std :: max ( std :: abs ( dst1 [ 0 ]), std :: abs ( dst1 [ 1 ]))); return lookup ( st , width ); } DAKKU_ERR ( \"EWA unimplemented\" ); return T {}; } } // namespace dakku #endif Updated on 2022-04-11 at 15:27:24 +0000","title":"Source code"},{"location":"Files/object_8h/","text":"src/core/object.h Namespaces Name dakku dakku namespace Classes Name class dakku::Object Object class, RTTI support. Defines Name DAKKU_DECLARE_OBJECT (name, parent) declare a dakku object DAKKU_EXPORT_OBJECTS (module, ...) Macros Documentation define DAKKU_DECLARE_OBJECT #define DAKKU_DECLARE_OBJECT( name , parent ) static std :: string getClassNameStatic () { return # name ; } \\ [[ nodiscard ]] std :: string getClassName () const override { \\ return getClassNameStatic (); \\ } \\ static std :: string getParentNameStatic () { return # parent ; } \\ [[ nodiscard ]] std :: string getParentName () const override { \\ return getParentNameStatic (); \\ } \\ explicit name ( const Property & = {}) declare a dakku object define DAKKU_EXPORT_OBJECTS #define DAKKU_EXPORT_OBJECTS( module , ... ) volatile int _export ## module ## ModuleObjects = [] { \\ registerObjects < __VA_ARGS__ > (); \\ return 0 ; \\ }() Source code #ifndef DAKKU_CORE_OBJECT_H_ #define DAKKU_CORE_OBJECT_H_ #include <core/class.h> namespace dakku { class DAKKU_EXPORT_CORE Object { public : virtual ~ Object () = default ; explicit Object ( const Property & = {}); [[ nodiscard ]] virtual std :: string getClassName () const ; [[ nodiscard ]] virtual std :: string getParentName () const ; [[ nodiscard ]] virtual std :: string toString () const ; [[ nodiscard ]] bool isDerivedFrom ( std :: string_view name ) const ; [[ nodiscard ]] bool isBaseOf ( std :: string_view name ) const ; static std :: string getClassNameStatic () { return \"Object\" ; } static std :: string getParentNameStatic () { return \"\" ; } }; #define DAKKU_DECLARE_OBJECT(name, parent) \\ static std::string getClassNameStatic() { return #name; } \\ [[nodiscard]] std::string getClassName() const override { \\ return getClassNameStatic(); \\ } \\ static std::string getParentNameStatic() { return #parent; } \\ [[nodiscard]] std::string getParentName() const override { \\ return getParentNameStatic(); \\ } \\ explicit name(const Property & = {}) template < typename ... Args > inline void registerObjects () { ( Class :: instance (). registerClass < Args > (), ...); } #define DAKKU_EXPORT_OBJECTS(module, ...) \\ volatile int _export##module##ModuleObjects = [] { \\ registerObjects<__VA_ARGS__>(); \\ return 0; \\ }() } // namespace dakku #endif Updated on 2022-04-11 at 15:27:24 +0000","title":"src/core/object.h"},{"location":"Files/object_8h/#srccoreobjecth","text":"","title":"src/core/object.h"},{"location":"Files/object_8h/#namespaces","text":"Name dakku dakku namespace","title":"Namespaces"},{"location":"Files/object_8h/#classes","text":"Name class dakku::Object Object class, RTTI support.","title":"Classes"},{"location":"Files/object_8h/#defines","text":"Name DAKKU_DECLARE_OBJECT (name, parent) declare a dakku object DAKKU_EXPORT_OBJECTS (module, ...)","title":"Defines"},{"location":"Files/object_8h/#macros-documentation","text":"","title":"Macros Documentation"},{"location":"Files/object_8h/#define-dakku_declare_object","text":"#define DAKKU_DECLARE_OBJECT( name , parent ) static std :: string getClassNameStatic () { return # name ; } \\ [[ nodiscard ]] std :: string getClassName () const override { \\ return getClassNameStatic (); \\ } \\ static std :: string getParentNameStatic () { return # parent ; } \\ [[ nodiscard ]] std :: string getParentName () const override { \\ return getParentNameStatic (); \\ } \\ explicit name ( const Property & = {}) declare a dakku object","title":"define DAKKU_DECLARE_OBJECT"},{"location":"Files/object_8h/#define-dakku_export_objects","text":"#define DAKKU_EXPORT_OBJECTS( module , ... ) volatile int _export ## module ## ModuleObjects = [] { \\ registerObjects < __VA_ARGS__ > (); \\ return 0 ; \\ }()","title":"define DAKKU_EXPORT_OBJECTS"},{"location":"Files/object_8h/#source-code","text":"#ifndef DAKKU_CORE_OBJECT_H_ #define DAKKU_CORE_OBJECT_H_ #include <core/class.h> namespace dakku { class DAKKU_EXPORT_CORE Object { public : virtual ~ Object () = default ; explicit Object ( const Property & = {}); [[ nodiscard ]] virtual std :: string getClassName () const ; [[ nodiscard ]] virtual std :: string getParentName () const ; [[ nodiscard ]] virtual std :: string toString () const ; [[ nodiscard ]] bool isDerivedFrom ( std :: string_view name ) const ; [[ nodiscard ]] bool isBaseOf ( std :: string_view name ) const ; static std :: string getClassNameStatic () { return \"Object\" ; } static std :: string getParentNameStatic () { return \"\" ; } }; #define DAKKU_DECLARE_OBJECT(name, parent) \\ static std::string getClassNameStatic() { return #name; } \\ [[nodiscard]] std::string getClassName() const override { \\ return getClassNameStatic(); \\ } \\ static std::string getParentNameStatic() { return #parent; } \\ [[nodiscard]] std::string getParentName() const override { \\ return getParentNameStatic(); \\ } \\ explicit name(const Property & = {}) template < typename ... Args > inline void registerObjects () { ( Class :: instance (). registerClass < Args > (), ...); } #define DAKKU_EXPORT_OBJECTS(module, ...) \\ volatile int _export##module##ModuleObjects = [] { \\ registerObjects<__VA_ARGS__>(); \\ return 0; \\ }() } // namespace dakku #endif Updated on 2022-04-11 at 15:27:24 +0000","title":"Source code"},{"location":"Files/platform_8h/","text":"src/platform.h Namespaces Name dakku dakku namespace Defines Name DAKKU_INLINE DAKKU_EXPORT DAKKU_IMPORT DAKKU_CORE_MODULE dakku core module DAKKU_STREAM_MODULE dakku stream module DAKKU_IMAGEIO_MODULE dakku imageio module DAKKU_FILTERS_MODULE dakku filters module DAKKU_TEXTURES_MODULE dakku textures module DAKKU_MAIN_MODULE dakku main module Macros Documentation define DAKKU_INLINE #define DAKKU_INLINE __attribute__((always_inline)) inline define DAKKU_EXPORT #define DAKKU_EXPORT __attribute__((visibility(\"default\"))) define DAKKU_IMPORT #define DAKKU_IMPORT define DAKKU_CORE_MODULE #define DAKKU_CORE_MODULE 1 dakku core module define DAKKU_STREAM_MODULE #define DAKKU_STREAM_MODULE 2 dakku stream module define DAKKU_IMAGEIO_MODULE #define DAKKU_IMAGEIO_MODULE 3 dakku imageio module define DAKKU_FILTERS_MODULE #define DAKKU_FILTERS_MODULE 4 dakku filters module define DAKKU_TEXTURES_MODULE #define DAKKU_TEXTURES_MODULE 5 dakku textures module define DAKKU_MAIN_MODULE #define DAKKU_MAIN_MODULE 10 dakku main module Source code #ifndef DAKKU_PLATFORM_H_ #define DAKKU_PLATFORM_H_ #if defined(_MSC_VER) #if !defined(_USE_MATH_DEFINES) &&!defined(M_PI) #define _USE_MATH_DEFINES #endif #endif namespace dakku { #if defined(_MSC_VER) #define DAKKU_INLINE __forceinline #define DAKKU_EXPORT __declspec(dllexport) #define DAKKU_IMPORT __declspec(dllimport) #else #define DAKKU_INLINE __attribute__((always_inline)) inline #define DAKKU_EXPORT __attribute__((visibility(\"default\"))) #define DAKKU_IMPORT #endif #define DAKKU_CORE_MODULE 1 #define DAKKU_STREAM_MODULE 2 #define DAKKU_IMAGEIO_MODULE 3 #define DAKKU_FILTERS_MODULE 4 #define DAKKU_TEXTURES_MODULE 5 #define DAKKU_MAIN_MODULE 10 } // namespace dakku #endif Updated on 2022-04-11 at 15:27:24 +0000","title":"src/platform.h"},{"location":"Files/platform_8h/#srcplatformh","text":"","title":"src/platform.h"},{"location":"Files/platform_8h/#namespaces","text":"Name dakku dakku namespace","title":"Namespaces"},{"location":"Files/platform_8h/#defines","text":"Name DAKKU_INLINE DAKKU_EXPORT DAKKU_IMPORT DAKKU_CORE_MODULE dakku core module DAKKU_STREAM_MODULE dakku stream module DAKKU_IMAGEIO_MODULE dakku imageio module DAKKU_FILTERS_MODULE dakku filters module DAKKU_TEXTURES_MODULE dakku textures module DAKKU_MAIN_MODULE dakku main module","title":"Defines"},{"location":"Files/platform_8h/#macros-documentation","text":"","title":"Macros Documentation"},{"location":"Files/platform_8h/#define-dakku_inline","text":"#define DAKKU_INLINE __attribute__((always_inline)) inline","title":"define DAKKU_INLINE"},{"location":"Files/platform_8h/#define-dakku_export","text":"#define DAKKU_EXPORT __attribute__((visibility(\"default\")))","title":"define DAKKU_EXPORT"},{"location":"Files/platform_8h/#define-dakku_import","text":"#define DAKKU_IMPORT","title":"define DAKKU_IMPORT"},{"location":"Files/platform_8h/#define-dakku_core_module","text":"#define DAKKU_CORE_MODULE 1 dakku core module","title":"define DAKKU_CORE_MODULE"},{"location":"Files/platform_8h/#define-dakku_stream_module","text":"#define DAKKU_STREAM_MODULE 2 dakku stream module","title":"define DAKKU_STREAM_MODULE"},{"location":"Files/platform_8h/#define-dakku_imageio_module","text":"#define DAKKU_IMAGEIO_MODULE 3 dakku imageio module","title":"define DAKKU_IMAGEIO_MODULE"},{"location":"Files/platform_8h/#define-dakku_filters_module","text":"#define DAKKU_FILTERS_MODULE 4 dakku filters module","title":"define DAKKU_FILTERS_MODULE"},{"location":"Files/platform_8h/#define-dakku_textures_module","text":"#define DAKKU_TEXTURES_MODULE 5 dakku textures module","title":"define DAKKU_TEXTURES_MODULE"},{"location":"Files/platform_8h/#define-dakku_main_module","text":"#define DAKKU_MAIN_MODULE 10 dakku main module","title":"define DAKKU_MAIN_MODULE"},{"location":"Files/platform_8h/#source-code","text":"#ifndef DAKKU_PLATFORM_H_ #define DAKKU_PLATFORM_H_ #if defined(_MSC_VER) #if !defined(_USE_MATH_DEFINES) &&!defined(M_PI) #define _USE_MATH_DEFINES #endif #endif namespace dakku { #if defined(_MSC_VER) #define DAKKU_INLINE __forceinline #define DAKKU_EXPORT __declspec(dllexport) #define DAKKU_IMPORT __declspec(dllimport) #else #define DAKKU_INLINE __attribute__((always_inline)) inline #define DAKKU_EXPORT __attribute__((visibility(\"default\"))) #define DAKKU_IMPORT #endif #define DAKKU_CORE_MODULE 1 #define DAKKU_STREAM_MODULE 2 #define DAKKU_IMAGEIO_MODULE 3 #define DAKKU_FILTERS_MODULE 4 #define DAKKU_TEXTURES_MODULE 5 #define DAKKU_MAIN_MODULE 10 } // namespace dakku #endif Updated on 2022-04-11 at 15:27:24 +0000","title":"Source code"},{"location":"Files/property_8h/","text":"src/core/property.h Namespaces Name dakku dakku namespace Classes Name class dakku::Property property class, containing many data types, similar to json Source code #ifndef DAKKU_CORE_PROPERTY_H_ #define DAKKU_CORE_PROPERTY_H_ #include <core/vector.h> #include <core/transform.h> #include <nlohmann/json.hpp> #include <map> #include <string> #include <variant> namespace dakku { enum class PropertyType { NONE , ARRAY , OBJECT , NUMBER , STRING , VECTOR , TRANSFORM }; class DAKKU_EXPORT_CORE Property { public : using ObjectType = std :: map < std :: string , Property , std :: less <>> ; using ArrayType = std :: vector < Property > ; using NumberType = float ; using VectorType = std :: vector < float > ; using StringType = std :: string ; using TransformType = Transform ; Property () = default ; template < ArithmeticType T > Property ( const T & v ) : data ( static_cast < float > ( v )), type ( PropertyType :: NUMBER ) {} Property ( const std :: string & s ) : data ( s ), type ( PropertyType :: STRING ) {} template < ArithmeticType T , size_t S , typename D > Property ( const VectorBase < T , S , D > & v ) : data ( v . toFloatVector ()), type ( PropertyType :: VECTOR ) {} Property ( const std :: vector < float > & v ) { if ( v . size () <= 3 ) { data = v ; type = PropertyType :: VECTOR ; } else if ( v . size () == 16 ) { data = Transform { v }; type = PropertyType :: TRANSFORM ; } else { std :: vector < Property > tmp ; tmp . reserve ( v . size ()); for ( float i : v ) tmp . emplace_back ( i ); data = std :: move ( tmp ); type = PropertyType :: ARRAY ; } } Property ( const Transform & t ) : data ( t ), type ( PropertyType :: TRANSFORM ) {} [[ nodiscard ]] decltype ( auto ) getPropertyType () const { return type ; } template < PropertyType type > [[ nodiscard ]] decltype ( auto ) get () { auto & ret = static_cast < const Property &> ( * this ). get < type > (); return const_cast < std :: add_lvalue_reference_t < std :: decay_t < decltype ( ret ) >>> ( ret ); } template < PropertyType type , bool required = false > [[ nodiscard ]] decltype ( auto ) get () const { if constexpr ( type == PropertyType :: OBJECT ) { return std :: get < ObjectType > ( data ); } else if constexpr ( type == PropertyType :: ARRAY ) { return std :: get < ArrayType > ( data ); } else if constexpr ( type == PropertyType :: NUMBER ) { return std :: get < NumberType > ( data ); } else if constexpr ( type == PropertyType :: STRING ) { return std :: get < StringType > ( data ); } else if constexpr ( type == PropertyType :: VECTOR ) { return std :: get < VectorType > ( data ); } else if constexpr ( type == PropertyType :: TRANSFORM ) { return std :: get < TransformType > ( data ); } else { if constexpr ( type == PropertyType :: NONE ) { DAKKU_WARN ( \"none property type\" ); } else { DAKKU_WARN ( \"invalid property type: {}\" , type ); } return std :: get < std :: nullptr_t > ( data ); } } [[ nodiscard ]] decltype ( auto ) getObject () { return get < PropertyType :: OBJECT > (); } [[ nodiscard ]] decltype ( auto ) getObject () const { return get < PropertyType :: OBJECT > (); } [[ nodiscard ]] decltype ( auto ) getArray () { return get < PropertyType :: ARRAY > (); } [[ nodiscard ]] decltype ( auto ) getArray () const { return get < PropertyType :: ARRAY > (); } [[ nodiscard ]] decltype ( auto ) getNumber () { return get < PropertyType :: NUMBER > (); } [[ nodiscard ]] decltype ( auto ) getNumber () const { return get < PropertyType :: NUMBER > (); } [[ nodiscard ]] decltype ( auto ) getString () { return get < PropertyType :: STRING > (); } [[ nodiscard ]] decltype ( auto ) getString () const { return get < PropertyType :: STRING > (); } [[ nodiscard ]] decltype ( auto ) getVector () { return get < PropertyType :: VECTOR > (); } [[ nodiscard ]] decltype ( auto ) getVector () const { return get < PropertyType :: VECTOR > (); } [[ nodiscard ]] decltype ( auto ) getTransform () { return get < PropertyType :: TRANSFORM > (); } [[ nodiscard ]] decltype ( auto ) getTransform () const { return get < PropertyType :: TRANSFORM > (); } [[ nodiscard ]] bool isObjectType () const { return type == PropertyType :: OBJECT ; } [[ nodiscard ]] bool isArrayType () const { return type == PropertyType :: ARRAY ; } [[ nodiscard ]] bool isNumberType () const { return type == PropertyType :: NUMBER ; } [[ nodiscard ]] bool isStringType () const { return type == PropertyType :: STRING ; } [[ nodiscard ]] bool isVectorType () const { return type == PropertyType :: VECTOR ; } [[ nodiscard ]] bool isTransformType () const { return type == PropertyType :: TRANSFORM ; } decltype ( auto ) operator []( const std :: string & key ) { if ( type == PropertyType :: NONE ) { data = ObjectType {}; type = PropertyType :: OBJECT ; } DAKKU_CHECK ( isObjectType (), \"looking up {} in a non-object property\" , key ); return getObject ()[ key ]; } decltype ( auto ) operator []( const std :: string & key ) const { if ( ! isObjectType ()) { DAKKU_ERR ( \"try to access {} in a non-object type property\" , key ); std :: exit ( -1 ); } if ( auto it = getObject (). find ( key ); it != getObject (). end ()) { return it -> second ; } else { DAKKU_ERR ( \"cannot find the request key: {}\" , key ); std :: exit ( -1 ); } } decltype ( auto ) operator []( size_t i ) { if ( type == PropertyType :: NONE ) { data = ArrayType {}; type = PropertyType :: ARRAY ; getArray (). reserve (( i + 1 ) * 2 ); } DAKKU_CHECK ( isArrayType (), \"index {} in a non-array property\" , i ); auto & arr = getArray (); if ( i >= arr . size ()) { arr . reserve (( i + 1 ) * 2 ); arr . resize ( i + 1 ); } return getArray ()[ i ]; } decltype ( auto ) operator []( size_t i ) const { if ( type == PropertyType :: NONE ) { DAKKU_ERR ( \"try to index {} in a non-array type property\" , i ); std :: exit ( -1 ); } if ( const auto & arr = getArray (); i < arr . size ()) { return arr [ i ]; } else { DAKKU_ERR ( \"index out of range: {} >= {}\" , i , arr . size ()); std :: exit ( -1 ); } } [[ nodiscard ]] std :: string toString () const ; friend std :: ostream & operator << ( std :: ostream & os , const Property & property ) { return os << property . toString (); } friend void to_json ( nlohmann :: json & j , const Property & p ) { switch ( p . type ) { case PropertyType :: OBJECT : { for ( const auto & [ k , v ] : p . getObject ()) { to_json ( j [ k ], v ); } break ; } case PropertyType :: ARRAY : { j = nlohmann :: json :: array (); for ( const auto & v : p . getArray ()) { j . push_back ( nlohmann :: json {}); to_json ( j . back (), v ); } break ; } case PropertyType :: NUMBER : { j = p . getNumber (); break ; } case PropertyType :: STRING : { j = p . getString (); break ; } case PropertyType :: VECTOR : { j = p . getVector (); break ; } case PropertyType :: TRANSFORM : { j = p . getTransform (). getMatrix (). toFloatVector (); break ; } case PropertyType :: NONE : { DAKKU_ERR ( \"none property type\" ); break ; } default : { DAKKU_ERR ( \"invalid property type: {}\" , p . type ); break ; } } } friend void from_json ( const nlohmann :: json & j , Property & p ) { if ( j . is_object ()) { for ( auto it = j . begin (); it != j . end (); ++ it ) from_json ( * it , p [ it . key ()]); } else if ( j . is_array ()) { auto isFloatVector = [ & ] { for ( const auto & v : j ) if ( ! v . is_number ()) return false ; return true ; }; if ( isFloatVector ()) { VectorType tmp ; j . get_to ( tmp ); p = tmp ; } else { for ( size_t i = 0 ; i < j . size (); ++ i ) from_json ( j [ i ], p [ i ]); } } else if ( j . is_number ()) { p = j . get < float > (); } else if ( j . is_string ()) { p = j . get < std :: string > (); } else if ( j . is_boolean ()) { p = static_cast < float > ( j . get < bool > ()); } else { DAKKU_ERR ( \"unknown type in json: {}\" , j . type_name ()); std :: exit ( -1 ); } } [[ nodiscard ]] Transform mergeTransform () const { // already a transform Transform ret ; if ( isTransformType ()) return ret ; if ( isArrayType ()) { auto & arr = getArray (); for ( const auto & v : arr ) { if ( ! v . isTransformType ()) { if ( v . isObjectType ()) { std :: string transType ; if ( auto it = v . getObject (). find ( \"type\" ); it != v . getObject (). end () && it -> second . isStringType ()) { transType = it -> second . getString (); } else { DAKKU_ERR ( \"cannot merge transforms for: {}\" , * this ); } if ( transType == \"lookat\" ) { Point3f pos = v [ \"pos\" ]. getVector (); Point3f look = v [ \"look\" ]. getVector (); Vector3f refUp = v [ \"up\" ]. getVector (); ret = ret * lookAt ( pos , look , refUp ); } else if ( transType == \"rotate\" ) { float angle = v [ \"data\" ]. getNumber (); if ( v [ \"axis\" ]. isStringType ()) { std :: string axis = v [ \"axis\" ]. getString (); if ( axis == \"x\" ) { ret = ret * rotateX ( angle ); } else if ( axis == \"y\" ) { ret = ret * rotateY ( angle ); } else if ( axis == \"z\" ) { ret = ret * rotateZ ( angle ); } else { DAKKU_ERR ( \"invalid axis for rotation: {}\" , axis ); return ret ; } } else { Vector3f axis = v [ \"axis\" ]. getVector (); ret = ret * rotate ( angle , axis ); } } else if ( transType == \"translate\" ) { Vector3f delta = v [ \"data\" ]. getVector (); ret = ret * translate ( delta ); } else if ( transType == \"scale\" ) { Vector3f s = v [ \"data\" ]. getVector (); ret = ret * scale ( s . x (), s . y (), s . z ()); } else { DAKKU_ERR ( \"invalid transform type: {}\" , type ); return ret ; } } else { DAKKU_ERR ( \"cannot merge transforms for: {}\" , * this ); return ret ; } } } } else { DAKKU_ERR ( \"cannot merge transforms for: {}\" , * this ); } return ret ; } template < typename T > T getVectorIf ( std :: string_view key , const T & value ) const { if ( auto it = getObject (). find ( key ); it != getObject (). end ()) { return T { it -> second . getVector ()}; } else { return value ; } } template < ArithmeticType T = float > T getNumberIf ( std :: string_view key , const T & value ) const { if ( auto it = getObject (). find ( key ); it != getObject (). end ()) { return static_cast < T > ( it -> second . getNumber ()); } else { return value ; } } [[ nodiscard ]] std :: string getStringIf ( std :: string_view key , const std :: string & value ) const { if ( auto it = getObject (). find ( key ); it != getObject (). end ()) { return it -> second . getString (); } else { return value ; } } private : #if defined(_MSC_VER) #pragma warning(push) #pragma warning(disable : 4251) #endif std :: variant < std :: nullptr_t , ObjectType , ArrayType , NumberType , StringType , VectorType , TransformType > data ; #if defined(_MSC_VER) #pragma warning(pop) #endif PropertyType type { PropertyType :: NONE }; }; } // namespace dakku #endif Updated on 2022-04-11 at 15:27:24 +0000","title":"src/core/property.h"},{"location":"Files/property_8h/#srccorepropertyh","text":"","title":"src/core/property.h"},{"location":"Files/property_8h/#namespaces","text":"Name dakku dakku namespace","title":"Namespaces"},{"location":"Files/property_8h/#classes","text":"Name class dakku::Property property class, containing many data types, similar to json","title":"Classes"},{"location":"Files/property_8h/#source-code","text":"#ifndef DAKKU_CORE_PROPERTY_H_ #define DAKKU_CORE_PROPERTY_H_ #include <core/vector.h> #include <core/transform.h> #include <nlohmann/json.hpp> #include <map> #include <string> #include <variant> namespace dakku { enum class PropertyType { NONE , ARRAY , OBJECT , NUMBER , STRING , VECTOR , TRANSFORM }; class DAKKU_EXPORT_CORE Property { public : using ObjectType = std :: map < std :: string , Property , std :: less <>> ; using ArrayType = std :: vector < Property > ; using NumberType = float ; using VectorType = std :: vector < float > ; using StringType = std :: string ; using TransformType = Transform ; Property () = default ; template < ArithmeticType T > Property ( const T & v ) : data ( static_cast < float > ( v )), type ( PropertyType :: NUMBER ) {} Property ( const std :: string & s ) : data ( s ), type ( PropertyType :: STRING ) {} template < ArithmeticType T , size_t S , typename D > Property ( const VectorBase < T , S , D > & v ) : data ( v . toFloatVector ()), type ( PropertyType :: VECTOR ) {} Property ( const std :: vector < float > & v ) { if ( v . size () <= 3 ) { data = v ; type = PropertyType :: VECTOR ; } else if ( v . size () == 16 ) { data = Transform { v }; type = PropertyType :: TRANSFORM ; } else { std :: vector < Property > tmp ; tmp . reserve ( v . size ()); for ( float i : v ) tmp . emplace_back ( i ); data = std :: move ( tmp ); type = PropertyType :: ARRAY ; } } Property ( const Transform & t ) : data ( t ), type ( PropertyType :: TRANSFORM ) {} [[ nodiscard ]] decltype ( auto ) getPropertyType () const { return type ; } template < PropertyType type > [[ nodiscard ]] decltype ( auto ) get () { auto & ret = static_cast < const Property &> ( * this ). get < type > (); return const_cast < std :: add_lvalue_reference_t < std :: decay_t < decltype ( ret ) >>> ( ret ); } template < PropertyType type , bool required = false > [[ nodiscard ]] decltype ( auto ) get () const { if constexpr ( type == PropertyType :: OBJECT ) { return std :: get < ObjectType > ( data ); } else if constexpr ( type == PropertyType :: ARRAY ) { return std :: get < ArrayType > ( data ); } else if constexpr ( type == PropertyType :: NUMBER ) { return std :: get < NumberType > ( data ); } else if constexpr ( type == PropertyType :: STRING ) { return std :: get < StringType > ( data ); } else if constexpr ( type == PropertyType :: VECTOR ) { return std :: get < VectorType > ( data ); } else if constexpr ( type == PropertyType :: TRANSFORM ) { return std :: get < TransformType > ( data ); } else { if constexpr ( type == PropertyType :: NONE ) { DAKKU_WARN ( \"none property type\" ); } else { DAKKU_WARN ( \"invalid property type: {}\" , type ); } return std :: get < std :: nullptr_t > ( data ); } } [[ nodiscard ]] decltype ( auto ) getObject () { return get < PropertyType :: OBJECT > (); } [[ nodiscard ]] decltype ( auto ) getObject () const { return get < PropertyType :: OBJECT > (); } [[ nodiscard ]] decltype ( auto ) getArray () { return get < PropertyType :: ARRAY > (); } [[ nodiscard ]] decltype ( auto ) getArray () const { return get < PropertyType :: ARRAY > (); } [[ nodiscard ]] decltype ( auto ) getNumber () { return get < PropertyType :: NUMBER > (); } [[ nodiscard ]] decltype ( auto ) getNumber () const { return get < PropertyType :: NUMBER > (); } [[ nodiscard ]] decltype ( auto ) getString () { return get < PropertyType :: STRING > (); } [[ nodiscard ]] decltype ( auto ) getString () const { return get < PropertyType :: STRING > (); } [[ nodiscard ]] decltype ( auto ) getVector () { return get < PropertyType :: VECTOR > (); } [[ nodiscard ]] decltype ( auto ) getVector () const { return get < PropertyType :: VECTOR > (); } [[ nodiscard ]] decltype ( auto ) getTransform () { return get < PropertyType :: TRANSFORM > (); } [[ nodiscard ]] decltype ( auto ) getTransform () const { return get < PropertyType :: TRANSFORM > (); } [[ nodiscard ]] bool isObjectType () const { return type == PropertyType :: OBJECT ; } [[ nodiscard ]] bool isArrayType () const { return type == PropertyType :: ARRAY ; } [[ nodiscard ]] bool isNumberType () const { return type == PropertyType :: NUMBER ; } [[ nodiscard ]] bool isStringType () const { return type == PropertyType :: STRING ; } [[ nodiscard ]] bool isVectorType () const { return type == PropertyType :: VECTOR ; } [[ nodiscard ]] bool isTransformType () const { return type == PropertyType :: TRANSFORM ; } decltype ( auto ) operator []( const std :: string & key ) { if ( type == PropertyType :: NONE ) { data = ObjectType {}; type = PropertyType :: OBJECT ; } DAKKU_CHECK ( isObjectType (), \"looking up {} in a non-object property\" , key ); return getObject ()[ key ]; } decltype ( auto ) operator []( const std :: string & key ) const { if ( ! isObjectType ()) { DAKKU_ERR ( \"try to access {} in a non-object type property\" , key ); std :: exit ( -1 ); } if ( auto it = getObject (). find ( key ); it != getObject (). end ()) { return it -> second ; } else { DAKKU_ERR ( \"cannot find the request key: {}\" , key ); std :: exit ( -1 ); } } decltype ( auto ) operator []( size_t i ) { if ( type == PropertyType :: NONE ) { data = ArrayType {}; type = PropertyType :: ARRAY ; getArray (). reserve (( i + 1 ) * 2 ); } DAKKU_CHECK ( isArrayType (), \"index {} in a non-array property\" , i ); auto & arr = getArray (); if ( i >= arr . size ()) { arr . reserve (( i + 1 ) * 2 ); arr . resize ( i + 1 ); } return getArray ()[ i ]; } decltype ( auto ) operator []( size_t i ) const { if ( type == PropertyType :: NONE ) { DAKKU_ERR ( \"try to index {} in a non-array type property\" , i ); std :: exit ( -1 ); } if ( const auto & arr = getArray (); i < arr . size ()) { return arr [ i ]; } else { DAKKU_ERR ( \"index out of range: {} >= {}\" , i , arr . size ()); std :: exit ( -1 ); } } [[ nodiscard ]] std :: string toString () const ; friend std :: ostream & operator << ( std :: ostream & os , const Property & property ) { return os << property . toString (); } friend void to_json ( nlohmann :: json & j , const Property & p ) { switch ( p . type ) { case PropertyType :: OBJECT : { for ( const auto & [ k , v ] : p . getObject ()) { to_json ( j [ k ], v ); } break ; } case PropertyType :: ARRAY : { j = nlohmann :: json :: array (); for ( const auto & v : p . getArray ()) { j . push_back ( nlohmann :: json {}); to_json ( j . back (), v ); } break ; } case PropertyType :: NUMBER : { j = p . getNumber (); break ; } case PropertyType :: STRING : { j = p . getString (); break ; } case PropertyType :: VECTOR : { j = p . getVector (); break ; } case PropertyType :: TRANSFORM : { j = p . getTransform (). getMatrix (). toFloatVector (); break ; } case PropertyType :: NONE : { DAKKU_ERR ( \"none property type\" ); break ; } default : { DAKKU_ERR ( \"invalid property type: {}\" , p . type ); break ; } } } friend void from_json ( const nlohmann :: json & j , Property & p ) { if ( j . is_object ()) { for ( auto it = j . begin (); it != j . end (); ++ it ) from_json ( * it , p [ it . key ()]); } else if ( j . is_array ()) { auto isFloatVector = [ & ] { for ( const auto & v : j ) if ( ! v . is_number ()) return false ; return true ; }; if ( isFloatVector ()) { VectorType tmp ; j . get_to ( tmp ); p = tmp ; } else { for ( size_t i = 0 ; i < j . size (); ++ i ) from_json ( j [ i ], p [ i ]); } } else if ( j . is_number ()) { p = j . get < float > (); } else if ( j . is_string ()) { p = j . get < std :: string > (); } else if ( j . is_boolean ()) { p = static_cast < float > ( j . get < bool > ()); } else { DAKKU_ERR ( \"unknown type in json: {}\" , j . type_name ()); std :: exit ( -1 ); } } [[ nodiscard ]] Transform mergeTransform () const { // already a transform Transform ret ; if ( isTransformType ()) return ret ; if ( isArrayType ()) { auto & arr = getArray (); for ( const auto & v : arr ) { if ( ! v . isTransformType ()) { if ( v . isObjectType ()) { std :: string transType ; if ( auto it = v . getObject (). find ( \"type\" ); it != v . getObject (). end () && it -> second . isStringType ()) { transType = it -> second . getString (); } else { DAKKU_ERR ( \"cannot merge transforms for: {}\" , * this ); } if ( transType == \"lookat\" ) { Point3f pos = v [ \"pos\" ]. getVector (); Point3f look = v [ \"look\" ]. getVector (); Vector3f refUp = v [ \"up\" ]. getVector (); ret = ret * lookAt ( pos , look , refUp ); } else if ( transType == \"rotate\" ) { float angle = v [ \"data\" ]. getNumber (); if ( v [ \"axis\" ]. isStringType ()) { std :: string axis = v [ \"axis\" ]. getString (); if ( axis == \"x\" ) { ret = ret * rotateX ( angle ); } else if ( axis == \"y\" ) { ret = ret * rotateY ( angle ); } else if ( axis == \"z\" ) { ret = ret * rotateZ ( angle ); } else { DAKKU_ERR ( \"invalid axis for rotation: {}\" , axis ); return ret ; } } else { Vector3f axis = v [ \"axis\" ]. getVector (); ret = ret * rotate ( angle , axis ); } } else if ( transType == \"translate\" ) { Vector3f delta = v [ \"data\" ]. getVector (); ret = ret * translate ( delta ); } else if ( transType == \"scale\" ) { Vector3f s = v [ \"data\" ]. getVector (); ret = ret * scale ( s . x (), s . y (), s . z ()); } else { DAKKU_ERR ( \"invalid transform type: {}\" , type ); return ret ; } } else { DAKKU_ERR ( \"cannot merge transforms for: {}\" , * this ); return ret ; } } } } else { DAKKU_ERR ( \"cannot merge transforms for: {}\" , * this ); } return ret ; } template < typename T > T getVectorIf ( std :: string_view key , const T & value ) const { if ( auto it = getObject (). find ( key ); it != getObject (). end ()) { return T { it -> second . getVector ()}; } else { return value ; } } template < ArithmeticType T = float > T getNumberIf ( std :: string_view key , const T & value ) const { if ( auto it = getObject (). find ( key ); it != getObject (). end ()) { return static_cast < T > ( it -> second . getNumber ()); } else { return value ; } } [[ nodiscard ]] std :: string getStringIf ( std :: string_view key , const std :: string & value ) const { if ( auto it = getObject (). find ( key ); it != getObject (). end ()) { return it -> second . getString (); } else { return value ; } } private : #if defined(_MSC_VER) #pragma warning(push) #pragma warning(disable : 4251) #endif std :: variant < std :: nullptr_t , ObjectType , ArrayType , NumberType , StringType , VectorType , TransformType > data ; #if defined(_MSC_VER) #pragma warning(pop) #endif PropertyType type { PropertyType :: NONE }; }; } // namespace dakku #endif Updated on 2022-04-11 at 15:27:24 +0000","title":"Source code"},{"location":"Files/ray_8h/","text":"src/core/ray.h Namespaces Name dakku dakku namespace Classes Name class dakku::Ray ray class dakku::RayDifferential differential ray Source code #ifndef DAKKU_CORE_RAY_H_ #define DAKKU_CORE_RAY_H_ #include <core/vector.h> #include <utility> namespace dakku { class Ray { public : Ray () = default ; explicit Ray ( Point3f o , Vector3f d , float tMax = INF ) : o ( std :: move ( o )), d ( std :: move ( d )), tMax ( tMax ) {} Point3f operator ()( float t ) const { return o + d * t ; } [[ nodiscard ]] bool hasNaNs () const { return o . hasNaNs () || d . hasNaNs () || isNaN ( tMax ); } Point3f o ; Vector3f d ; mutable float tMax { INF }; }; class RayDifferential : public Ray { public : RayDifferential () = default ; explicit RayDifferential ( const Point3f & o , const Vector3f & d , float tMax = INF ) : Ray ( o , d , tMax ) {} [[ nodiscard ]] bool hasNaNs () const { return Ray :: hasNaNs () || ( hasDifferentials && ( rxOrigin . hasNaNs () || ryOrigin . hasNaNs () || rxDirection . hasNaNs () || ryDirection . hasNaNs ())); } void scaleDifferentials ( float s ) { rxOrigin = o + ( rxOrigin - o ) * s ; ryOrigin = o + ( ryOrigin - o ) * s ; rxDirection = d + ( rxDirection - d ) * s ; ryDirection = d + ( ryDirection - d ) * s ; } bool hasDifferentials { false }; Point3f rxOrigin ; Point3f ryOrigin ; Vector3f rxDirection ; Vector3f ryDirection ; }; inline Point3f offsetRayOrigin ( const Point3f & p , const Normal3f & n , const Vector3f & w ) { Vector3f offset = SHADOW_EPS * Vector3f ( n ); if ( dot ( w , n ) < 0 ) offset = - offset ; return p + offset ; } } // namespace dakku #endif Updated on 2022-04-11 at 15:27:24 +0000","title":"src/core/ray.h"},{"location":"Files/ray_8h/#srccorerayh","text":"","title":"src/core/ray.h"},{"location":"Files/ray_8h/#namespaces","text":"Name dakku dakku namespace","title":"Namespaces"},{"location":"Files/ray_8h/#classes","text":"Name class dakku::Ray ray class dakku::RayDifferential differential ray","title":"Classes"},{"location":"Files/ray_8h/#source-code","text":"#ifndef DAKKU_CORE_RAY_H_ #define DAKKU_CORE_RAY_H_ #include <core/vector.h> #include <utility> namespace dakku { class Ray { public : Ray () = default ; explicit Ray ( Point3f o , Vector3f d , float tMax = INF ) : o ( std :: move ( o )), d ( std :: move ( d )), tMax ( tMax ) {} Point3f operator ()( float t ) const { return o + d * t ; } [[ nodiscard ]] bool hasNaNs () const { return o . hasNaNs () || d . hasNaNs () || isNaN ( tMax ); } Point3f o ; Vector3f d ; mutable float tMax { INF }; }; class RayDifferential : public Ray { public : RayDifferential () = default ; explicit RayDifferential ( const Point3f & o , const Vector3f & d , float tMax = INF ) : Ray ( o , d , tMax ) {} [[ nodiscard ]] bool hasNaNs () const { return Ray :: hasNaNs () || ( hasDifferentials && ( rxOrigin . hasNaNs () || ryOrigin . hasNaNs () || rxDirection . hasNaNs () || ryDirection . hasNaNs ())); } void scaleDifferentials ( float s ) { rxOrigin = o + ( rxOrigin - o ) * s ; ryOrigin = o + ( ryOrigin - o ) * s ; rxDirection = d + ( rxDirection - d ) * s ; ryDirection = d + ( ryDirection - d ) * s ; } bool hasDifferentials { false }; Point3f rxOrigin ; Point3f ryOrigin ; Vector3f rxDirection ; Vector3f ryDirection ; }; inline Point3f offsetRayOrigin ( const Point3f & p , const Normal3f & n , const Vector3f & w ) { Vector3f offset = SHADOW_EPS * Vector3f ( n ); if ( dot ( w , n ) < 0 ) offset = - offset ; return p + offset ; } } // namespace dakku #endif Updated on 2022-04-11 at 15:27:24 +0000","title":"Source code"},{"location":"Files/relative_8h/","text":"src/core/relative.h Namespaces Name dakku dakku namespace Classes Name class dakku::RelativeRoot utility to retrieve relative path (used for scene loading and saving) Source code #ifndef DAKKU_CORE_RELATIVE_H_ #define DAKKU_CORE_RELATIVE_H_ #include <core/fwd.h> #include <string> #include <filesystem> namespace dakku { class DAKKU_EXPORT_CORE RelativeRoot final { public : static RelativeRoot & instance (); [[ nodiscard ]] const std :: string & get () const ; [[ nodiscard ]] std :: filesystem :: path get ( const std :: filesystem :: path & path ) const ; [[ nodiscard ]] std :: string get ( const std :: string & path ) const ; void set ( const std :: filesystem :: path & root ); private : explicit RelativeRoot () = default ; #if defined(_MSC_VER) #pragma warning(push) #pragma warning(disable : 4251) #endif std :: string dir ; #if defined(_MSC_VER) #pragma warning(pop) #endif }; } // namespace dakku #endif Updated on 2022-04-11 at 15:27:24 +0000","title":"src/core/relative.h"},{"location":"Files/relative_8h/#srccorerelativeh","text":"","title":"src/core/relative.h"},{"location":"Files/relative_8h/#namespaces","text":"Name dakku dakku namespace","title":"Namespaces"},{"location":"Files/relative_8h/#classes","text":"Name class dakku::RelativeRoot utility to retrieve relative path (used for scene loading and saving)","title":"Classes"},{"location":"Files/relative_8h/#source-code","text":"#ifndef DAKKU_CORE_RELATIVE_H_ #define DAKKU_CORE_RELATIVE_H_ #include <core/fwd.h> #include <string> #include <filesystem> namespace dakku { class DAKKU_EXPORT_CORE RelativeRoot final { public : static RelativeRoot & instance (); [[ nodiscard ]] const std :: string & get () const ; [[ nodiscard ]] std :: filesystem :: path get ( const std :: filesystem :: path & path ) const ; [[ nodiscard ]] std :: string get ( const std :: string & path ) const ; void set ( const std :: filesystem :: path & root ); private : explicit RelativeRoot () = default ; #if defined(_MSC_VER) #pragma warning(push) #pragma warning(disable : 4251) #endif std :: string dir ; #if defined(_MSC_VER) #pragma warning(pop) #endif }; } // namespace dakku #endif Updated on 2022-04-11 at 15:27:24 +0000","title":"Source code"},{"location":"Files/serialization_8h/","text":"src/core/serialization.h Namespaces Name dakku dakku namespace Classes Name class dakku::InputStream input stream class dakku::OutputStream output stream class dakku::SerializableObject serializable object Source code #ifndef DAKKU_CORE_SERIALIZATION_H_ #define DAKKU_CORE_SERIALIZATION_H_ #include <core/object.h> namespace dakku { class DAKKU_EXPORT_CORE InputStream : public Object { public : DAKKU_DECLARE_OBJECT ( InputStream , Object ); virtual std :: uint8_t readByte () = 0 ; virtual size_t readBytes ( void * ptr , size_t size ) = 0 ; }; class DAKKU_EXPORT_CORE OutputStream : public Object { public : DAKKU_DECLARE_OBJECT ( OutputStream , Object ); virtual void writeByte ( std :: uint8_t value ) = 0 ; virtual size_t writeBytes ( const void * ptr , size_t size ) = 0 ; }; class DAKKU_EXPORT_CORE SerializableObject : public Object { public : DAKKU_DECLARE_OBJECT ( SerializableObject , Object ); virtual void serialize ( OutputStream * stream ) const = 0 ; virtual void deserialize ( InputStream * stream ) = 0 ; }; } // namespace dakku #endif Updated on 2022-04-11 at 15:27:24 +0000","title":"src/core/serialization.h"},{"location":"Files/serialization_8h/#srccoreserializationh","text":"","title":"src/core/serialization.h"},{"location":"Files/serialization_8h/#namespaces","text":"Name dakku dakku namespace","title":"Namespaces"},{"location":"Files/serialization_8h/#classes","text":"Name class dakku::InputStream input stream class dakku::OutputStream output stream class dakku::SerializableObject serializable object","title":"Classes"},{"location":"Files/serialization_8h/#source-code","text":"#ifndef DAKKU_CORE_SERIALIZATION_H_ #define DAKKU_CORE_SERIALIZATION_H_ #include <core/object.h> namespace dakku { class DAKKU_EXPORT_CORE InputStream : public Object { public : DAKKU_DECLARE_OBJECT ( InputStream , Object ); virtual std :: uint8_t readByte () = 0 ; virtual size_t readBytes ( void * ptr , size_t size ) = 0 ; }; class DAKKU_EXPORT_CORE OutputStream : public Object { public : DAKKU_DECLARE_OBJECT ( OutputStream , Object ); virtual void writeByte ( std :: uint8_t value ) = 0 ; virtual size_t writeBytes ( const void * ptr , size_t size ) = 0 ; }; class DAKKU_EXPORT_CORE SerializableObject : public Object { public : DAKKU_DECLARE_OBJECT ( SerializableObject , Object ); virtual void serialize ( OutputStream * stream ) const = 0 ; virtual void deserialize ( InputStream * stream ) = 0 ; }; } // namespace dakku #endif Updated on 2022-04-11 at 15:27:24 +0000","title":"Source code"},{"location":"Files/shape_8h/","text":"src/core/shape.h Namespaces Name dakku dakku namespace Classes Name class dakku::Shape Source code #ifndef DAKKU_CORE_SHAPE_H_ #define DAKKU_CORE_SHAPE_H_ #include <core/transform.h> #include <core/object.h> #include <core/bounds.h> namespace dakku { class DAKKU_EXPORT_CORE Shape : public Object { public : DAKKU_DECLARE_OBJECT ( Shape , Object ); explicit Shape ( const Transform * objectToWorld , const Transform * worldToObject ); [[ nodiscard ]] virtual Bounds3f objectBound () const = 0 ; [[ nodiscard ]] virtual Bounds3f worldBound () const = 0 ; }; } // namespace dakku #endif Updated on 2022-04-11 at 15:27:24 +0000","title":"src/core/shape.h"},{"location":"Files/shape_8h/#srccoreshapeh","text":"","title":"src/core/shape.h"},{"location":"Files/shape_8h/#namespaces","text":"Name dakku dakku namespace","title":"Namespaces"},{"location":"Files/shape_8h/#classes","text":"Name class dakku::Shape","title":"Classes"},{"location":"Files/shape_8h/#source-code","text":"#ifndef DAKKU_CORE_SHAPE_H_ #define DAKKU_CORE_SHAPE_H_ #include <core/transform.h> #include <core/object.h> #include <core/bounds.h> namespace dakku { class DAKKU_EXPORT_CORE Shape : public Object { public : DAKKU_DECLARE_OBJECT ( Shape , Object ); explicit Shape ( const Transform * objectToWorld , const Transform * worldToObject ); [[ nodiscard ]] virtual Bounds3f objectBound () const = 0 ; [[ nodiscard ]] virtual Bounds3f worldBound () const = 0 ; }; } // namespace dakku #endif Updated on 2022-04-11 at 15:27:24 +0000","title":"Source code"},{"location":"Files/spectrum_8h/","text":"src/core/spectrum.h Namespaces Name dakku dakku namespace Classes Name class dakku::CoefficientSpectrum coefficient spectrum class dakku::RgbSpectrum spectrum that only use r, g, b Source code #ifndef DAKKU_CORE_SPECTRUM_H_ #define DAKKU_CORE_SPECTRUM_H_ #include <core/vector_base.h> namespace dakku { inline void xyzToRgb ( std :: span < const float , 3 > xyz , std :: span < float , 3 > rgb ) { rgb [ 0 ] = 3.240479f * xyz [ 0 ] - 1.537150f * xyz [ 1 ] - 0.498535f * xyz [ 2 ]; rgb [ 1 ] = -0.969256f * xyz [ 0 ] + 1.875991f * xyz [ 1 ] + 0.041556f * xyz [ 2 ]; rgb [ 2 ] = 0.055648f * xyz [ 0 ] - 0.204043f * xyz [ 1 ] + 1.057311f * xyz [ 2 ]; } inline void rgbToXyz ( std :: span < const float , 3 > rgb , std :: span < float , 3 > xyz ) { xyz [ 0 ] = 0.412453f * rgb [ 0 ] + 0.357580f * rgb [ 1 ] + 0.180423f * rgb [ 2 ]; xyz [ 1 ] = 0.212671f * rgb [ 0 ] + 0.715160f * rgb [ 1 ] + 0.072169f * rgb [ 2 ]; xyz [ 2 ] = 0.019334f * rgb [ 0 ] + 0.119193f * rgb [ 1 ] + 0.950227f * rgb [ 2 ]; } template < size_t S , typename Derived > class CoefficientSpectrum : public VectorBase < float , S , Derived > { public : using VectorBase < float , S , Derived >:: VectorBase ; [[ nodiscard ]] bool isBlack () const { return this -> isZero (); } [[ nodiscard ]] Derived clamp ( float low = 0 , float high = INF ) const { Derived ret = static_cast < const Derived &> ( * this ); for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = std :: clamp ( ret [ i ], low , high ); return ret ; } }; class RgbSpectrum : public CoefficientSpectrum < 3 , RgbSpectrum > { public : using CoefficientSpectrum < 3 , RgbSpectrum >:: CoefficientSpectrum ; static RgbSpectrum fromRgb ( std :: span < const float , 3 > rgb ) { return RgbSpectrum { rgb [ 0 ], rgb [ 1 ], rgb [ 2 ]}; } static RgbSpectrum fromXyz ( std :: span < const float , 3 > xyz ) { RgbSpectrum ret ; xyzToRgb ( xyz , ret ); return ret ; } void toRgb ( std :: span < float , 3 > rgb ) const { rgb [ 0 ] = ( * this )[ 0 ]; rgb [ 1 ] = ( * this )[ 1 ]; rgb [ 2 ] = ( * this )[ 2 ]; } void toXyz ( std :: span < float , 3 > xyz ) const { rgbToXyz ( * this , xyz ); } }; } // namespace dakku #endif Updated on 2022-04-11 at 15:27:24 +0000","title":"src/core/spectrum.h"},{"location":"Files/spectrum_8h/#srccorespectrumh","text":"","title":"src/core/spectrum.h"},{"location":"Files/spectrum_8h/#namespaces","text":"Name dakku dakku namespace","title":"Namespaces"},{"location":"Files/spectrum_8h/#classes","text":"Name class dakku::CoefficientSpectrum coefficient spectrum class dakku::RgbSpectrum spectrum that only use r, g, b","title":"Classes"},{"location":"Files/spectrum_8h/#source-code","text":"#ifndef DAKKU_CORE_SPECTRUM_H_ #define DAKKU_CORE_SPECTRUM_H_ #include <core/vector_base.h> namespace dakku { inline void xyzToRgb ( std :: span < const float , 3 > xyz , std :: span < float , 3 > rgb ) { rgb [ 0 ] = 3.240479f * xyz [ 0 ] - 1.537150f * xyz [ 1 ] - 0.498535f * xyz [ 2 ]; rgb [ 1 ] = -0.969256f * xyz [ 0 ] + 1.875991f * xyz [ 1 ] + 0.041556f * xyz [ 2 ]; rgb [ 2 ] = 0.055648f * xyz [ 0 ] - 0.204043f * xyz [ 1 ] + 1.057311f * xyz [ 2 ]; } inline void rgbToXyz ( std :: span < const float , 3 > rgb , std :: span < float , 3 > xyz ) { xyz [ 0 ] = 0.412453f * rgb [ 0 ] + 0.357580f * rgb [ 1 ] + 0.180423f * rgb [ 2 ]; xyz [ 1 ] = 0.212671f * rgb [ 0 ] + 0.715160f * rgb [ 1 ] + 0.072169f * rgb [ 2 ]; xyz [ 2 ] = 0.019334f * rgb [ 0 ] + 0.119193f * rgb [ 1 ] + 0.950227f * rgb [ 2 ]; } template < size_t S , typename Derived > class CoefficientSpectrum : public VectorBase < float , S , Derived > { public : using VectorBase < float , S , Derived >:: VectorBase ; [[ nodiscard ]] bool isBlack () const { return this -> isZero (); } [[ nodiscard ]] Derived clamp ( float low = 0 , float high = INF ) const { Derived ret = static_cast < const Derived &> ( * this ); for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = std :: clamp ( ret [ i ], low , high ); return ret ; } }; class RgbSpectrum : public CoefficientSpectrum < 3 , RgbSpectrum > { public : using CoefficientSpectrum < 3 , RgbSpectrum >:: CoefficientSpectrum ; static RgbSpectrum fromRgb ( std :: span < const float , 3 > rgb ) { return RgbSpectrum { rgb [ 0 ], rgb [ 1 ], rgb [ 2 ]}; } static RgbSpectrum fromXyz ( std :: span < const float , 3 > xyz ) { RgbSpectrum ret ; xyzToRgb ( xyz , ret ); return ret ; } void toRgb ( std :: span < float , 3 > rgb ) const { rgb [ 0 ] = ( * this )[ 0 ]; rgb [ 1 ] = ( * this )[ 1 ]; rgb [ 2 ] = ( * this )[ 2 ]; } void toXyz ( std :: span < float , 3 > xyz ) const { rgbToXyz ( * this , xyz ); } }; } // namespace dakku #endif Updated on 2022-04-11 at 15:27:24 +0000","title":"Source code"},{"location":"Files/stream_2api_8h/","text":"src/stream/api.h this must be include only once in source Namespaces Name dakku dakku namespace Source code #ifndef DAKKU_STREAM_API_H_ #define DAKKU_STREAM_API_H_ #include <stream/fstream.h> namespace dakku { DAKKU_EXPORT_OBJECTS ( Stream , FileOutputStream , FileInputStream ); } #endif Updated on 2022-04-11 at 15:27:24 +0000","title":"src/stream/api.h"},{"location":"Files/stream_2api_8h/#srcstreamapih","text":"this must be include only once in source","title":"src/stream/api.h"},{"location":"Files/stream_2api_8h/#namespaces","text":"Name dakku dakku namespace","title":"Namespaces"},{"location":"Files/stream_2api_8h/#source-code","text":"#ifndef DAKKU_STREAM_API_H_ #define DAKKU_STREAM_API_H_ #include <stream/fstream.h> namespace dakku { DAKKU_EXPORT_OBJECTS ( Stream , FileOutputStream , FileInputStream ); } #endif Updated on 2022-04-11 at 15:27:24 +0000","title":"Source code"},{"location":"Files/stream_2fwd_8h/","text":"src/stream/fwd.h Namespaces Name dakku dakku namespace Defines Name DAKKU_EXPORT_STREAM Macros Documentation define DAKKU_EXPORT_STREAM #define DAKKU_EXPORT_STREAM DAKKU_EXPORT Source code #ifndef DAKKU_STREAM_FWD_H_ #define DAKKU_STREAM_FWD_H_ #include <core/serialization.h> namespace dakku { #if DAKKU_BUILD_MODULE != DAKKU_STREAM_MODULE #define DAKKU_EXPORT_STREAM DAKKU_IMPORT #else #define DAKKU_EXPORT_STREAM DAKKU_EXPORT #endif } // namespace dakku #endif Updated on 2022-04-11 at 15:27:24 +0000","title":"src/stream/fwd.h"},{"location":"Files/stream_2fwd_8h/#srcstreamfwdh","text":"","title":"src/stream/fwd.h"},{"location":"Files/stream_2fwd_8h/#namespaces","text":"Name dakku dakku namespace","title":"Namespaces"},{"location":"Files/stream_2fwd_8h/#defines","text":"Name DAKKU_EXPORT_STREAM","title":"Defines"},{"location":"Files/stream_2fwd_8h/#macros-documentation","text":"","title":"Macros Documentation"},{"location":"Files/stream_2fwd_8h/#define-dakku_export_stream","text":"#define DAKKU_EXPORT_STREAM DAKKU_EXPORT","title":"define DAKKU_EXPORT_STREAM"},{"location":"Files/stream_2fwd_8h/#source-code","text":"#ifndef DAKKU_STREAM_FWD_H_ #define DAKKU_STREAM_FWD_H_ #include <core/serialization.h> namespace dakku { #if DAKKU_BUILD_MODULE != DAKKU_STREAM_MODULE #define DAKKU_EXPORT_STREAM DAKKU_IMPORT #else #define DAKKU_EXPORT_STREAM DAKKU_EXPORT #endif } // namespace dakku #endif Updated on 2022-04-11 at 15:27:24 +0000","title":"Source code"},{"location":"Files/stream_8h/","text":"src/core/stream.h Updated on 2022-04-11 at 15:27:24 +0000","title":"src/core/stream.h"},{"location":"Files/stream_8h/#srccorestreamh","text":"Updated on 2022-04-11 at 15:27:24 +0000","title":"src/core/stream.h"},{"location":"Files/texture_8h/","text":"src/core/texture.h Namespaces Name dakku dakku namespace Classes Name class dakku::TextureMapping2D 2d texture mapping class dakku::UvMapping2D class dakku::Texture Source code #ifndef DAKKU_CORE_TEXTURE_H_ #define DAKKU_CORE_TEXTURE_H_ #include <core/object.h> namespace dakku { class TextureMapping2D : public Object { public : DAKKU_DECLARE_OBJECT ( TextureMapping2D , Object ); virtual Point2f map ( const SurfaceInteraction & si , Vector2f & dstdx , Vector2f & dstdy ) const = 0 ; }; class UvMapping2D : public TextureMapping2D { public : DAKKU_DECLARE_OBJECT ( UvMapping2D , TextureMapping2D ); explicit UvMapping2D ( float su = 1 , float sv = 1 , float du = 0 , float dv = 0 ); Point2f map ( const SurfaceInteraction & si , Vector2f & dstdx , Vector2f & dstdy ) const override ; private : const float su , sv ; const float du , dv ; }; class DAKKU_EXPORT_CORE Texture : public Object { public : DAKKU_DECLARE_OBJECT ( Texture , Object ); explicit Texture ( bool floatType ); [[ nodiscard ]] virtual Spectrum evaluate ( const SurfaceInteraction & ) const = 0 ; protected : bool floatType {}; }; } // namespace dakku #endif Updated on 2022-04-11 at 15:27:24 +0000","title":"src/core/texture.h"},{"location":"Files/texture_8h/#srccoretextureh","text":"","title":"src/core/texture.h"},{"location":"Files/texture_8h/#namespaces","text":"Name dakku dakku namespace","title":"Namespaces"},{"location":"Files/texture_8h/#classes","text":"Name class dakku::TextureMapping2D 2d texture mapping class dakku::UvMapping2D class dakku::Texture","title":"Classes"},{"location":"Files/texture_8h/#source-code","text":"#ifndef DAKKU_CORE_TEXTURE_H_ #define DAKKU_CORE_TEXTURE_H_ #include <core/object.h> namespace dakku { class TextureMapping2D : public Object { public : DAKKU_DECLARE_OBJECT ( TextureMapping2D , Object ); virtual Point2f map ( const SurfaceInteraction & si , Vector2f & dstdx , Vector2f & dstdy ) const = 0 ; }; class UvMapping2D : public TextureMapping2D { public : DAKKU_DECLARE_OBJECT ( UvMapping2D , TextureMapping2D ); explicit UvMapping2D ( float su = 1 , float sv = 1 , float du = 0 , float dv = 0 ); Point2f map ( const SurfaceInteraction & si , Vector2f & dstdx , Vector2f & dstdy ) const override ; private : const float su , sv ; const float du , dv ; }; class DAKKU_EXPORT_CORE Texture : public Object { public : DAKKU_DECLARE_OBJECT ( Texture , Object ); explicit Texture ( bool floatType ); [[ nodiscard ]] virtual Spectrum evaluate ( const SurfaceInteraction & ) const = 0 ; protected : bool floatType {}; }; } // namespace dakku #endif Updated on 2022-04-11 at 15:27:24 +0000","title":"Source code"},{"location":"Files/textures_2api_8h/","text":"src/textures/api.h this must be include only once in source Namespaces Name dakku dakku namespace Source code #ifndef DAKKU_TEXTURES_API_H_ #define DAKKU_TEXTURES_API_H_ #include <textures/constant.h> #include <textures/image.h> namespace dakku { DAKKU_EXPORT_OBJECTS ( Textures , ConstantTexture ); } #endif Updated on 2022-04-11 at 15:27:24 +0000","title":"src/textures/api.h"},{"location":"Files/textures_2api_8h/#srctexturesapih","text":"this must be include only once in source","title":"src/textures/api.h"},{"location":"Files/textures_2api_8h/#namespaces","text":"Name dakku dakku namespace","title":"Namespaces"},{"location":"Files/textures_2api_8h/#source-code","text":"#ifndef DAKKU_TEXTURES_API_H_ #define DAKKU_TEXTURES_API_H_ #include <textures/constant.h> #include <textures/image.h> namespace dakku { DAKKU_EXPORT_OBJECTS ( Textures , ConstantTexture ); } #endif Updated on 2022-04-11 at 15:27:24 +0000","title":"Source code"},{"location":"Files/textures_2fwd_8h/","text":"src/textures/fwd.h Namespaces Name dakku dakku namespace Defines Name DAKKU_EXPORT_TEXTURES Macros Documentation define DAKKU_EXPORT_TEXTURES #define DAKKU_EXPORT_TEXTURES DAKKU_EXPORT Source code #ifndef DAKKU_TEXTURES_FWD_H_ #define DAKKU_TEXTURES_FWD_H_ #include <core/fwd.h> #include <core/texture.h> namespace dakku { #if DAKKU_BUILD_MODULE != DAKKU_TEXTURES_MODULE #define DAKKU_EXPORT_TEXTURES DAKKU_IMPORT #else #define DAKKU_EXPORT_TEXTURES DAKKU_EXPORT #endif } // namespace dakku #endif Updated on 2022-04-11 at 15:27:24 +0000","title":"src/textures/fwd.h"},{"location":"Files/textures_2fwd_8h/#srctexturesfwdh","text":"","title":"src/textures/fwd.h"},{"location":"Files/textures_2fwd_8h/#namespaces","text":"Name dakku dakku namespace","title":"Namespaces"},{"location":"Files/textures_2fwd_8h/#defines","text":"Name DAKKU_EXPORT_TEXTURES","title":"Defines"},{"location":"Files/textures_2fwd_8h/#macros-documentation","text":"","title":"Macros Documentation"},{"location":"Files/textures_2fwd_8h/#define-dakku_export_textures","text":"#define DAKKU_EXPORT_TEXTURES DAKKU_EXPORT","title":"define DAKKU_EXPORT_TEXTURES"},{"location":"Files/textures_2fwd_8h/#source-code","text":"#ifndef DAKKU_TEXTURES_FWD_H_ #define DAKKU_TEXTURES_FWD_H_ #include <core/fwd.h> #include <core/texture.h> namespace dakku { #if DAKKU_BUILD_MODULE != DAKKU_TEXTURES_MODULE #define DAKKU_EXPORT_TEXTURES DAKKU_IMPORT #else #define DAKKU_EXPORT_TEXTURES DAKKU_EXPORT #endif } // namespace dakku #endif Updated on 2022-04-11 at 15:27:24 +0000","title":"Source code"},{"location":"Files/transform_8h/","text":"src/core/transform.h Namespaces Name dakku dakku namespace Classes Name struct dakku::Matrix4x4 4x4 matrix class dakku::Transform Source code #ifndef DAKKU_CORE_TRANSFORM_H_ #define DAKKU_CORE_TRANSFORM_H_ #include <core/vector.h> #include <core/ray.h> namespace dakku { struct DAKKU_EXPORT_CORE Matrix4x4 { Matrix4x4 () { setIdentity (); } Matrix4x4 ( float t00 , float t01 , float t02 , float t03 , float t10 , float t11 , float t12 , float t13 , float t20 , float t21 , float t22 , float t23 , float t30 , float t31 , float t32 , float t33 ) { m [ 0 ][ 0 ] = t00 ; m [ 0 ][ 1 ] = t01 ; m [ 0 ][ 2 ] = t02 ; m [ 0 ][ 3 ] = t03 ; m [ 1 ][ 0 ] = t10 ; m [ 1 ][ 1 ] = t11 ; m [ 1 ][ 2 ] = t12 ; m [ 1 ][ 3 ] = t13 ; m [ 2 ][ 0 ] = t20 ; m [ 2 ][ 1 ] = t21 ; m [ 2 ][ 2 ] = t22 ; m [ 2 ][ 3 ] = t23 ; m [ 3 ][ 0 ] = t30 ; m [ 3 ][ 1 ] = t31 ; m [ 3 ][ 2 ] = t32 ; m [ 3 ][ 3 ] = t33 ; } Matrix4x4 ( const std :: vector < float > & v ) { for ( int i = 0 ; i < 4 ; ++ i ) for ( int j = 0 ; j < 4 ; ++ j ) m [ i ][ j ] = v [ j * 4 + i ]; } decltype ( auto ) operator []( size_t i ) const { return m [ i ]; } decltype ( auto ) operator []( size_t i ) { return m [ i ]; } decltype ( auto ) operator ()( size_t i , size_t j ) { return m [ i ][ j ]; } decltype ( auto ) operator ()( size_t i , size_t j ) const { return m [ i ][ j ]; } void setIdentity () { m [ 0 ][ 1 ] = m [ 0 ][ 2 ] = m [ 0 ][ 3 ] = m [ 1 ][ 0 ] = m [ 1 ][ 2 ] = m [ 1 ][ 3 ] = m [ 2 ][ 0 ] = m [ 2 ][ 1 ] = m [ 2 ][ 3 ] = m [ 3 ][ 0 ] = m [ 3 ][ 1 ] = m [ 3 ][ 2 ] = 0 ; m [ 0 ][ 0 ] = m [ 1 ][ 1 ] = m [ 2 ][ 2 ] = m [ 3 ][ 3 ] = 1 ; } bool operator == ( const Matrix4x4 & rhs ) const { return m == rhs . m ; } bool operator != ( const Matrix4x4 & rhs ) const { return m != rhs . m ; } static Matrix4x4 mul ( const Matrix4x4 & a , const Matrix4x4 & b ); Matrix4x4 operator * ( const Matrix4x4 & rhs ) const { return mul ( * this , rhs ); } Matrix4x4 operator *= ( const Matrix4x4 & rhs ) { * this = mul ( * this , rhs ); return * this ; } friend Matrix4x4 DAKKU_EXPORT_CORE transpose ( const Matrix4x4 & m ); friend Matrix4x4 DAKKU_EXPORT_CORE inverse ( const Matrix4x4 & m ); [[ nodiscard ]] bool isIdentity () const { return * this == Matrix4x4 {}; } [[ nodiscard ]] std :: string toString () const { std :: string ret = \"[\" ; for ( int i = 0 ; i < 4 ; ++ i ) { for ( int j = 0 ; j < 4 ; ++ j ) { ret += std :: to_string ( m [ i ][ j ]); if ( ! ( i == 3 && j == 3 )) ret += \", \" ; } } ret += \"]\" ; return ret ; } friend std :: ostream & operator << ( std :: ostream & os , const Matrix4x4 & m ) { return os << m . toString (); } [[ nodiscard ]] std :: vector < float > toFloatVector () const { std :: vector < float > ret ( 16 ); for ( int i = 0 ; i < 4 ; ++ i ) for ( int j = 0 ; j < 4 ; ++ j ) ret [ j * 4 + i ] = m [ i ][ j ]; return ret ; } std :: array < std :: array < float , 4 > , 4 > m ; }; class Transform { public : Transform () = default ; Transform ( const Matrix4x4 & m ) : m ( m ), mInv ( inverse ( m )) {} Transform ( const Matrix4x4 & m , const Matrix4x4 & mInv ) : m ( m ), mInv ( mInv ) {} friend Transform inverse ( Transform & t ) { return { t . mInv , t . m }; } friend Transform transpose ( Transform & t ) { return { transpose ( t . m ), transpose ( t . mInv )}; } bool operator == ( const Transform & rhs ) const { return m == rhs . m && mInv == rhs . mInv ; } bool operator != ( const Transform & rhs ) const { return m != rhs . m || mInv != rhs . mInv ; } bool operator < ( const Transform & rhs ) const { for ( int i = 0 ; i < 4 ; ++ i ) { for ( int j = 0 ; j < 4 ; ++ j ) { if ( m ( i , j ) < rhs . m ( i , j )) return true ; if ( m ( i , j ) > rhs . m ( i , j )) return false ; } } return false ; } [[ nodiscard ]] bool isIdentity () const { return m . isIdentity (); } [[ nodiscard ]] const Matrix4x4 & getMatrix () const { return m ; } [[ nodiscard ]] const Matrix4x4 & getInverseMatrix () const { return mInv ; } template < ArithmeticType T > inline Point3 < T > operator ()( const Point3 < T > & p ) const ; template < ArithmeticType T > inline Vector3 < T > operator ()( const Vector3 < T > & v ) const ; template < ArithmeticType T > inline Normal3 < T > operator ()( const Normal3 < T > & n ) const ; inline Ray operator ()( const Ray & r ) const ; inline RayDifferential operator ()( const RayDifferential & r ) const ; Transform operator * ( const Transform & rhs ) const { return { m * rhs . m , rhs . mInv * mInv }; } [[ nodiscard ]] bool swapsHandedNess () const { float det = m [ 0 ][ 0 ] * ( m [ 1 ][ 1 ] * m [ 2 ][ 2 ] - m [ 1 ][ 2 ] * m [ 2 ][ 1 ]) - m [ 0 ][ 1 ] * ( m [ 1 ][ 0 ] * m [ 2 ][ 2 ] - m [ 1 ][ 2 ] * m [ 2 ][ 0 ]) + m [ 0 ][ 2 ] * ( m [ 1 ][ 0 ] * m [ 2 ][ 1 ] - m [ 1 ][ 1 ] * m [ 2 ][ 0 ]); return det < 0 ; } private : Matrix4x4 m , mInv ; }; template < ArithmeticType T > inline Point3 < T > Transform :: operator ()( const Point3 < T > & p ) const { T x = p . x (), y = p . y (), z = p . z (); T xp = m [ 0 ][ 0 ] * x + m [ 0 ][ 1 ] * y + m [ 0 ][ 2 ] * z + m [ 0 ][ 3 ]; T yp = m [ 1 ][ 0 ] * x + m [ 1 ][ 1 ] * y + m [ 1 ][ 2 ] * z + m [ 1 ][ 3 ]; T zp = m [ 2 ][ 0 ] * x + m [ 2 ][ 1 ] * y + m [ 2 ][ 2 ] * z + m [ 2 ][ 3 ]; T wp = m [ 3 ][ 0 ] * x + m [ 3 ][ 1 ] * y + m [ 3 ][ 2 ] * z + m [ 3 ][ 3 ]; DAKKU_CHECK ( wp != 0 , \"divide by zero\" ); if ( wp == 1 ) return Point3 < T > ( xp , yp , zp ); else return Point3 < T > ( xp , yp , zp ) / wp ; } template < ArithmeticType T > inline Vector3 < T > Transform :: operator ()( const Vector3 < T > & v ) const { T x = v . x (), y = v . y (), z = v . z (); return Vector3 < T > ( m [ 0 ][ 0 ] * x + m [ 0 ][ 1 ] * y + m [ 0 ][ 2 ] * z , m [ 1 ][ 0 ] * x + m [ 1 ][ 1 ] * y + m [ 1 ][ 2 ] * z , m [ 2 ][ 0 ] * x + m [ 2 ][ 1 ] * y + m [ 2 ][ 2 ] * z ); } template < ArithmeticType T > inline Normal3 < T > Transform :: operator ()( const Normal3 < T > & n ) const { T x = n . x (), y = n . y (), z = n . z (); return Normal3 < T > ( mInv [ 0 ][ 0 ] * x + mInv [ 1 ][ 0 ] * y + mInv [ 2 ][ 0 ] * z , mInv [ 0 ][ 1 ] * x + mInv [ 1 ][ 1 ] * y + mInv [ 2 ][ 1 ] * z , mInv [ 0 ][ 2 ] * x + mInv [ 1 ][ 2 ] * y + mInv [ 2 ][ 2 ] * z ); } inline Ray Transform :: operator ()( const Ray & r ) const { Point3f o = ( * this )( r . o ); Vector3f d = ( * this )( r . d ); return Ray ( o , d , r . tMax ); } inline RayDifferential Transform :: operator ()( const RayDifferential & r ) const { Ray tr = ( * this )( static_cast < const Ray &> ( r )); RayDifferential ret ( tr . o , tr . d , tr . tMax ); ret . hasDifferentials = r . hasDifferentials ; ret . rxOrigin = ( * this )( r . rxOrigin ); ret . ryOrigin = ( * this )( r . ryOrigin ); ret . rxDirection = ( * this )( r . rxDirection ); ret . ryDirection = ( * this )( r . ryDirection ); return ret ; } DAKKU_EXPORT_CORE Transform translate ( const Vector3f & delta ); DAKKU_EXPORT_CORE Transform scale ( float x , float y , float z ); DAKKU_EXPORT_CORE Transform rotateX ( float theta ); DAKKU_EXPORT_CORE Transform rotateY ( float theta ); DAKKU_EXPORT_CORE Transform rotateZ ( float theta ); DAKKU_EXPORT_CORE Transform rotate ( float theta , const Vector3f & axis ); DAKKU_EXPORT_CORE Transform lookAt ( const Point3f & pos , const Point3f & look , const Vector3f & refUp ); DAKKU_EXPORT_CORE Transform perspective ( float fov , float zNear , float zFar ); } // namespace dakku #endif Updated on 2022-04-11 at 15:27:24 +0000","title":"src/core/transform.h"},{"location":"Files/transform_8h/#srccoretransformh","text":"","title":"src/core/transform.h"},{"location":"Files/transform_8h/#namespaces","text":"Name dakku dakku namespace","title":"Namespaces"},{"location":"Files/transform_8h/#classes","text":"Name struct dakku::Matrix4x4 4x4 matrix class dakku::Transform","title":"Classes"},{"location":"Files/transform_8h/#source-code","text":"#ifndef DAKKU_CORE_TRANSFORM_H_ #define DAKKU_CORE_TRANSFORM_H_ #include <core/vector.h> #include <core/ray.h> namespace dakku { struct DAKKU_EXPORT_CORE Matrix4x4 { Matrix4x4 () { setIdentity (); } Matrix4x4 ( float t00 , float t01 , float t02 , float t03 , float t10 , float t11 , float t12 , float t13 , float t20 , float t21 , float t22 , float t23 , float t30 , float t31 , float t32 , float t33 ) { m [ 0 ][ 0 ] = t00 ; m [ 0 ][ 1 ] = t01 ; m [ 0 ][ 2 ] = t02 ; m [ 0 ][ 3 ] = t03 ; m [ 1 ][ 0 ] = t10 ; m [ 1 ][ 1 ] = t11 ; m [ 1 ][ 2 ] = t12 ; m [ 1 ][ 3 ] = t13 ; m [ 2 ][ 0 ] = t20 ; m [ 2 ][ 1 ] = t21 ; m [ 2 ][ 2 ] = t22 ; m [ 2 ][ 3 ] = t23 ; m [ 3 ][ 0 ] = t30 ; m [ 3 ][ 1 ] = t31 ; m [ 3 ][ 2 ] = t32 ; m [ 3 ][ 3 ] = t33 ; } Matrix4x4 ( const std :: vector < float > & v ) { for ( int i = 0 ; i < 4 ; ++ i ) for ( int j = 0 ; j < 4 ; ++ j ) m [ i ][ j ] = v [ j * 4 + i ]; } decltype ( auto ) operator []( size_t i ) const { return m [ i ]; } decltype ( auto ) operator []( size_t i ) { return m [ i ]; } decltype ( auto ) operator ()( size_t i , size_t j ) { return m [ i ][ j ]; } decltype ( auto ) operator ()( size_t i , size_t j ) const { return m [ i ][ j ]; } void setIdentity () { m [ 0 ][ 1 ] = m [ 0 ][ 2 ] = m [ 0 ][ 3 ] = m [ 1 ][ 0 ] = m [ 1 ][ 2 ] = m [ 1 ][ 3 ] = m [ 2 ][ 0 ] = m [ 2 ][ 1 ] = m [ 2 ][ 3 ] = m [ 3 ][ 0 ] = m [ 3 ][ 1 ] = m [ 3 ][ 2 ] = 0 ; m [ 0 ][ 0 ] = m [ 1 ][ 1 ] = m [ 2 ][ 2 ] = m [ 3 ][ 3 ] = 1 ; } bool operator == ( const Matrix4x4 & rhs ) const { return m == rhs . m ; } bool operator != ( const Matrix4x4 & rhs ) const { return m != rhs . m ; } static Matrix4x4 mul ( const Matrix4x4 & a , const Matrix4x4 & b ); Matrix4x4 operator * ( const Matrix4x4 & rhs ) const { return mul ( * this , rhs ); } Matrix4x4 operator *= ( const Matrix4x4 & rhs ) { * this = mul ( * this , rhs ); return * this ; } friend Matrix4x4 DAKKU_EXPORT_CORE transpose ( const Matrix4x4 & m ); friend Matrix4x4 DAKKU_EXPORT_CORE inverse ( const Matrix4x4 & m ); [[ nodiscard ]] bool isIdentity () const { return * this == Matrix4x4 {}; } [[ nodiscard ]] std :: string toString () const { std :: string ret = \"[\" ; for ( int i = 0 ; i < 4 ; ++ i ) { for ( int j = 0 ; j < 4 ; ++ j ) { ret += std :: to_string ( m [ i ][ j ]); if ( ! ( i == 3 && j == 3 )) ret += \", \" ; } } ret += \"]\" ; return ret ; } friend std :: ostream & operator << ( std :: ostream & os , const Matrix4x4 & m ) { return os << m . toString (); } [[ nodiscard ]] std :: vector < float > toFloatVector () const { std :: vector < float > ret ( 16 ); for ( int i = 0 ; i < 4 ; ++ i ) for ( int j = 0 ; j < 4 ; ++ j ) ret [ j * 4 + i ] = m [ i ][ j ]; return ret ; } std :: array < std :: array < float , 4 > , 4 > m ; }; class Transform { public : Transform () = default ; Transform ( const Matrix4x4 & m ) : m ( m ), mInv ( inverse ( m )) {} Transform ( const Matrix4x4 & m , const Matrix4x4 & mInv ) : m ( m ), mInv ( mInv ) {} friend Transform inverse ( Transform & t ) { return { t . mInv , t . m }; } friend Transform transpose ( Transform & t ) { return { transpose ( t . m ), transpose ( t . mInv )}; } bool operator == ( const Transform & rhs ) const { return m == rhs . m && mInv == rhs . mInv ; } bool operator != ( const Transform & rhs ) const { return m != rhs . m || mInv != rhs . mInv ; } bool operator < ( const Transform & rhs ) const { for ( int i = 0 ; i < 4 ; ++ i ) { for ( int j = 0 ; j < 4 ; ++ j ) { if ( m ( i , j ) < rhs . m ( i , j )) return true ; if ( m ( i , j ) > rhs . m ( i , j )) return false ; } } return false ; } [[ nodiscard ]] bool isIdentity () const { return m . isIdentity (); } [[ nodiscard ]] const Matrix4x4 & getMatrix () const { return m ; } [[ nodiscard ]] const Matrix4x4 & getInverseMatrix () const { return mInv ; } template < ArithmeticType T > inline Point3 < T > operator ()( const Point3 < T > & p ) const ; template < ArithmeticType T > inline Vector3 < T > operator ()( const Vector3 < T > & v ) const ; template < ArithmeticType T > inline Normal3 < T > operator ()( const Normal3 < T > & n ) const ; inline Ray operator ()( const Ray & r ) const ; inline RayDifferential operator ()( const RayDifferential & r ) const ; Transform operator * ( const Transform & rhs ) const { return { m * rhs . m , rhs . mInv * mInv }; } [[ nodiscard ]] bool swapsHandedNess () const { float det = m [ 0 ][ 0 ] * ( m [ 1 ][ 1 ] * m [ 2 ][ 2 ] - m [ 1 ][ 2 ] * m [ 2 ][ 1 ]) - m [ 0 ][ 1 ] * ( m [ 1 ][ 0 ] * m [ 2 ][ 2 ] - m [ 1 ][ 2 ] * m [ 2 ][ 0 ]) + m [ 0 ][ 2 ] * ( m [ 1 ][ 0 ] * m [ 2 ][ 1 ] - m [ 1 ][ 1 ] * m [ 2 ][ 0 ]); return det < 0 ; } private : Matrix4x4 m , mInv ; }; template < ArithmeticType T > inline Point3 < T > Transform :: operator ()( const Point3 < T > & p ) const { T x = p . x (), y = p . y (), z = p . z (); T xp = m [ 0 ][ 0 ] * x + m [ 0 ][ 1 ] * y + m [ 0 ][ 2 ] * z + m [ 0 ][ 3 ]; T yp = m [ 1 ][ 0 ] * x + m [ 1 ][ 1 ] * y + m [ 1 ][ 2 ] * z + m [ 1 ][ 3 ]; T zp = m [ 2 ][ 0 ] * x + m [ 2 ][ 1 ] * y + m [ 2 ][ 2 ] * z + m [ 2 ][ 3 ]; T wp = m [ 3 ][ 0 ] * x + m [ 3 ][ 1 ] * y + m [ 3 ][ 2 ] * z + m [ 3 ][ 3 ]; DAKKU_CHECK ( wp != 0 , \"divide by zero\" ); if ( wp == 1 ) return Point3 < T > ( xp , yp , zp ); else return Point3 < T > ( xp , yp , zp ) / wp ; } template < ArithmeticType T > inline Vector3 < T > Transform :: operator ()( const Vector3 < T > & v ) const { T x = v . x (), y = v . y (), z = v . z (); return Vector3 < T > ( m [ 0 ][ 0 ] * x + m [ 0 ][ 1 ] * y + m [ 0 ][ 2 ] * z , m [ 1 ][ 0 ] * x + m [ 1 ][ 1 ] * y + m [ 1 ][ 2 ] * z , m [ 2 ][ 0 ] * x + m [ 2 ][ 1 ] * y + m [ 2 ][ 2 ] * z ); } template < ArithmeticType T > inline Normal3 < T > Transform :: operator ()( const Normal3 < T > & n ) const { T x = n . x (), y = n . y (), z = n . z (); return Normal3 < T > ( mInv [ 0 ][ 0 ] * x + mInv [ 1 ][ 0 ] * y + mInv [ 2 ][ 0 ] * z , mInv [ 0 ][ 1 ] * x + mInv [ 1 ][ 1 ] * y + mInv [ 2 ][ 1 ] * z , mInv [ 0 ][ 2 ] * x + mInv [ 1 ][ 2 ] * y + mInv [ 2 ][ 2 ] * z ); } inline Ray Transform :: operator ()( const Ray & r ) const { Point3f o = ( * this )( r . o ); Vector3f d = ( * this )( r . d ); return Ray ( o , d , r . tMax ); } inline RayDifferential Transform :: operator ()( const RayDifferential & r ) const { Ray tr = ( * this )( static_cast < const Ray &> ( r )); RayDifferential ret ( tr . o , tr . d , tr . tMax ); ret . hasDifferentials = r . hasDifferentials ; ret . rxOrigin = ( * this )( r . rxOrigin ); ret . ryOrigin = ( * this )( r . ryOrigin ); ret . rxDirection = ( * this )( r . rxDirection ); ret . ryDirection = ( * this )( r . ryDirection ); return ret ; } DAKKU_EXPORT_CORE Transform translate ( const Vector3f & delta ); DAKKU_EXPORT_CORE Transform scale ( float x , float y , float z ); DAKKU_EXPORT_CORE Transform rotateX ( float theta ); DAKKU_EXPORT_CORE Transform rotateY ( float theta ); DAKKU_EXPORT_CORE Transform rotateZ ( float theta ); DAKKU_EXPORT_CORE Transform rotate ( float theta , const Vector3f & axis ); DAKKU_EXPORT_CORE Transform lookAt ( const Point3f & pos , const Point3f & look , const Vector3f & refUp ); DAKKU_EXPORT_CORE Transform perspective ( float fov , float zNear , float zFar ); } // namespace dakku #endif Updated on 2022-04-11 at 15:27:24 +0000","title":"Source code"},{"location":"Files/triangle_8h/","text":"src/filters/triangle.h Namespaces Name dakku dakku namespace Classes Name class dakku::TriangleFilter triangle filter the weight falls off linearly from the filter center over the square extent of the filter Source code #ifndef DAKKU_FILTERS_Triangle_H_ #define DAKKU_FILTERS_Triangle_H_ #include <filters/fwd.h> #include <core/filter.h> namespace dakku { class DAKKU_EXPORT_FILTERS TriangleFilter : public Filter { public : DAKKU_DECLARE_OBJECT ( TriangleFilter , Filter ); using Filter :: Filter ; [[ nodiscard ]] float evaluate ( const Point2f & p ) const override ; }; } // namespace dakku #endif Updated on 2022-04-11 at 15:27:24 +0000","title":"src/filters/triangle.h"},{"location":"Files/triangle_8h/#srcfilterstriangleh","text":"","title":"src/filters/triangle.h"},{"location":"Files/triangle_8h/#namespaces","text":"Name dakku dakku namespace","title":"Namespaces"},{"location":"Files/triangle_8h/#classes","text":"Name class dakku::TriangleFilter triangle filter the weight falls off linearly from the filter center over the square extent of the filter","title":"Classes"},{"location":"Files/triangle_8h/#source-code","text":"#ifndef DAKKU_FILTERS_Triangle_H_ #define DAKKU_FILTERS_Triangle_H_ #include <filters/fwd.h> #include <core/filter.h> namespace dakku { class DAKKU_EXPORT_FILTERS TriangleFilter : public Filter { public : DAKKU_DECLARE_OBJECT ( TriangleFilter , Filter ); using Filter :: Filter ; [[ nodiscard ]] float evaluate ( const Point2f & p ) const override ; }; } // namespace dakku #endif Updated on 2022-04-11 at 15:27:24 +0000","title":"Source code"},{"location":"Files/vector_8h/","text":"src/core/vector.h Namespaces Name dakku dakku namespace Classes Name class dakku::Vector vector class dakku::Point point class dakku::Normal normal Source code #ifndef DAKKU_CORE_VECTOR_H_ #define DAKKU_CORE_VECTOR_H_ #include <core/vector_base.h> namespace dakku { template < ArithmeticType T , size_t S > class Vector : public VectorBase < T , S , Vector < T , S >> { public : using VectorBase < T , S , Vector < T , S >>:: VectorBase ; friend Vector operator - ( const Vector & a , const Vector & b ) { Vector ret = a ; ret -= b ; return ret ; } }; template < ArithmeticType T , size_t S > class Point : public VectorBase < T , S , Point < T , S >> { public : using VectorBase < T , S , Point < T , S >>:: VectorBase ; friend Vector < T , S > operator - ( const Point & a , const Point & b ) { return Vector < T , S > ( a ) - Vector < T , S > ( b ); } friend Point operator - ( const Point & a , const Vector < T , S > & b ) { return Point ( Vector < T , S > ( a ) - b ); } friend Point operator + ( const Point & a , const Vector < T , S > & b ) { return Point ( Vector < T , S > ( a ) + b ); } }; template < ArithmeticType T , size_t S > class Normal : public VectorBase < T , S , Normal < T , S >> { public : using VectorBase < T , S , Normal < T , S >>:: VectorBase ; friend Normal operator - ( const Normal & a , const Normal & b ) { Normal ret = a ; ret -= b ; return ret ; } }; template < ArithmeticType T > using Vector2 = Vector < T , 2 > ; template < ArithmeticType T > using Vector3 = Vector < T , 3 > ; using Vector2f = Vector2 < float > ; using Vector3f = Vector3 < float > ; template < ArithmeticType T > using Point2 = Point < T , 2 > ; template < ArithmeticType T > using Point3 = Point < T , 3 > ; using Point2f = Point2 < float > ; using Point2i = Point2 < int > ; using Point3f = Point3 < float > ; template < ArithmeticType T > using Normal3 = Normal < T , 3 > ; using Normal3f = Normal3 < float > ; } // namespace dakku #endif Updated on 2022-04-11 at 15:27:24 +0000","title":"src/core/vector.h"},{"location":"Files/vector_8h/#srccorevectorh","text":"","title":"src/core/vector.h"},{"location":"Files/vector_8h/#namespaces","text":"Name dakku dakku namespace","title":"Namespaces"},{"location":"Files/vector_8h/#classes","text":"Name class dakku::Vector vector class dakku::Point point class dakku::Normal normal","title":"Classes"},{"location":"Files/vector_8h/#source-code","text":"#ifndef DAKKU_CORE_VECTOR_H_ #define DAKKU_CORE_VECTOR_H_ #include <core/vector_base.h> namespace dakku { template < ArithmeticType T , size_t S > class Vector : public VectorBase < T , S , Vector < T , S >> { public : using VectorBase < T , S , Vector < T , S >>:: VectorBase ; friend Vector operator - ( const Vector & a , const Vector & b ) { Vector ret = a ; ret -= b ; return ret ; } }; template < ArithmeticType T , size_t S > class Point : public VectorBase < T , S , Point < T , S >> { public : using VectorBase < T , S , Point < T , S >>:: VectorBase ; friend Vector < T , S > operator - ( const Point & a , const Point & b ) { return Vector < T , S > ( a ) - Vector < T , S > ( b ); } friend Point operator - ( const Point & a , const Vector < T , S > & b ) { return Point ( Vector < T , S > ( a ) - b ); } friend Point operator + ( const Point & a , const Vector < T , S > & b ) { return Point ( Vector < T , S > ( a ) + b ); } }; template < ArithmeticType T , size_t S > class Normal : public VectorBase < T , S , Normal < T , S >> { public : using VectorBase < T , S , Normal < T , S >>:: VectorBase ; friend Normal operator - ( const Normal & a , const Normal & b ) { Normal ret = a ; ret -= b ; return ret ; } }; template < ArithmeticType T > using Vector2 = Vector < T , 2 > ; template < ArithmeticType T > using Vector3 = Vector < T , 3 > ; using Vector2f = Vector2 < float > ; using Vector3f = Vector3 < float > ; template < ArithmeticType T > using Point2 = Point < T , 2 > ; template < ArithmeticType T > using Point3 = Point < T , 3 > ; using Point2f = Point2 < float > ; using Point2i = Point2 < int > ; using Point3f = Point3 < float > ; template < ArithmeticType T > using Normal3 = Normal < T , 3 > ; using Normal3f = Normal3 < float > ; } // namespace dakku #endif Updated on 2022-04-11 at 15:27:24 +0000","title":"Source code"},{"location":"Files/vector__base_8h/","text":"src/core/vector_base.h Namespaces Name dakku dakku namespace Classes Name class dakku::VectorBase vector base class Source code #ifndef DAKKU_CORE_VECTOR_BASE_H_ #define DAKKU_CORE_VECTOR_BASE_H_ #include <core/logger.h> #include <array> #include <algorithm> #include <string> #include <ostream> #include <numeric> #include <span> namespace dakku { template < ArithmeticType T , size_t S , typename Derived > class VectorBase { public : explicit VectorBase () : _data () {} template < ArithmeticType Arg > VectorBase ( Arg value ) { set ( value ); DAKKU_CHECK ( ! hasNaNs (), \"has nan\" ); } template < ArithmeticType Other , typename OtherDerived > explicit VectorBase ( const VectorBase < Other , S , OtherDerived > & other ) { set ( other ); DAKKU_CHECK ( ! hasNaNs (), \"has nan\" ); } VectorBase ( const VectorBase & other ) : _data ( other . _data ) { DAKKU_CHECK ( ! hasNaNs (), \"has nan\" ); } VectorBase ( VectorBase && other ) noexcept : _data ( std :: move ( other . _data )) { DAKKU_CHECK ( ! hasNaNs (), \"has nan\" ); } VectorBase & operator = ( const VectorBase & other ) { if ( this == & other ) return * this ; _data = other . _data ; DAKKU_CHECK ( ! hasNaNs (), \"has nan\" ); return * this ; } VectorBase & operator = ( VectorBase && other ) noexcept { if ( this == & other ) return * this ; _data = std :: move ( other . _data ); DAKKU_CHECK ( ! hasNaNs (), \"has nan\" ); return * this ; } template < ArithmeticType ... Args > requires ( sizeof ...( Args ) == S ) VectorBase ( Args && ... args ) { set ( std :: forward < Args > ( args )...); } template < ArithmeticType Arg > void set ( Arg value ) { _data . fill ( static_cast < T > ( value )); } template < ArithmeticType Arg > void setByIndex ( size_t index , Arg value ) { DAKKU_CHECK ( 0 <= index && index < S , \"index out of range: {} >= {}\" , index , S ); _data [ index ] = static_cast < T > ( value ); } template < ArithmeticType ... Args , size_t ... Is > requires ( sizeof ...( Args ) == S ) void set ( std :: index_sequence < Is ... > , Args && ... args ) { ( setByIndex ( Is , std :: forward < Args > ( args )), ...); } template < ArithmeticType ... Args > requires ( sizeof ...( Args ) == S ) void set ( Args && ... args ) { set ( std :: index_sequence_for < Args ... > {}, std :: forward < Args > ( args )...); } template < ArithmeticType Other , typename OtherDerived > void set ( const VectorBase < Other , S , OtherDerived > & rhs ) { for ( size_t i = 0 ; i < S ; ++ i ) _data [ i ] = static_cast < T > ( rhs [ i ]); } [[ nodiscard ]] bool hasNaNs () const { return std :: any_of ( std :: begin ( _data ), std :: end ( _data ), []( T x ) { return isNaN ( x ); }); } const T & get ( size_t i ) const { return _data [ i ]; } [[ nodiscard ]] std :: string toString () const { std :: string ret { \"[\" }; for ( size_t i = 0 ; i < _data . size (); ++ i ) { ret += std :: to_string ( _data [ i ]); if ( i + 1 != _data . size ()) ret += \", \" ; } return ret + \"]\" ; } friend std :: ostream & operator << ( std :: ostream & os , const VectorBase & vec ) { return os << vec . toString (); } [[ nodiscard ]] size_t size () const { return S ; } const T & operator []( size_t i ) const { return _data [ i ]; } T & operator []( size_t i ) { return const_cast < T &> ( static_cast < const VectorBase &> ( * this )[ i ]); } Derived operator - () const { Derived ret = derived (); for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = - ret [ i ]; return ret ; } const Derived & derived () const { return static_cast < const Derived &> ( * this ); } Derived & derived () { return const_cast < Derived &> ( static_cast < const VectorBase &> ( * this ). derived ()); } Derived & operator += ( const Derived & rhs ) { for ( size_t i = 0 ; i < S ; ++ i ) _data [ i ] += rhs [ i ]; return derived (); } template < ArithmeticType V > Derived & operator += ( const V & rhs ) { for ( size_t i = 0 ; i < S ; ++ i ) _data [ i ] += rhs ; return derived (); } friend Derived operator + ( const Derived & a , const Derived & b ) { Derived ret = a ; ret += b ; return ret ; } template < ArithmeticType U > friend Derived operator + ( const Derived & a , const U & b ) { Derived ret = a ; ret += b ; return ret ; } template < ArithmeticType U > friend Derived operator + ( const U & a , const Derived & b ) { return b + a ; } Derived & operator -= ( const Derived & rhs ) { for ( size_t i = 0 ; i < S ; ++ i ) _data [ i ] -= rhs [ i ]; return derived (); } template < ArithmeticType V > Derived & operator -= ( const V & rhs ) { for ( size_t i = 0 ; i < S ; ++ i ) _data [ i ] -= rhs ; return derived (); } template < ArithmeticType U > friend Derived operator - ( const Derived & a , const U & b ) { Derived ret = a ; ret -= b ; return ret ; } template < ArithmeticType U > friend Derived operator - ( const U & a , const Derived & b ) { Derived ret = - b ; ret += a ; return ret ; } Derived & operator *= ( const Derived & rhs ) { for ( size_t i = 0 ; i < S ; ++ i ) _data [ i ] *= rhs [ i ]; return derived (); } template < ArithmeticType V > Derived & operator *= ( const V & rhs ) { for ( size_t i = 0 ; i < S ; ++ i ) _data [ i ] *= rhs ; return derived (); } friend Derived operator * ( const Derived & a , const Derived & b ) { Derived ret = a ; ret *= b ; return ret ; } template < ArithmeticType U > friend Derived operator * ( const Derived & a , const U & b ) { Derived ret = a ; ret *= b ; return ret ; } template < ArithmeticType U > friend Derived operator * ( const U & a , const Derived & b ) { return b * a ; } Derived & operator /= ( const Derived & rhs ) { for ( size_t i = 0 ; i < S ; ++ i ) _data [ i ] /= rhs [ i ]; return derived (); } template < ArithmeticType V > Derived & operator /= ( const V & rhs ) { return derived () *= static_cast < T > ( T { 1 } / rhs ); } friend Derived operator / ( const Derived & a , const Derived & b ) { Derived ret = a ; ret /= b ; return ret ; } template < ArithmeticType U > friend Derived operator / ( const Derived & a , const U & b ) { Derived ret = a ; ret /= b ; return ret ; } template < ArithmeticType U > friend Derived operator / ( const U & a , const Derived & b ) { return Derived ( a ) / b ; } [[ nodiscard ]] std :: vector < float > toFloatVector () const { std :: vector < float > ret ( S ); for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = static_cast < float > ( _data [ i ]); return ret ; } VectorBase ( const std :: vector < float > & v ) { DAKKU_CHECK ( v . size () == S , \"invalid vector size: {}, expected: {}\" , v . size (), S ); for ( size_t i = 0 ; i < S ; ++ i ) _data [ i ] = static_cast < T > ( v [ i ]); } decltype ( auto ) x () const { static_assert ( S >= 1 , \"not enough size to get x\" ); return _data [ 0 ]; } decltype ( auto ) x () { static_assert ( S >= 1 , \"not enough size to get x\" ); return _data [ 0 ]; } decltype ( auto ) y () const { static_assert ( S >= 2 , \"not enough size to get y\" ); return _data [ 1 ]; } decltype ( auto ) y () { static_assert ( S >= 2 , \"not enough size to get y\" ); return _data [ 1 ]; } decltype ( auto ) z () const { static_assert ( S >= 3 , \"not enough size to get z\" ); return _data [ 2 ]; } decltype ( auto ) z () { static_assert ( S >= 3 , \"not enough size to get w\" ); return _data [ 2 ]; } decltype ( auto ) w () const { static_assert ( S >= 4 , \"not enough size to get w\" ); return _data [ 3 ]; } decltype ( auto ) w () { static_assert ( S >= 4 , \"not enough size to get z\" ); return _data [ 3 ]; } [[ nodiscard ]] size_t maxElementIndex () const { return std :: distance ( begin (), std :: max_element ( begin (), end ())); } decltype ( auto ) maxElement () const { return _data [ maxElementIndex ()]; } decltype ( auto ) begin () { return _data . begin (); } decltype ( auto ) begin () const { return _data . begin (); } decltype ( auto ) end () { return _data . end (); } decltype ( auto ) end () const { return _data . end (); } friend bool operator == ( const Derived & a , const Derived & b ) { return a . _data == b . _data ; } friend bool operator != ( const Derived & a , const Derived & b ) { return a . _data != b . _data ; } friend Derived max ( const Derived & v1 , const Derived & v2 ) { Derived ret = v1 ; for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = std :: max ( ret [ i ], v2 [ i ]); return ret ; } friend Derived min ( const Derived & v1 , const Derived & v2 ) { Derived ret = v1 ; for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = std :: min ( ret [ i ], v2 [ i ]); return ret ; } friend Derived normalize ( const Derived & v ) { return v . normalized (); } decltype ( auto ) normalized () const { return derived () / norm (); } Derived & normalize () { derived () = normalized (); return derived (); } template < typename OtherDerived > decltype ( auto ) dot ( const VectorBase < T , S , OtherDerived > & rhs ) const { return std :: inner_product ( begin (), end (), rhs . begin (), T {}); } decltype ( auto ) squaredNorm () const { return this -> dot ( * this ); } decltype ( auto ) norm () const { return std :: sqrt ( squaredNorm ()); } decltype ( auto ) length () const { return norm (); } friend decltype ( auto ) distance ( const Derived & a , const Derived & b ) { return ( a - b ). length (); } friend decltype ( auto ) abs ( const Derived & v ) { Derived ret = v ; for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = std :: abs ( ret [ i ]); return ret ; } Derived cross ( const Derived & rhs ) const { static_assert ( S == 3 , \"only 3d vector support cross product\" ); return Derived {( y () * rhs . z ()) - ( z () * rhs . y ()), ( z () * rhs . x ()) - ( x () * rhs . z ()), ( x () * rhs . y ()) - ( y () * rhs . x ())}; } [[ nodiscard ]] bool isZero () const { return std :: all_of ( begin (), end (), []( const T & v ) { return v == 0 ; }); } friend Derived sqrt ( const Derived & v ) { Derived ret = v ; for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = static_cast < T > ( std :: sqrt ( ret [ i ])); return ret ; } template < ArithmeticType E > friend Derived pow ( const Derived & v , E e ) { Derived ret = v ; for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = static_cast < T > ( std :: pow ( ret [ i ], e )); return ret ; } friend Derived exp ( const Derived & v ) { Derived ret = v ; for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = static_cast < T > ( std :: exp ( ret [ i ])); return ret ; } friend Derived floor ( const Derived & v ) { Derived ret = v ; for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = std :: floor ( ret [ i ]); return ret ; } friend Derived ceil ( const Derived & v ) { Derived ret = v ; for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = std :: ceil ( ret [ i ]); return ret ; } operator std :: span < T , S > () { return std :: span { _data }; } operator std :: span < const T , S > () const { return std :: span { _data }; } friend Derived lerp ( const Derived & a , const Derived & b , T t ) { Derived ret ; for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = lerp ( a [ i ], b [ i ], t ); return ret ; } protected : std :: array < T , S > _data ; }; template < ArithmeticType T , size_t S , typename D1 , typename D2 > inline decltype ( auto ) dot ( const VectorBase < T , S , D1 > & a , const VectorBase < T , S , D2 > & b ) { return a . dot ( b ); } } // namespace dakku #endif Updated on 2022-04-11 at 15:27:24 +0000","title":"src/core/vector_base.h"},{"location":"Files/vector__base_8h/#srccorevector_baseh","text":"","title":"src/core/vector_base.h"},{"location":"Files/vector__base_8h/#namespaces","text":"Name dakku dakku namespace","title":"Namespaces"},{"location":"Files/vector__base_8h/#classes","text":"Name class dakku::VectorBase vector base class","title":"Classes"},{"location":"Files/vector__base_8h/#source-code","text":"#ifndef DAKKU_CORE_VECTOR_BASE_H_ #define DAKKU_CORE_VECTOR_BASE_H_ #include <core/logger.h> #include <array> #include <algorithm> #include <string> #include <ostream> #include <numeric> #include <span> namespace dakku { template < ArithmeticType T , size_t S , typename Derived > class VectorBase { public : explicit VectorBase () : _data () {} template < ArithmeticType Arg > VectorBase ( Arg value ) { set ( value ); DAKKU_CHECK ( ! hasNaNs (), \"has nan\" ); } template < ArithmeticType Other , typename OtherDerived > explicit VectorBase ( const VectorBase < Other , S , OtherDerived > & other ) { set ( other ); DAKKU_CHECK ( ! hasNaNs (), \"has nan\" ); } VectorBase ( const VectorBase & other ) : _data ( other . _data ) { DAKKU_CHECK ( ! hasNaNs (), \"has nan\" ); } VectorBase ( VectorBase && other ) noexcept : _data ( std :: move ( other . _data )) { DAKKU_CHECK ( ! hasNaNs (), \"has nan\" ); } VectorBase & operator = ( const VectorBase & other ) { if ( this == & other ) return * this ; _data = other . _data ; DAKKU_CHECK ( ! hasNaNs (), \"has nan\" ); return * this ; } VectorBase & operator = ( VectorBase && other ) noexcept { if ( this == & other ) return * this ; _data = std :: move ( other . _data ); DAKKU_CHECK ( ! hasNaNs (), \"has nan\" ); return * this ; } template < ArithmeticType ... Args > requires ( sizeof ...( Args ) == S ) VectorBase ( Args && ... args ) { set ( std :: forward < Args > ( args )...); } template < ArithmeticType Arg > void set ( Arg value ) { _data . fill ( static_cast < T > ( value )); } template < ArithmeticType Arg > void setByIndex ( size_t index , Arg value ) { DAKKU_CHECK ( 0 <= index && index < S , \"index out of range: {} >= {}\" , index , S ); _data [ index ] = static_cast < T > ( value ); } template < ArithmeticType ... Args , size_t ... Is > requires ( sizeof ...( Args ) == S ) void set ( std :: index_sequence < Is ... > , Args && ... args ) { ( setByIndex ( Is , std :: forward < Args > ( args )), ...); } template < ArithmeticType ... Args > requires ( sizeof ...( Args ) == S ) void set ( Args && ... args ) { set ( std :: index_sequence_for < Args ... > {}, std :: forward < Args > ( args )...); } template < ArithmeticType Other , typename OtherDerived > void set ( const VectorBase < Other , S , OtherDerived > & rhs ) { for ( size_t i = 0 ; i < S ; ++ i ) _data [ i ] = static_cast < T > ( rhs [ i ]); } [[ nodiscard ]] bool hasNaNs () const { return std :: any_of ( std :: begin ( _data ), std :: end ( _data ), []( T x ) { return isNaN ( x ); }); } const T & get ( size_t i ) const { return _data [ i ]; } [[ nodiscard ]] std :: string toString () const { std :: string ret { \"[\" }; for ( size_t i = 0 ; i < _data . size (); ++ i ) { ret += std :: to_string ( _data [ i ]); if ( i + 1 != _data . size ()) ret += \", \" ; } return ret + \"]\" ; } friend std :: ostream & operator << ( std :: ostream & os , const VectorBase & vec ) { return os << vec . toString (); } [[ nodiscard ]] size_t size () const { return S ; } const T & operator []( size_t i ) const { return _data [ i ]; } T & operator []( size_t i ) { return const_cast < T &> ( static_cast < const VectorBase &> ( * this )[ i ]); } Derived operator - () const { Derived ret = derived (); for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = - ret [ i ]; return ret ; } const Derived & derived () const { return static_cast < const Derived &> ( * this ); } Derived & derived () { return const_cast < Derived &> ( static_cast < const VectorBase &> ( * this ). derived ()); } Derived & operator += ( const Derived & rhs ) { for ( size_t i = 0 ; i < S ; ++ i ) _data [ i ] += rhs [ i ]; return derived (); } template < ArithmeticType V > Derived & operator += ( const V & rhs ) { for ( size_t i = 0 ; i < S ; ++ i ) _data [ i ] += rhs ; return derived (); } friend Derived operator + ( const Derived & a , const Derived & b ) { Derived ret = a ; ret += b ; return ret ; } template < ArithmeticType U > friend Derived operator + ( const Derived & a , const U & b ) { Derived ret = a ; ret += b ; return ret ; } template < ArithmeticType U > friend Derived operator + ( const U & a , const Derived & b ) { return b + a ; } Derived & operator -= ( const Derived & rhs ) { for ( size_t i = 0 ; i < S ; ++ i ) _data [ i ] -= rhs [ i ]; return derived (); } template < ArithmeticType V > Derived & operator -= ( const V & rhs ) { for ( size_t i = 0 ; i < S ; ++ i ) _data [ i ] -= rhs ; return derived (); } template < ArithmeticType U > friend Derived operator - ( const Derived & a , const U & b ) { Derived ret = a ; ret -= b ; return ret ; } template < ArithmeticType U > friend Derived operator - ( const U & a , const Derived & b ) { Derived ret = - b ; ret += a ; return ret ; } Derived & operator *= ( const Derived & rhs ) { for ( size_t i = 0 ; i < S ; ++ i ) _data [ i ] *= rhs [ i ]; return derived (); } template < ArithmeticType V > Derived & operator *= ( const V & rhs ) { for ( size_t i = 0 ; i < S ; ++ i ) _data [ i ] *= rhs ; return derived (); } friend Derived operator * ( const Derived & a , const Derived & b ) { Derived ret = a ; ret *= b ; return ret ; } template < ArithmeticType U > friend Derived operator * ( const Derived & a , const U & b ) { Derived ret = a ; ret *= b ; return ret ; } template < ArithmeticType U > friend Derived operator * ( const U & a , const Derived & b ) { return b * a ; } Derived & operator /= ( const Derived & rhs ) { for ( size_t i = 0 ; i < S ; ++ i ) _data [ i ] /= rhs [ i ]; return derived (); } template < ArithmeticType V > Derived & operator /= ( const V & rhs ) { return derived () *= static_cast < T > ( T { 1 } / rhs ); } friend Derived operator / ( const Derived & a , const Derived & b ) { Derived ret = a ; ret /= b ; return ret ; } template < ArithmeticType U > friend Derived operator / ( const Derived & a , const U & b ) { Derived ret = a ; ret /= b ; return ret ; } template < ArithmeticType U > friend Derived operator / ( const U & a , const Derived & b ) { return Derived ( a ) / b ; } [[ nodiscard ]] std :: vector < float > toFloatVector () const { std :: vector < float > ret ( S ); for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = static_cast < float > ( _data [ i ]); return ret ; } VectorBase ( const std :: vector < float > & v ) { DAKKU_CHECK ( v . size () == S , \"invalid vector size: {}, expected: {}\" , v . size (), S ); for ( size_t i = 0 ; i < S ; ++ i ) _data [ i ] = static_cast < T > ( v [ i ]); } decltype ( auto ) x () const { static_assert ( S >= 1 , \"not enough size to get x\" ); return _data [ 0 ]; } decltype ( auto ) x () { static_assert ( S >= 1 , \"not enough size to get x\" ); return _data [ 0 ]; } decltype ( auto ) y () const { static_assert ( S >= 2 , \"not enough size to get y\" ); return _data [ 1 ]; } decltype ( auto ) y () { static_assert ( S >= 2 , \"not enough size to get y\" ); return _data [ 1 ]; } decltype ( auto ) z () const { static_assert ( S >= 3 , \"not enough size to get z\" ); return _data [ 2 ]; } decltype ( auto ) z () { static_assert ( S >= 3 , \"not enough size to get w\" ); return _data [ 2 ]; } decltype ( auto ) w () const { static_assert ( S >= 4 , \"not enough size to get w\" ); return _data [ 3 ]; } decltype ( auto ) w () { static_assert ( S >= 4 , \"not enough size to get z\" ); return _data [ 3 ]; } [[ nodiscard ]] size_t maxElementIndex () const { return std :: distance ( begin (), std :: max_element ( begin (), end ())); } decltype ( auto ) maxElement () const { return _data [ maxElementIndex ()]; } decltype ( auto ) begin () { return _data . begin (); } decltype ( auto ) begin () const { return _data . begin (); } decltype ( auto ) end () { return _data . end (); } decltype ( auto ) end () const { return _data . end (); } friend bool operator == ( const Derived & a , const Derived & b ) { return a . _data == b . _data ; } friend bool operator != ( const Derived & a , const Derived & b ) { return a . _data != b . _data ; } friend Derived max ( const Derived & v1 , const Derived & v2 ) { Derived ret = v1 ; for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = std :: max ( ret [ i ], v2 [ i ]); return ret ; } friend Derived min ( const Derived & v1 , const Derived & v2 ) { Derived ret = v1 ; for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = std :: min ( ret [ i ], v2 [ i ]); return ret ; } friend Derived normalize ( const Derived & v ) { return v . normalized (); } decltype ( auto ) normalized () const { return derived () / norm (); } Derived & normalize () { derived () = normalized (); return derived (); } template < typename OtherDerived > decltype ( auto ) dot ( const VectorBase < T , S , OtherDerived > & rhs ) const { return std :: inner_product ( begin (), end (), rhs . begin (), T {}); } decltype ( auto ) squaredNorm () const { return this -> dot ( * this ); } decltype ( auto ) norm () const { return std :: sqrt ( squaredNorm ()); } decltype ( auto ) length () const { return norm (); } friend decltype ( auto ) distance ( const Derived & a , const Derived & b ) { return ( a - b ). length (); } friend decltype ( auto ) abs ( const Derived & v ) { Derived ret = v ; for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = std :: abs ( ret [ i ]); return ret ; } Derived cross ( const Derived & rhs ) const { static_assert ( S == 3 , \"only 3d vector support cross product\" ); return Derived {( y () * rhs . z ()) - ( z () * rhs . y ()), ( z () * rhs . x ()) - ( x () * rhs . z ()), ( x () * rhs . y ()) - ( y () * rhs . x ())}; } [[ nodiscard ]] bool isZero () const { return std :: all_of ( begin (), end (), []( const T & v ) { return v == 0 ; }); } friend Derived sqrt ( const Derived & v ) { Derived ret = v ; for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = static_cast < T > ( std :: sqrt ( ret [ i ])); return ret ; } template < ArithmeticType E > friend Derived pow ( const Derived & v , E e ) { Derived ret = v ; for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = static_cast < T > ( std :: pow ( ret [ i ], e )); return ret ; } friend Derived exp ( const Derived & v ) { Derived ret = v ; for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = static_cast < T > ( std :: exp ( ret [ i ])); return ret ; } friend Derived floor ( const Derived & v ) { Derived ret = v ; for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = std :: floor ( ret [ i ]); return ret ; } friend Derived ceil ( const Derived & v ) { Derived ret = v ; for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = std :: ceil ( ret [ i ]); return ret ; } operator std :: span < T , S > () { return std :: span { _data }; } operator std :: span < const T , S > () const { return std :: span { _data }; } friend Derived lerp ( const Derived & a , const Derived & b , T t ) { Derived ret ; for ( size_t i = 0 ; i < S ; ++ i ) ret [ i ] = lerp ( a [ i ], b [ i ], t ); return ret ; } protected : std :: array < T , S > _data ; }; template < ArithmeticType T , size_t S , typename D1 , typename D2 > inline decltype ( auto ) dot ( const VectorBase < T , S , D1 > & a , const VectorBase < T , S , D2 > & b ) { return a . dot ( b ); } } // namespace dakku #endif Updated on 2022-04-11 at 15:27:24 +0000","title":"Source code"},{"location":"Modules/","text":"Modules Updated on 2022-04-11 at 15:27:24 +0000","title":"Modules"},{"location":"Modules/#modules","text":"Updated on 2022-04-11 at 15:27:24 +0000","title":"Modules"},{"location":"Namespaces/","text":"Namespaces namespace dakku dakku namespace namespace std namespace pmr Updated on 2022-04-11 at 15:27:24 +0000","title":"Namespaces"},{"location":"Namespaces/#namespaces","text":"namespace dakku dakku namespace namespace std namespace pmr Updated on 2022-04-11 at 15:27:24 +0000","title":"Namespaces"},{"location":"Namespaces/namespacedakku/","text":"dakku dakku namespace Classes Name class dakku::BlockedArray blocked array \\(s \\times s\\) elements are layout together (linear), where \\(s\\) is the block size, then block by block linear layout block size \\(s\\) is power of \\(2\\) This improves the performance for looking up nearby elements (for texture) class dakku::Bounds2 2d bounding box class dakku::Bounds2iIterator 2d integer bounds iterator, iterate all pixels inside class dakku::Bounds3 3d bounding box class dakku::BoundsBase bounding box base class dakku::BoxFilter box filter the box filter is simple, just return \\(1\\) for all values class dakku::Class RTTI support. class dakku::CoefficientSpectrum coefficient spectrum class dakku::ConstantTexture class dakku::FileInputStream file input stream class dakku::FileOutputStream file output stream class dakku::Film film class class dakku::FilmImageProvider class dakku::FilmTile film tile struct dakku::FilmTilePixel film tile pixel class dakku::Filter filter class all filters are centered at origin \\((0, 0)\\) and defined a radius beyond which they have a value of \\(0\\) this width may be different in the \\(x\\) and \\(y\\) directions class dakku::GuiEngine class dakku::ImageTexture class dakku::InputStream input stream struct dakku::Interaction interaction class dakku::L1CacheLineAlignedResource memory resource that at least aligned with L1 cache line size class dakku::Logger logger class struct dakku::Matrix4x4 4x4 matrix class dakku::MemoryArena memory arena class dakku::MipMap mipmap class class dakku::Normal normal class dakku::Object Object class, RTTI support. class dakku::OutputStream output stream class dakku::Point point class dakku::Property property class, containing many data types, similar to json class dakku::Ray ray class dakku::RayDifferential differential ray class dakku::RelativeRoot utility to retrieve relative path (used for scene loading and saving) struct dakku::ResampleWeight resample weight of the four nearby (continuous) texels class dakku::RgbSpectrum spectrum that only use r, g, b class dakku::SerializableObject serializable object class dakku::Shape class dakku::SurfaceInteraction surface interaction class dakku::Texture class dakku::TextureMapping2D 2d texture mapping class dakku::Transform class dakku::TriangleFilter triangle filter the weight falls off linearly from the filter center over the square extent of the filter class dakku::UvMapping2D class dakku::Vector vector class dakku::VectorBase vector base class Types Name enum class ImageWrapMode { REPEAT, BLACK, CLAMP} image wrap mode enum class PropertyType { NONE, ARRAY, OBJECT, NUMBER, STRING, VECTOR, TRANSFORM} property type using Bounds2 < float > Bounds2f 2d float bounds using Bounds2 < int > Bounds2i 2d int bounds using Bounds3 < float > Bounds3f 3d float bounds using RgbSpectrum Spectrum Spectrum type: use RgbSpectrum . template <ArithmeticType T> using Vector < T, 2 > Vector2 2d vectors template <ArithmeticType T> using Vector < T, 3 > Vector3 3d vectors using Vector2 < float > Vector2f 2d float vector using Vector3 < float > Vector3f 3d float vector template <ArithmeticType T> using Point < T, 2 > Point2 2d point template <ArithmeticType T> using Point < T, 3 > Point3 3d point using Point2 < float > Point2f 2d float point using Point2 < int > Point2i 2d int point using Point3 < float > Point3f 3d float point template <ArithmeticType T> using Normal < T, 3 > Normal3 3d normal using Normal3 < float > Normal3f 3d float normal Functions Name DAKKU_EXPORT_OBJECTS (Core , Object , InputStream , OutputStream , SerializableObject , Filter , Film , Texture ) Bounds2iIterator begin (const Bounds2i & b) begin of the bounds2i iteration Bounds2iIterator end (const Bounds2i & b) end of the bounds2i iteration template <typename T > DAKKU_INLINE bool isNaN (T x) check whether x is not a number template <typename T > DAKKU_INLINE bool isNaN (T ) check whether x is not a number float radians (float deg) convert degrees to radians float degrees (float rad) convert radians to degrees template <typename T > constexpr bool isPowerOf2 (T v) check whether v is power of 2 std::int32_t roundUpPow2 (std::int32_t v) round up to nearest value which is power of 2 float evalLanczos (float x, float tau =2) int log2Int (std::int32_t v) \\(\\lfloor \\log_2 v \\rfloor\\) int log2Int (std::int64_t v) \\(\\lfloor \\log_2 v \\rfloor\\) template <ArithmeticType T> T lerp (T a, T b, T t) linear interpolation doTrilinear (doTrilinear ) maxAnisotropy (maxAnisotropy ) wrapMode (wrapMode ) template <typename... Args> void registerObjects () Point3f offsetRayOrigin (const Point3f & p, const Normal3f & n, const Vector3f & w) offset ray origin void xyzToRgb (std::span< const float, 3 > xyz, std::span< float, 3 > rgb) xyz to rgb void rgbToXyz (std::span< const float, 3 > rgb, std::span< float, 3 > xyz) rgb to xyz DAKKU_EXPORT_CORE Transform translate (const Vector3f & delta) translate DAKKU_EXPORT_CORE Transform scale (float x, float y, float z) scale DAKKU_EXPORT_CORE Transform rotateX (float theta) rotate through x axis DAKKU_EXPORT_CORE Transform rotateY (float theta) rotate through y axis DAKKU_EXPORT_CORE Transform rotateZ (float theta) rotate through z axis DAKKU_EXPORT_CORE Transform rotate (float theta, const Vector3f & axis) rotate through axis DAKKU_EXPORT_CORE Transform lookAt (const Point3f & pos, const Point3f & look, const Vector3f & refUp) look at DAKKU_EXPORT_CORE Transform perspective (float fov, float zNear, float zFar) perspective transform template <ArithmeticType T,size_t S,typename D1 ,typename D2 > decltype(auto) dot (const VectorBase < T, S, D1 > & a, const VectorBase < T, S, D2 > & b) dot product between two vectors DAKKU_EXPORT_OBJECTS (Filters , BoxFilter , TriangleFilter ) float gammaCorrect (float value) gamma correction float inverseGammaCorrect (float value) inverse gamma correction DAKKU_EXPORT_IMAGEIO bool writeImage (const std::filesystem::path & path, const float * rgb, int totalResX, int totalResY, int outBoundsMinX =0, int outBoundsMinY =0, int outBoundsMaxX =-1, int outBoundsMaxY =-1) write image to path DAKKU_EXPORT_IMAGEIO float * readImage (const std::filesystem::path & path, int & resX, int & resY, bool flipVertical =true, int gamma =-1, float scale =1) read image from file need to free memory manually DAKKU_EXPORT_OBJECTS (Stream , FileOutputStream , FileInputStream ) DAKKU_EXPORT_OBJECTS (Textures , ConstantTexture ) Attributes Name constexpr float INF infinity constexpr float PI PI. constexpr size_t L1_CACHE_LINE_SIZE L1 cache line size. constexpr float SHADOW_EPS shadow epsilon, used for shadow ray, offset ray origin class DAKKU_EXPORT_CORE RelativeRoot class DAKKU_EXPORT_CORE InputStream class DAKKU_EXPORT_CORE OutputStream class DAKKU_EXPORT_CORE Property class DAKKU_EXPORT_CORE Class class DAKKU_EXPORT_CORE Object struct DAKKU_EXPORT_CORE Matrix4x4 class DAKKU_EXPORT_CORE Filter class DAKKU_EXPORT_CORE Film class DAKKU_EXPORT_CORE Shape class DAKKU_EXPORT_CORE Texture pad0 Types Documentation enum ImageWrapMode Enumerator Value Description REPEAT BLACK CLAMP image wrap mode enum PropertyType Enumerator Value Description NONE ARRAY OBJECT NUMBER STRING VECTOR TRANSFORM property type using Bounds2f using dakku :: Bounds2f = typedef Bounds2 < float > ; 2d float bounds using Bounds2i using dakku :: Bounds2i = typedef Bounds2 < int > ; 2d int bounds using Bounds3f using dakku :: Bounds3f = typedef Bounds3 < float > ; 3d float bounds using Spectrum using dakku :: Spectrum = typedef RgbSpectrum ; Spectrum type: use RgbSpectrum . using Vector2 template < ArithmeticType T > using dakku :: Vector2 = typedef Vector < T , 2 > ; 2d vectors Template Parameters : T data type using Vector3 template < ArithmeticType T > using dakku :: Vector3 = typedef Vector < T , 3 > ; 3d vectors Template Parameters : T data type using Vector2f using dakku :: Vector2f = typedef Vector2 < float > ; 2d float vector using Vector3f using dakku :: Vector3f = typedef Vector3 < float > ; 3d float vector using Point2 template < ArithmeticType T > using dakku :: Point2 = typedef Point < T , 2 > ; 2d point Template Parameters : T data type using Point3 template < ArithmeticType T > using dakku :: Point3 = typedef Point < T , 3 > ; 3d point Template Parameters : T data type using Point2f using dakku :: Point2f = typedef Point2 < float > ; 2d float point using Point2i using dakku :: Point2i = typedef Point2 < int > ; 2d int point using Point3f using dakku :: Point3f = typedef Point3 < float > ; 3d float point using Normal3 template < ArithmeticType T > using dakku :: Normal3 = typedef Normal < T , 3 > ; 3d normal Template Parameters : T data type using Normal3f using dakku :: Normal3f = typedef Normal3 < float > ; 3d float normal Functions Documentation function DAKKU_EXPORT_OBJECTS DAKKU_EXPORT_OBJECTS ( Core , Object , InputStream , OutputStream , SerializableObject , Filter , Film , Texture ) function begin inline Bounds2iIterator begin ( const Bounds2i & b ) begin of the bounds2i iteration function end inline Bounds2iIterator end ( const Bounds2i & b ) end of the bounds2i iteration function isNaN template < typename T > DAKKU_INLINE bool isNaN ( T x ) check whether x is not a number Parameters : x given value Template Parameters : T type (floating point) Return : whether x is nan function isNaN template < typename T > DAKKU_INLINE bool isNaN ( T ) check whether x is not a number Template Parameters : T type (integer) Return : false (all integers are not nans) function radians inline float radians ( float deg ) convert degrees to radians Parameters : deg given degree Return : the radian of deg function degrees inline float degrees ( float rad ) convert radians to degrees Parameters : rad the given radian Return : the degree of rad function isPowerOf2 template < typename T > inline constexpr bool isPowerOf2 ( T v ) check whether v is power of 2 Parameters : v value Template Parameters : T integer type function roundUpPow2 inline std :: int32_t roundUpPow2 ( std :: int32_t v ) round up to nearest value which is power of 2 function evalLanczos inline float evalLanczos ( float x , float tau = 2 ) function log2Int inline int log2Int ( std :: int32_t v ) \\(\\lfloor \\log_2 v \\rfloor\\) function log2Int inline int log2Int ( std :: int64_t v ) \\(\\lfloor \\log_2 v \\rfloor\\) function lerp template < ArithmeticType T > inline T lerp ( T a , T b , T t ) linear interpolation function doTrilinear doTrilinear ( doTrilinear ) function maxAnisotropy maxAnisotropy ( maxAnisotropy ) function wrapMode wrapMode ( wrapMode ) function registerObjects template < typename ... Args > inline void registerObjects () function offsetRayOrigin inline Point3f offsetRayOrigin ( const Point3f & p , const Normal3f & n , const Vector3f & w ) offset ray origin Parameters : p ray origin n normal w direction Return : the origin after offset function xyzToRgb inline void xyzToRgb ( std :: span < const float , 3 > xyz , std :: span < float , 3 > rgb ) xyz to rgb function rgbToXyz inline void rgbToXyz ( std :: span < const float , 3 > rgb , std :: span < float , 3 > xyz ) rgb to xyz function translate DAKKU_EXPORT_CORETransform translate ( const Vector3f & delta ) translate function scale DAKKU_EXPORT_CORETransform scale ( float x , float y , float z ) scale function rotateX DAKKU_EXPORT_CORETransform rotateX ( float theta ) rotate through x axis function rotateY DAKKU_EXPORT_CORETransform rotateY ( float theta ) rotate through y axis Parameters : theta Return : DAKKU_EXPORT_CORE function rotateZ DAKKU_EXPORT_CORETransform rotateZ ( float theta ) rotate through z axis Parameters : theta Return : DAKKU_EXPORT_CORE function rotate DAKKU_EXPORT_CORETransform rotate ( float theta , const Vector3f & axis ) rotate through axis Parameters : theta angle axis given axis function lookAt DAKKU_EXPORT_CORETransform lookAt ( const Point3f & pos , const Point3f & look , const Vector3f & refUp ) look at Parameters : pos camera position look camera look direction refUp reference up vector function perspective DAKKU_EXPORT_CORETransform perspective ( float fov , float zNear , float zFar ) perspective transform Parameters : fov field of view zNear far plane z zFar near plane z the shorter edge mapped to [-1, 1], the longer [-ratio, ratio] left handed function dot template < ArithmeticType T , size_t S , typename D1 , typename D2 > inline decltype ( auto ) dot ( const VectorBase < T , S , D1 > & a , const VectorBase < T , S , D2 > & b ) dot product between two vectors Parameters : a \\(\\vec a\\) b \\(\\vec b\\) Return : \\(\\vec a \\cdot \\vec b\\) function DAKKU_EXPORT_OBJECTS DAKKU_EXPORT_OBJECTS ( Filters , BoxFilter , TriangleFilter ) function gammaCorrect inline float gammaCorrect ( float value ) gamma correction function inverseGammaCorrect inline float inverseGammaCorrect ( float value ) inverse gamma correction function writeImage DAKKU_EXPORT_IMAGEIO bool writeImage ( const std :: filesystem :: path & path , const float * rgb , int totalResX , int totalResY , int outBoundsMinX = 0 , int outBoundsMinY = 0 , int outBoundsMaxX = -1 , int outBoundsMaxY = -1 ) write image to path Parameters : path file path totalResX total resolution x (width) totalResY total resolution y (height) outBoundsMinX crop window bounds (pMin.x) outBoundsMinY crop window bounds (pMin.y) outBoundsMaxX crop window bounds (pMax.x) outBoundsMaxY crop window bounds (pMax.y) function readImage DAKKU_EXPORT_IMAGEIO float * readImage ( const std :: filesystem :: path & path , int & resX , int & resY , bool flipVertical = true , int gamma = -1 , float scale = 1 ) read image from file need to free memory manually Parameters : path image file path rgb image buffer resX image resolution x (width) resY image resolution y (height) flipVertical flip y gamma do inverse gamma correction: -1 auto, 0 not, 1 do scale scale the image value function DAKKU_EXPORT_OBJECTS DAKKU_EXPORT_OBJECTS ( Stream , FileOutputStream , FileInputStream ) function DAKKU_EXPORT_OBJECTS DAKKU_EXPORT_OBJECTS ( Textures , ConstantTexture ) Attributes Documentation variable INF static constexpr float INF = std :: numeric_limits < float >:: infinity (); infinity variable PI static constexpr float PI = std :: numbers :: pi_v < float > ; PI. variable L1_CACHE_LINE_SIZE static constexpr size_t L1_CACHE_LINE_SIZE = 64 ; L1 cache line size. variable SHADOW_EPS static constexpr float SHADOW_EPS = 1e-4f ; shadow epsilon, used for shadow ray, offset ray origin variable RelativeRoot class DAKKU_EXPORT_CORE RelativeRoot ; variable InputStream class DAKKU_EXPORT_CORE InputStream ; variable OutputStream class DAKKU_EXPORT_CORE OutputStream ; variable Property class DAKKU_EXPORT_CORE Property ; variable Class class DAKKU_EXPORT_CORE Class ; variable Object class DAKKU_EXPORT_CORE Object ; variable Matrix4x4 struct DAKKU_EXPORT_CORE Matrix4x4 ; variable Filter class DAKKU_EXPORT_CORE Filter ; variable Film class DAKKU_EXPORT_CORE Film ; variable Shape class DAKKU_EXPORT_CORE Shape ; variable Texture class DAKKU_EXPORT_CORE Texture ; variable pad0 __pad0__ ; Updated on 2022-04-11 at 15:27:23 +0000","title":"dakku"},{"location":"Namespaces/namespacedakku/#dakku","text":"dakku namespace","title":"dakku"},{"location":"Namespaces/namespacedakku/#classes","text":"Name class dakku::BlockedArray blocked array \\(s \\times s\\) elements are layout together (linear), where \\(s\\) is the block size, then block by block linear layout block size \\(s\\) is power of \\(2\\) This improves the performance for looking up nearby elements (for texture) class dakku::Bounds2 2d bounding box class dakku::Bounds2iIterator 2d integer bounds iterator, iterate all pixels inside class dakku::Bounds3 3d bounding box class dakku::BoundsBase bounding box base class dakku::BoxFilter box filter the box filter is simple, just return \\(1\\) for all values class dakku::Class RTTI support. class dakku::CoefficientSpectrum coefficient spectrum class dakku::ConstantTexture class dakku::FileInputStream file input stream class dakku::FileOutputStream file output stream class dakku::Film film class class dakku::FilmImageProvider class dakku::FilmTile film tile struct dakku::FilmTilePixel film tile pixel class dakku::Filter filter class all filters are centered at origin \\((0, 0)\\) and defined a radius beyond which they have a value of \\(0\\) this width may be different in the \\(x\\) and \\(y\\) directions class dakku::GuiEngine class dakku::ImageTexture class dakku::InputStream input stream struct dakku::Interaction interaction class dakku::L1CacheLineAlignedResource memory resource that at least aligned with L1 cache line size class dakku::Logger logger class struct dakku::Matrix4x4 4x4 matrix class dakku::MemoryArena memory arena class dakku::MipMap mipmap class class dakku::Normal normal class dakku::Object Object class, RTTI support. class dakku::OutputStream output stream class dakku::Point point class dakku::Property property class, containing many data types, similar to json class dakku::Ray ray class dakku::RayDifferential differential ray class dakku::RelativeRoot utility to retrieve relative path (used for scene loading and saving) struct dakku::ResampleWeight resample weight of the four nearby (continuous) texels class dakku::RgbSpectrum spectrum that only use r, g, b class dakku::SerializableObject serializable object class dakku::Shape class dakku::SurfaceInteraction surface interaction class dakku::Texture class dakku::TextureMapping2D 2d texture mapping class dakku::Transform class dakku::TriangleFilter triangle filter the weight falls off linearly from the filter center over the square extent of the filter class dakku::UvMapping2D class dakku::Vector vector class dakku::VectorBase vector base class","title":"Classes"},{"location":"Namespaces/namespacedakku/#types","text":"Name enum class ImageWrapMode { REPEAT, BLACK, CLAMP} image wrap mode enum class PropertyType { NONE, ARRAY, OBJECT, NUMBER, STRING, VECTOR, TRANSFORM} property type using Bounds2 < float > Bounds2f 2d float bounds using Bounds2 < int > Bounds2i 2d int bounds using Bounds3 < float > Bounds3f 3d float bounds using RgbSpectrum Spectrum Spectrum type: use RgbSpectrum . template <ArithmeticType T> using Vector < T, 2 > Vector2 2d vectors template <ArithmeticType T> using Vector < T, 3 > Vector3 3d vectors using Vector2 < float > Vector2f 2d float vector using Vector3 < float > Vector3f 3d float vector template <ArithmeticType T> using Point < T, 2 > Point2 2d point template <ArithmeticType T> using Point < T, 3 > Point3 3d point using Point2 < float > Point2f 2d float point using Point2 < int > Point2i 2d int point using Point3 < float > Point3f 3d float point template <ArithmeticType T> using Normal < T, 3 > Normal3 3d normal using Normal3 < float > Normal3f 3d float normal","title":"Types"},{"location":"Namespaces/namespacedakku/#functions","text":"Name DAKKU_EXPORT_OBJECTS (Core , Object , InputStream , OutputStream , SerializableObject , Filter , Film , Texture ) Bounds2iIterator begin (const Bounds2i & b) begin of the bounds2i iteration Bounds2iIterator end (const Bounds2i & b) end of the bounds2i iteration template <typename T > DAKKU_INLINE bool isNaN (T x) check whether x is not a number template <typename T > DAKKU_INLINE bool isNaN (T ) check whether x is not a number float radians (float deg) convert degrees to radians float degrees (float rad) convert radians to degrees template <typename T > constexpr bool isPowerOf2 (T v) check whether v is power of 2 std::int32_t roundUpPow2 (std::int32_t v) round up to nearest value which is power of 2 float evalLanczos (float x, float tau =2) int log2Int (std::int32_t v) \\(\\lfloor \\log_2 v \\rfloor\\) int log2Int (std::int64_t v) \\(\\lfloor \\log_2 v \\rfloor\\) template <ArithmeticType T> T lerp (T a, T b, T t) linear interpolation doTrilinear (doTrilinear ) maxAnisotropy (maxAnisotropy ) wrapMode (wrapMode ) template <typename... Args> void registerObjects () Point3f offsetRayOrigin (const Point3f & p, const Normal3f & n, const Vector3f & w) offset ray origin void xyzToRgb (std::span< const float, 3 > xyz, std::span< float, 3 > rgb) xyz to rgb void rgbToXyz (std::span< const float, 3 > rgb, std::span< float, 3 > xyz) rgb to xyz DAKKU_EXPORT_CORE Transform translate (const Vector3f & delta) translate DAKKU_EXPORT_CORE Transform scale (float x, float y, float z) scale DAKKU_EXPORT_CORE Transform rotateX (float theta) rotate through x axis DAKKU_EXPORT_CORE Transform rotateY (float theta) rotate through y axis DAKKU_EXPORT_CORE Transform rotateZ (float theta) rotate through z axis DAKKU_EXPORT_CORE Transform rotate (float theta, const Vector3f & axis) rotate through axis DAKKU_EXPORT_CORE Transform lookAt (const Point3f & pos, const Point3f & look, const Vector3f & refUp) look at DAKKU_EXPORT_CORE Transform perspective (float fov, float zNear, float zFar) perspective transform template <ArithmeticType T,size_t S,typename D1 ,typename D2 > decltype(auto) dot (const VectorBase < T, S, D1 > & a, const VectorBase < T, S, D2 > & b) dot product between two vectors DAKKU_EXPORT_OBJECTS (Filters , BoxFilter , TriangleFilter ) float gammaCorrect (float value) gamma correction float inverseGammaCorrect (float value) inverse gamma correction DAKKU_EXPORT_IMAGEIO bool writeImage (const std::filesystem::path & path, const float * rgb, int totalResX, int totalResY, int outBoundsMinX =0, int outBoundsMinY =0, int outBoundsMaxX =-1, int outBoundsMaxY =-1) write image to path DAKKU_EXPORT_IMAGEIO float * readImage (const std::filesystem::path & path, int & resX, int & resY, bool flipVertical =true, int gamma =-1, float scale =1) read image from file need to free memory manually DAKKU_EXPORT_OBJECTS (Stream , FileOutputStream , FileInputStream ) DAKKU_EXPORT_OBJECTS (Textures , ConstantTexture )","title":"Functions"},{"location":"Namespaces/namespacedakku/#attributes","text":"Name constexpr float INF infinity constexpr float PI PI. constexpr size_t L1_CACHE_LINE_SIZE L1 cache line size. constexpr float SHADOW_EPS shadow epsilon, used for shadow ray, offset ray origin class DAKKU_EXPORT_CORE RelativeRoot class DAKKU_EXPORT_CORE InputStream class DAKKU_EXPORT_CORE OutputStream class DAKKU_EXPORT_CORE Property class DAKKU_EXPORT_CORE Class class DAKKU_EXPORT_CORE Object struct DAKKU_EXPORT_CORE Matrix4x4 class DAKKU_EXPORT_CORE Filter class DAKKU_EXPORT_CORE Film class DAKKU_EXPORT_CORE Shape class DAKKU_EXPORT_CORE Texture pad0","title":"Attributes"},{"location":"Namespaces/namespacedakku/#types-documentation","text":"","title":"Types Documentation"},{"location":"Namespaces/namespacedakku/#enum-imagewrapmode","text":"Enumerator Value Description REPEAT BLACK CLAMP image wrap mode","title":"enum ImageWrapMode"},{"location":"Namespaces/namespacedakku/#enum-propertytype","text":"Enumerator Value Description NONE ARRAY OBJECT NUMBER STRING VECTOR TRANSFORM property type","title":"enum PropertyType"},{"location":"Namespaces/namespacedakku/#using-bounds2f","text":"using dakku :: Bounds2f = typedef Bounds2 < float > ; 2d float bounds","title":"using Bounds2f"},{"location":"Namespaces/namespacedakku/#using-bounds2i","text":"using dakku :: Bounds2i = typedef Bounds2 < int > ; 2d int bounds","title":"using Bounds2i"},{"location":"Namespaces/namespacedakku/#using-bounds3f","text":"using dakku :: Bounds3f = typedef Bounds3 < float > ; 3d float bounds","title":"using Bounds3f"},{"location":"Namespaces/namespacedakku/#using-spectrum","text":"using dakku :: Spectrum = typedef RgbSpectrum ; Spectrum type: use RgbSpectrum .","title":"using Spectrum"},{"location":"Namespaces/namespacedakku/#using-vector2","text":"template < ArithmeticType T > using dakku :: Vector2 = typedef Vector < T , 2 > ; 2d vectors Template Parameters : T data type","title":"using Vector2"},{"location":"Namespaces/namespacedakku/#using-vector3","text":"template < ArithmeticType T > using dakku :: Vector3 = typedef Vector < T , 3 > ; 3d vectors Template Parameters : T data type","title":"using Vector3"},{"location":"Namespaces/namespacedakku/#using-vector2f","text":"using dakku :: Vector2f = typedef Vector2 < float > ; 2d float vector","title":"using Vector2f"},{"location":"Namespaces/namespacedakku/#using-vector3f","text":"using dakku :: Vector3f = typedef Vector3 < float > ; 3d float vector","title":"using Vector3f"},{"location":"Namespaces/namespacedakku/#using-point2","text":"template < ArithmeticType T > using dakku :: Point2 = typedef Point < T , 2 > ; 2d point Template Parameters : T data type","title":"using Point2"},{"location":"Namespaces/namespacedakku/#using-point3","text":"template < ArithmeticType T > using dakku :: Point3 = typedef Point < T , 3 > ; 3d point Template Parameters : T data type","title":"using Point3"},{"location":"Namespaces/namespacedakku/#using-point2f","text":"using dakku :: Point2f = typedef Point2 < float > ; 2d float point","title":"using Point2f"},{"location":"Namespaces/namespacedakku/#using-point2i","text":"using dakku :: Point2i = typedef Point2 < int > ; 2d int point","title":"using Point2i"},{"location":"Namespaces/namespacedakku/#using-point3f","text":"using dakku :: Point3f = typedef Point3 < float > ; 3d float point","title":"using Point3f"},{"location":"Namespaces/namespacedakku/#using-normal3","text":"template < ArithmeticType T > using dakku :: Normal3 = typedef Normal < T , 3 > ; 3d normal Template Parameters : T data type","title":"using Normal3"},{"location":"Namespaces/namespacedakku/#using-normal3f","text":"using dakku :: Normal3f = typedef Normal3 < float > ; 3d float normal","title":"using Normal3f"},{"location":"Namespaces/namespacedakku/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Namespaces/namespacedakku/#function-dakku_export_objects","text":"DAKKU_EXPORT_OBJECTS ( Core , Object , InputStream , OutputStream , SerializableObject , Filter , Film , Texture )","title":"function DAKKU_EXPORT_OBJECTS"},{"location":"Namespaces/namespacedakku/#function-begin","text":"inline Bounds2iIterator begin ( const Bounds2i & b ) begin of the bounds2i iteration","title":"function begin"},{"location":"Namespaces/namespacedakku/#function-end","text":"inline Bounds2iIterator end ( const Bounds2i & b ) end of the bounds2i iteration","title":"function end"},{"location":"Namespaces/namespacedakku/#function-isnan","text":"template < typename T > DAKKU_INLINE bool isNaN ( T x ) check whether x is not a number Parameters : x given value Template Parameters : T type (floating point) Return : whether x is nan","title":"function isNaN"},{"location":"Namespaces/namespacedakku/#function-isnan_1","text":"template < typename T > DAKKU_INLINE bool isNaN ( T ) check whether x is not a number Template Parameters : T type (integer) Return : false (all integers are not nans)","title":"function isNaN"},{"location":"Namespaces/namespacedakku/#function-radians","text":"inline float radians ( float deg ) convert degrees to radians Parameters : deg given degree Return : the radian of deg","title":"function radians"},{"location":"Namespaces/namespacedakku/#function-degrees","text":"inline float degrees ( float rad ) convert radians to degrees Parameters : rad the given radian Return : the degree of rad","title":"function degrees"},{"location":"Namespaces/namespacedakku/#function-ispowerof2","text":"template < typename T > inline constexpr bool isPowerOf2 ( T v ) check whether v is power of 2 Parameters : v value Template Parameters : T integer type","title":"function isPowerOf2"},{"location":"Namespaces/namespacedakku/#function-rounduppow2","text":"inline std :: int32_t roundUpPow2 ( std :: int32_t v ) round up to nearest value which is power of 2","title":"function roundUpPow2"},{"location":"Namespaces/namespacedakku/#function-evallanczos","text":"inline float evalLanczos ( float x , float tau = 2 )","title":"function evalLanczos"},{"location":"Namespaces/namespacedakku/#function-log2int","text":"inline int log2Int ( std :: int32_t v ) \\(\\lfloor \\log_2 v \\rfloor\\)","title":"function log2Int"},{"location":"Namespaces/namespacedakku/#function-log2int_1","text":"inline int log2Int ( std :: int64_t v ) \\(\\lfloor \\log_2 v \\rfloor\\)","title":"function log2Int"},{"location":"Namespaces/namespacedakku/#function-lerp","text":"template < ArithmeticType T > inline T lerp ( T a , T b , T t ) linear interpolation","title":"function lerp"},{"location":"Namespaces/namespacedakku/#function-dotrilinear","text":"doTrilinear ( doTrilinear )","title":"function doTrilinear"},{"location":"Namespaces/namespacedakku/#function-maxanisotropy","text":"maxAnisotropy ( maxAnisotropy )","title":"function maxAnisotropy"},{"location":"Namespaces/namespacedakku/#function-wrapmode","text":"wrapMode ( wrapMode )","title":"function wrapMode"},{"location":"Namespaces/namespacedakku/#function-registerobjects","text":"template < typename ... Args > inline void registerObjects ()","title":"function registerObjects"},{"location":"Namespaces/namespacedakku/#function-offsetrayorigin","text":"inline Point3f offsetRayOrigin ( const Point3f & p , const Normal3f & n , const Vector3f & w ) offset ray origin Parameters : p ray origin n normal w direction Return : the origin after offset","title":"function offsetRayOrigin"},{"location":"Namespaces/namespacedakku/#function-xyztorgb","text":"inline void xyzToRgb ( std :: span < const float , 3 > xyz , std :: span < float , 3 > rgb ) xyz to rgb","title":"function xyzToRgb"},{"location":"Namespaces/namespacedakku/#function-rgbtoxyz","text":"inline void rgbToXyz ( std :: span < const float , 3 > rgb , std :: span < float , 3 > xyz ) rgb to xyz","title":"function rgbToXyz"},{"location":"Namespaces/namespacedakku/#function-translate","text":"DAKKU_EXPORT_CORETransform translate ( const Vector3f & delta ) translate","title":"function translate"},{"location":"Namespaces/namespacedakku/#function-scale","text":"DAKKU_EXPORT_CORETransform scale ( float x , float y , float z ) scale","title":"function scale"},{"location":"Namespaces/namespacedakku/#function-rotatex","text":"DAKKU_EXPORT_CORETransform rotateX ( float theta ) rotate through x axis","title":"function rotateX"},{"location":"Namespaces/namespacedakku/#function-rotatey","text":"DAKKU_EXPORT_CORETransform rotateY ( float theta ) rotate through y axis Parameters : theta Return : DAKKU_EXPORT_CORE","title":"function rotateY"},{"location":"Namespaces/namespacedakku/#function-rotatez","text":"DAKKU_EXPORT_CORETransform rotateZ ( float theta ) rotate through z axis Parameters : theta Return : DAKKU_EXPORT_CORE","title":"function rotateZ"},{"location":"Namespaces/namespacedakku/#function-rotate","text":"DAKKU_EXPORT_CORETransform rotate ( float theta , const Vector3f & axis ) rotate through axis Parameters : theta angle axis given axis","title":"function rotate"},{"location":"Namespaces/namespacedakku/#function-lookat","text":"DAKKU_EXPORT_CORETransform lookAt ( const Point3f & pos , const Point3f & look , const Vector3f & refUp ) look at Parameters : pos camera position look camera look direction refUp reference up vector","title":"function lookAt"},{"location":"Namespaces/namespacedakku/#function-perspective","text":"DAKKU_EXPORT_CORETransform perspective ( float fov , float zNear , float zFar ) perspective transform Parameters : fov field of view zNear far plane z zFar near plane z the shorter edge mapped to [-1, 1], the longer [-ratio, ratio] left handed","title":"function perspective"},{"location":"Namespaces/namespacedakku/#function-dot","text":"template < ArithmeticType T , size_t S , typename D1 , typename D2 > inline decltype ( auto ) dot ( const VectorBase < T , S , D1 > & a , const VectorBase < T , S , D2 > & b ) dot product between two vectors Parameters : a \\(\\vec a\\) b \\(\\vec b\\) Return : \\(\\vec a \\cdot \\vec b\\)","title":"function dot"},{"location":"Namespaces/namespacedakku/#function-dakku_export_objects_1","text":"DAKKU_EXPORT_OBJECTS ( Filters , BoxFilter , TriangleFilter )","title":"function DAKKU_EXPORT_OBJECTS"},{"location":"Namespaces/namespacedakku/#function-gammacorrect","text":"inline float gammaCorrect ( float value ) gamma correction","title":"function gammaCorrect"},{"location":"Namespaces/namespacedakku/#function-inversegammacorrect","text":"inline float inverseGammaCorrect ( float value ) inverse gamma correction","title":"function inverseGammaCorrect"},{"location":"Namespaces/namespacedakku/#function-writeimage","text":"DAKKU_EXPORT_IMAGEIO bool writeImage ( const std :: filesystem :: path & path , const float * rgb , int totalResX , int totalResY , int outBoundsMinX = 0 , int outBoundsMinY = 0 , int outBoundsMaxX = -1 , int outBoundsMaxY = -1 ) write image to path Parameters : path file path totalResX total resolution x (width) totalResY total resolution y (height) outBoundsMinX crop window bounds (pMin.x) outBoundsMinY crop window bounds (pMin.y) outBoundsMaxX crop window bounds (pMax.x) outBoundsMaxY crop window bounds (pMax.y)","title":"function writeImage"},{"location":"Namespaces/namespacedakku/#function-readimage","text":"DAKKU_EXPORT_IMAGEIO float * readImage ( const std :: filesystem :: path & path , int & resX , int & resY , bool flipVertical = true , int gamma = -1 , float scale = 1 ) read image from file need to free memory manually Parameters : path image file path rgb image buffer resX image resolution x (width) resY image resolution y (height) flipVertical flip y gamma do inverse gamma correction: -1 auto, 0 not, 1 do scale scale the image value","title":"function readImage"},{"location":"Namespaces/namespacedakku/#function-dakku_export_objects_2","text":"DAKKU_EXPORT_OBJECTS ( Stream , FileOutputStream , FileInputStream )","title":"function DAKKU_EXPORT_OBJECTS"},{"location":"Namespaces/namespacedakku/#function-dakku_export_objects_3","text":"DAKKU_EXPORT_OBJECTS ( Textures , ConstantTexture )","title":"function DAKKU_EXPORT_OBJECTS"},{"location":"Namespaces/namespacedakku/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"Namespaces/namespacedakku/#variable-inf","text":"static constexpr float INF = std :: numeric_limits < float >:: infinity (); infinity","title":"variable INF"},{"location":"Namespaces/namespacedakku/#variable-pi","text":"static constexpr float PI = std :: numbers :: pi_v < float > ; PI.","title":"variable PI"},{"location":"Namespaces/namespacedakku/#variable-l1_cache_line_size","text":"static constexpr size_t L1_CACHE_LINE_SIZE = 64 ; L1 cache line size.","title":"variable L1_CACHE_LINE_SIZE"},{"location":"Namespaces/namespacedakku/#variable-shadow_eps","text":"static constexpr float SHADOW_EPS = 1e-4f ; shadow epsilon, used for shadow ray, offset ray origin","title":"variable SHADOW_EPS"},{"location":"Namespaces/namespacedakku/#variable-relativeroot","text":"class DAKKU_EXPORT_CORE RelativeRoot ;","title":"variable RelativeRoot"},{"location":"Namespaces/namespacedakku/#variable-inputstream","text":"class DAKKU_EXPORT_CORE InputStream ;","title":"variable InputStream"},{"location":"Namespaces/namespacedakku/#variable-outputstream","text":"class DAKKU_EXPORT_CORE OutputStream ;","title":"variable OutputStream"},{"location":"Namespaces/namespacedakku/#variable-property","text":"class DAKKU_EXPORT_CORE Property ;","title":"variable Property"},{"location":"Namespaces/namespacedakku/#variable-class","text":"class DAKKU_EXPORT_CORE Class ;","title":"variable Class"},{"location":"Namespaces/namespacedakku/#variable-object","text":"class DAKKU_EXPORT_CORE Object ;","title":"variable Object"},{"location":"Namespaces/namespacedakku/#variable-matrix4x4","text":"struct DAKKU_EXPORT_CORE Matrix4x4 ;","title":"variable Matrix4x4"},{"location":"Namespaces/namespacedakku/#variable-filter","text":"class DAKKU_EXPORT_CORE Filter ;","title":"variable Filter"},{"location":"Namespaces/namespacedakku/#variable-film","text":"class DAKKU_EXPORT_CORE Film ;","title":"variable Film"},{"location":"Namespaces/namespacedakku/#variable-shape","text":"class DAKKU_EXPORT_CORE Shape ;","title":"variable Shape"},{"location":"Namespaces/namespacedakku/#variable-texture","text":"class DAKKU_EXPORT_CORE Texture ;","title":"variable Texture"},{"location":"Namespaces/namespacedakku/#variable-pad0","text":"__pad0__ ; Updated on 2022-04-11 at 15:27:23 +0000","title":"variable pad0"},{"location":"Namespaces/namespacestd/","text":"std Namespaces Name std::pmr Updated on 2022-04-11 at 15:27:23 +0000","title":"std"},{"location":"Namespaces/namespacestd/#std","text":"","title":"std"},{"location":"Namespaces/namespacestd/#namespaces","text":"Name std::pmr Updated on 2022-04-11 at 15:27:23 +0000","title":"Namespaces"},{"location":"Namespaces/namespacestd_1_1pmr/","text":"std::pmr Updated on 2022-04-11 at 15:27:23 +0000","title":"std::pmr"},{"location":"Namespaces/namespacestd_1_1pmr/#stdpmr","text":"Updated on 2022-04-11 at 15:27:23 +0000","title":"std::pmr"},{"location":"Pages/","text":"Pages page dakku documentation page Vector Base Updated on 2022-04-11 at 15:27:24 +0000","title":"Pages"},{"location":"Pages/#pages","text":"page dakku documentation page Vector Base Updated on 2022-04-11 at 15:27:24 +0000","title":"Pages"},{"location":"Pages/vector_base/","text":"Vector Base dakku currently use naive implementation, may use intrinsics and expression templates later. Updated on 2022-04-11 at 15:27:24 +0000","title":"Vector Base"},{"location":"Pages/vector_base/#vector-base","text":"dakku currently use naive implementation, may use intrinsics and expression templates later. Updated on 2022-04-11 at 15:27:24 +0000","title":"Vector Base"}]}